Suffix Tree
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }  Suffix Tree

Suffix tree за низа S с дължина n се дефинира по следния начин:

   * пътищата от корена до листата съвпадат едно към едно с наставките на S
   * в ребрата се съдържат не празни низове
   * всички вътрешни върхове (освен корена) имат поне 2 деца

Такова дърво не съществува за всички низове, затова към края на S се добавя специален символ, който не се среща никъде в низа(обикновенно той се отбелязва с $). Това осигурява да няма наставка, която е представка на друга наставка, и че за всичките n наставки на S ще има по едно листо в Suffix Tree - то. Тъй като всички вътрешни върхове(различни от корена) се разклоняват, може да има най-много n - 1 такива върхове, и n + (n − 1) + 1 = 2n върхове общо.

  Приложения 
Suffix Tree за низа S с дължина n може да бъде построено за време Θ(n), ако азбуката е крайна. В противен случай построяването зависи от конкретната реализация. За оценките по-долу сме допуснали, че азбуката е крайна.
Да предположим, че е построено Suffix Tree-то за низа S с дължина n, или е построено обобщеното Suffix Tree за множеството от низове D = {S1,S2,...,SK} с обща дължина n = | n1 | + | n2 | + ... + | nK |. Тогава можем:

да търсим низове:
Да проверим дали низа P с дължина m е подниз за време O(m).
Да намерим първото срещане на шаблоните P1,...,Pq с обща дължина m като поднизове за време O(m), когато Suffix Tree - то е построено по алгоритъма на Ukkonen.
Да намерим всички z срещания на шаблоните P1,...,Pq с обща дължина m като поднизове за време O(m + z).
Да търсим регулярен израз P за подлинейно време спрямо n.
За всяка наставка на шаблона P, да намерим дължината на най-дългото съвпадение между наставката P[i...m] и подниз в D за време Θ(m)
 да търсим свойства на низове:
Да намерим най-дългия общ подниз на низовете Si и Sj за време Θ(ni + nj).
Да намерим най-всички максимални двойки, максимални повторения или супермаксимални повторения за време Θ(n + z).
Да намерим разбиването на Lempel-Ziv за време Θ(n).
Да намерим най-дългия повтарящ се подниз за време Θ(n).
Да намерим най-често срещания подниз с минимална дължина за време Θ(n)
Да намерим най-късите низове от Σ които не се срещат в D, за време O(n + z), ако има z такива низа.
Да намерим най-късите низове които се срещат само веднъж за време Θ(n).
Да намерим за всяко i, най-късите поднизове на Si които не се срещат никъде в D за време Θ(n).
Suffix Tree - то може да бъде направено за константно по време търсене на най-близък общ предшественик между върховете за време Θ(n)([5] chapter 8). Тогава можем:
Да намерим най-дългата обща представка между наставките Si[p..ni] and Sj[q..nj] за време Θ(1)
Да търсим за шаблон P с дължина m с най много k грешки за време O(kn + z), където z е броя на срещанията
Да намерим всички z максимални палиндрома за време Θ(n)([5] page 198), или за време Θ(gn) ако пропуски с дължина g са допустими,или за време Θ(kn) ако са допустими k грешки
 Suffix Links
Suffix links се използват за построяване на Suffix Tree - то за О(n) време. В пълно Suffix Tree всички вътрешни върхове(различни от корена) имат Suffix link към друг вътрешен връх. Ако пътя от корена до даден връх е низа χα, където χ е знак, а α е низ(може и празен), тогава има Suffix link към вътрешен връх който е за низа α. Suffix links също се използват за някой алгоритми върху Suffix Tree - то. Suffix Linк - вете за низа xabxa са показани на горната картинка с червени стрелки.

 Implicit Suffix Tree 
Implicit suffix tree - то се ползва от алгоритъма на Ukkonen за построяване на Suffix Tree за O(n) време. Implicit suffix tree - то за низа S се получава, когато от Suffix Tree - то на низа S$ се премахнат всички терминални символи $, след това се премахнат ребрата, които са празни, и за край се премахнат и върховете, които нямат поне 2 деца.Implicit suffix tree - то за даден низ S ще има толкова листа, колкото има и Suffix Tree - то за S$ тогава и само тогава ,когато в S няма наставка, която е представка на друга наставка. Въпреки че Implicit Suffix Tree - то може да няма листо за всяка наставка, то съдържа всички наставки на дадения низ.
 Алгоритъм на Ukkonen за построяване на Suffix Tree
Нека имаме низ S с дължина n, за който искаме да построим Suffix Tree.С <math>I_i</math> ще бележим Implicit Suffix tree - то за низа S[1..i] (i <= n). Алгоритъма на Ukkonen строи Implicit Suffix tree <math>I_i</math> за всяка представка на низа S, започвайки от <math>I_1</math> и увеличавайки i докато <math>I_n</math> бъде построено. Suffix tree - то за  S се получава от <math>I_n</math>. По време алгоритъма има сложност О(n). 
Алгоритъма има n фази. Във фазата i+1, дървото <math>I_i+_1</math> се получава от дървото <math>I_i</math>. Всяка фаза е разделена на i+1 разширения, по едно за всяка от i+1 - те наставки на низа S[1..i+1].
Най общо алгоритъма може да бъде описан така:

Построяваме <math>I_1</math>.
For i from 1 to n-1 do
  begin {фаза i+1}
    For j from 1 to i+1
      begin {разширяване j+1}
        Намираме края на пътя от корена който отговаря на низа S[j..i] в текущото дърво. 
        Ако е нужно този път се разширява като се добавя знак S(i+1), 
        което ни гарантира че низа S[j..i+1] е в дървото.
      end;
  end;

Нека S[j..i] = <math>\beta</math>. Тогава по време на раширяване j, когато алгоритъма намери края на <math>\beta</math> в текущото дърво, <math>\beta</math> се раширява до <math>\beta</math>S(i+1).
При това разширяване се използват следните правила:
(В картинките по долу S(i+1) е заменено с x)

Правило 1:В текущото дърво <math>\beta</math> свършва в листо. Знака S(i+1) се добавя в края на реброто, което влиза в това листо.Правило 2:Няма път от края на <math>\beta</math>, който да започва с S(i+1), но поне един непразен път продължава от <math>\beta</math>. В този случай трябвa да бъде създадено листо от края на <math>\beta</math> и на реброто му да бъде дадена стойност S(i+1).Номера на това ново листо е j,защото това листо отговаря за j-тата наставка на S.Правило 3:Някой път от края на <math>\beta</math> започва с S(i+1). Тогава низа <math>\beta</math>S(i+1) вече е в дървото и не правим нищо, защото това е Implicit Suffix Tree и няма нужда за всяка наставка да има листо.Прилагането на тези правила изисква константно време, ако се използва представяне на дървото ляв син - десен брат.
За бързото намиране на края на пътя за даден низ от корена на дървото се използват Suffix Links с оптимизация Skip/Count.По подробно как става това е описано в секция 6.
За постигане на линейна сложност по време алгоритъма на Ukkonen използва някой наблюдения върху следствията от прилагане на дадено правило за разширение. Тези наблюдения са описани в секция 7.

Освен това за достигане на линейна сложност по време не се пазят целите низове в ребрата на дървото а само начален и краен индекс от целия низ. Използване Suffix Links със Skip/Count оптимизация в алгоритъма на Ukkonen
Наивния подход при търсенето на край на низ в Suffix Tree - то е всеки път да тръгваме от корена и така да намираме края. Такава имплементация би довела до сложност по време на алгоритъма на Ukkonen от порядъка на O(<math>n^3</math>). Затова се използват Suffix Links. Тяхната главна идея е, че ако сме стигнали до връх с път x<math>\beta</math>, където х е знак,а <math>\beta</math> е низ (може и празен) и ако в текущия връх имаме Suffix Link, и го последваме, то ще отидем точно във върха, който отговаря на следващата наставка, която ще трябва да търсим, а именно <math>\beta</math>.Следната лема и следствията от нея са от голяма полза при построяването и следването на Suffix Link - вете в алгоритъма на Ukkonen:

Лема 1- Ако нов вътрешен връх v с път x<math>\alpha</math> е добавен в текущото дърво по време на j - тото разширение на i+1 - та фаза, тогава или пътя <math>\alpha</math> вече свършва във вътрешен връх на текущото дърво, или вътрешен връх с път <math>\alpha</math> ще бъде създаден по време на j+1 - то разширение на същата фаза i+1.
Следствие 1- В алгоритъма на Ukkonen, всеки новосъздаден вътрешен връх ще има Suffix Link от него, най-късно до края на следващото разширение.
Следствие 2- Във всяко <math>I_i</math>, ако вътрешен връх v отговаря на пътя x<math>\alpha</math>, тогава съществува връх s(v) от <math>I_i</math> чиито път отговаря на <math>\alpha</math>.

При всяко разшиерение трябва да намерим къде в дървото завършва текущата наставка. Забелязваме, че на първата наставка S[1..i] винаги ще отговаря листо в <math>I_i</math>, защото S[1..i] е най дългия низ който съществува в дървото. При това за тази наставка винаги ще се изпълнява правило 1.От тук следва, че тя винаги ще е най-дългата. Така можем да пазим указател към тази наставка и на всяко първо разширение да намираме първата наставка с константна сложност.За втората наставка гледаме бащата на листото, в което се намираме. Ако това е корена на дървото, ще трябва да се спуснем по наивния начин, за да намерим края на втората наставка.Ако това обаче е вътрешен връх, може да запишем съдържанието на реброто между листото и баща му в gama, след това да последваме Suffix Link - а на баща му и от новия връх да се спуснем и да търсим gama.Тогава gama може да е доста дълъг низ и затова се използва Skip/Count оптимизацията. Тя се възползва от това, че gama със сигурност съществува в подървото на върха до който сме стигнали след като сме проследили Suffix Link - a.Така от текущия връх проверяваме само първия символ на излизащите ребра.Ако той съвпада с първия символ на gama тогава: ако дължината на gama е по-малка или равна от дължината на текущото ребро значи краят на втората наставка се намира в това ребро, иначе повтаряме същата процедура, като преминаваме по реброто,сменяме текущия връх и отбелязваме че от gama са намерени толкова символа, колкото е дължината на реброто, по което сме преминали.
По аналогичен начин тази процедура се повтаря и за всички останали наставки с единствената разлика, че някоя наставка може да завърши във връх със Suffix Link. В такъв случай вместо да се следа Suffix Link - а на бащата се следва Suffix Link - а на текущия връх.
Следната теорема ни дава и ползата от използването на Skip/Count оптимизацията:

Теорема 1-Използвайки Skip/Count оптимизацията,времето за всяка фаза от алгоритъма на Ukkonen е О(n).
Така със Suffix Links и Skip/Count оптимизация достигаме до времева сложност от порядъка на O(<math>n^2</math>) за алгоритъма на Ukkonen.
Така единичното разширяване j >= 2 за фазата i+1 може да се запише със следния псевдокод:

Begin
1.Намираме върха v който е над или в края на S[j-1..i] който или има Suffix Link от него или е корена.
  Това изисква най много едно изкачване.
  Нека с gama(може и празен низ) да означим низа между v и края на S[j-1..i] 
2.Ako v не е корена, проследяваме Suffix Link - а от него до s(v)
  След това продължаваме от s(v) да търсим gama, използвайки Skip/Count оптимизацията.
  Ako v е корена тогава проследяваме пътя за S[j..i] от корена по наивния алгоритъм.
  Не използваме Skip/Count оптимизацията, защото не знаем дали текущия низ е в дървото.
3.Разширяваме дървото с правилата за разширяване, така че S[j..i]S(i+1) да е в дървото. 
4.Ако нов вътрешен връх w е бил създаден по време на j-1 - то разширяване.
  От лемата по горе следва, че на това разширение е създаден върха към който той има Suffix Link.
  Правим този Suffix Link.
End

 Наблюдения върху следствията след прилагане на правила за разширяване в алгоритъма на Ukkonen
Наблюдение 1: Във всяка фаза ако е приложено правило 3 за разширяване по време на j - тото разширение.Тогава правило 3 ще се прилага и във всички разширявания до края на тази фаза.Това е така, защото когато е приложено правило 3, пътя S[j..i] в текущото дърво продължава с S(i+1), но така и пътя S[j+1..i] ще продължи. Правило 3 не прави нищо освен да установява, че дадена наставка вече е в дървото.Тогава достигаме до следната оптимизация:
Оптимизация 1: Прекратяваме всяка фаза i+1 веднага щом приложим правило 3 за първи път в тази фаза.
Наблюдение 2: Щом веднъж един връх е станал листо, то до края той си остава листо. Това е така, защото в алгоритъма няма действие, което да направи от листо вътрешен връх. Нещо повече - щом на дадено листо е даден номер j, тогава алгоритъмът винаги ще прилага първото правило за разширяване към това листо по време на j - тото разширяване на всяка следваща фаза. От това следва, че ако е създадено листо с номер j, то на всяка фаза първите j стъпки ще бъдат прилагане на правило 1 за j-те листа.
Оптимизация 2: Тогава ако въведем една глобална променлива Е за дървото, която показва крайния индекс на влизащато ребро във всяко листо, то j-те разширявания могат да бъдат направени за константно време, като на всяка фаза просто увеличаваме Е с единица.
Така вече с псевдокод може да опишем процедурата за изпълние на i+1-та фаза от алгоритъма:

Begin
1. Увеличаваме променливата E на i+1, така правим всички начални разширения на лисата от 1 до <math>j_i</math>
2. Изпълняваме останалите фази на разширение по алгоритъма за разширяване описан в предната секция,
   започвайки от <math>j_i</math> + 1 докато не достигнем разширение <math>j^*</math> където e приложено правило 3
   или не изпълненим всички разширения за тази фаза
3. Правим <math>j_i+_1</math> да бъде <math>j^*</math> - 1, за да се подготвим за следващата фаза. 
End.

В стъпка 3 на алгоритъма на <math>j_i+_1</math> се дава тази стойност, защото началната последователност от разширения 1 и 2 ще завърши в точката където 3 за първи път е било приложено. 

Теорема 2- Използвайки Suffix Links със Skip/Count оптимизацията, и прилагайки оптимизации 2 и 3, алгоритъма на Ukkonen ще построи <math>I_1</math> до <math>I_n</math> за време от порядъка на O(n)
 Използвани ресурси
Gusfield, Dan [1997] (1999). Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology. USA: Cambridge University Press. ISBN 0-521-58519-8.
Wikipedia, the free encyclopedia
Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Suffix_Tree“.
			Категории: Структури от данни | Advanced Data Structures			
						
		