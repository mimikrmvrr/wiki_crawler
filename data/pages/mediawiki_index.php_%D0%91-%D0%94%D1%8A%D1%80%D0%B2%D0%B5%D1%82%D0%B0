Б-Дървета
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Въведение 
Повечето операции върху дървета като търсене, вмъкване, триене изискват време пропорционално на височината на дървото. 
Затова много полезни са структури като AVL, RB-дървета, Б-дървета, които поддържат баланс на височината от порядъка на logn ,
където n е броят на възлите в дървото.
Б-дърветата са оптималния вариант за ситуации, в които по-голямата част от възлите са разположени върху дисковото пространсво.
Това е така, защото те минимизират броя на достъпите до дисковия носител, поддържайки много малка височина на дървото и пазейки
корена и най-често посещаваните върхове в кеша.

 Структура на Б-дърветата
За разлика от двоичните дървета, Б-дърветата могат да имат произволен брой ключове и деца.Ключовете се съхраняват в нарастващ
ред, като всеки ключ сочи към корена на поддърво с ключове <= от него и > от предишния ключ.Възелът съдържа и допълнително дете,
което е с ключове > от тези в настоящия възел. Свойствата на Б-дърво с изискване за минимален брой ключове >= M-1 трябва да се 
пазят в следните насоки:

 всеки възел(без корена) трябва да има поне M-1 ключа
 корена трябва да има поне две деца
 всеки възел трябва да има най-много 2M-1 ключа
 всеки възел трябва да има най-много 2M деца(децата винаги са с едно повече от ключовете)
 листата имат същите рестрикции за броя на ключовете, но нямат деца
 Основни операции
Основните операции върху Б-дървета са:

търсене
вмъкване
изтриване
 търсене
Търсенето в Б-дърво е почти аналогично на търсенето в двоично дърво. Започваме от корена обхождайки отгоре надолу, обхождаме възела
(може и чрез двоично търсене) в който сме в момента: 

 -така или дадения ключ е '<' най-левия: слизаме ниво надолу по най-левия указател
 -или дадения ключ е '>' от най-десния:  слизаме ниво надолу по най-десния указател
 -или намираме два поредни ключа единия '<' а другия '>': продължаваме едно ниво надолу по указателя между тях
 -или намираме дадения ключ

Търсенето се използва и при следващите два алгоритъма за вмъкване и за изтриване

 вмъкване
Вмъкването става единствено в листата. Имаме следния алгоритъм.

   1. Чрез търсене намираме листото, на което трябва да принадлежи нашия ключ.
   2. Ако то не е пълно(според горните свойства) вмъкваме в него.
   3. Иначе го разделяме на два възела.
      3.1 Вземаме средния елемент във възела
      3.2 Елементите < от средния елемент се поставят в нов възел отляво, а елем. > средния в нов възел вдясно
      3.3 Средния възел се поставя в бащата на разделения възел, което също може да предизвика разделяне

Единственият начин да се стигне до увеличаване на височината на дървото е ако се стигне до разделяне на всички възли от началния път
(пътя извървян за намиране на мястото на дадения ключ), включително корена. Създаването на нов корен не нарушава свойствата на Б-дървото,
тъй като единствено за кореновия възел не важат ограниченията.
Подобрение в алгоритъма може да се получи, ако разделяме всички пълни възли по пътя на търсенето, което обезсмисля обръщенията към бащата.
За този алгоритъм е нужно да се променят малко горните свойства, като за пълен връх да се счита този с 2M елемента.

 изтриване
Има два основни алгоритмични подхода при изтриване на даден елемент.

 Да намерим елемента, да го премахнем и ако се наруши някое от свойствата да реконструираме дървото
 Да обходим дървото и преди да извършим триенето да реконструираме дървото, така че при триене да не се нарушат свойствата му.
Има два специални случая, с които трябва да се съобразим когато изтриваме елемент:

 1. Триенето може да остави възела с по-малко елементи отколкото е позволено
 2. Елемента може да принадлежи на вътрешен възел и да бъде разделител на две деца.

 триене от листо
1.Намиране на елемента който трябва да бъде изтрит.
2.Ако е лист, просто го изтриваме с възможност да възникне случай 1, с който се справяме по-надолу

 триене от вътрешен възел
Тук възникват два случая, с които се справяма така:

if (и двете деца имат точно по М-1(минимума) елементa) ги сливаме в общ възел;
else (вътрешен възел) 
  избираме измежду max от лявото поддърво или min от дясното; 
  качваме избрания елемент на мястото на изтрития елемент;
  премахваме го от старото му място; //може да е вътрешен възел или лист
  if (вътрешен възел) рекурсивно повтаряме триене на вътрешен възел;
  else отиваме на стъпката за триене на листо;

 балансиране след триене
if (братът отдясно има повече елементи от минимума) 
   избираме новия разделител като среден на двата възела;
   слагаме го в бащата;
   разпределяме останалите елементи между лявото и дясното поддърво;
else if (братът отляво има точно минимума) 
  гледаме левия брат и действаме както с десния;
else  (и двата са с минимума) 
  комбинираме първоначалния възел с някой от братята;
  и добавяме разделителя от бащата;
  премахваме сепаратора от бащата;
  и заместваме двете му деца с току що комбинирания възел;
  if (в бащата елементите станат по-малко от минимума)
     почваме отначало;

 Приложения
Заради свойствата си(най-вече поддържане на много малка височина, което е ценно при много данни върху магнитен диск) ,Б-дървото 
и неговите производни се използват за индексиране на таблици в базите данни, и във организацията на файловите системи.
Много от широко използваните софтуерни продукти като Postgres, ReiserFS, NTFS са изградени върху концепциите нa Б-дървото.

 See Also
[ http://en.wikipedia.org/wiki/B-tree  wikipedia B-tree ]
[ http://cis.stvincent.edu/html/tutorials/swd/btree/btree.html - добра статия с много примери и цялостна реализация]
[ http://www.bluerwhite.org/btree/ - повечето от нещата са от Introduction To Algorithms]
 Introduction To Algorithms - Cormen, Leirson, Rivest

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%91-%D0%94%D1%8A%D1%80%D0%B2%D0%B5%D1%82%D0%B0“.
			Категории: Структури от данни | Advanced Data Structures			
						
		