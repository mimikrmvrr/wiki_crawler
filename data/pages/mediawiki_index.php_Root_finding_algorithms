Root finding algorithms  Алгоритми за намиране корените на полиноми  (root – finding algorithms for polynomials) 
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Алгоритми за намиране корените на полиноми  (root – finding algorithms for polynomials) 
Алгоритмите за намиране корените на полиноми са числени методи  за намиране на стойност х , за която f(x) = 0 за някакъв
полином f.  Разгледаните в статията методи са част от много по-широка общност, която се занимава с намиране на корените не само на полиноми, но и на различни класове функции.
За този тип алгоритми е характерно генерирането на редица от стойности , които са сходящи към корен на полинома. Сходимостта може да бъде локална ( тоест алгоритъмът се нуждае от първоначално налучкване на стойност , която е близо до нулата на полинома) , глобална ( съответно, ако не е необходимо задаването на начална стойност) или дори условна – тоест необходимо е полинома да притежава някакви подходящи свойства. Всъщност всеки такъв алгоритъм трябва да бъде прекратен “принудително” след краен брой стъпки, така че разликата между получената стойност и тази на корена да не е по-голяма по абсолютна стойност от някакво първоначално определно приближение Е.
(Предварително искам да отбележа, че предоставените имплементации са в най-общ вид – тоест не разглеждат гранични случаи. Допълнителни проверки и оптимизации могат да се добавят в зависимост от конкретната ситуация.)

  Алгоритми за намиране на произволен корен на полином 
  Алгоритъм чрез отсичане на интервал 
Един от най-лесните начини за намиране на корен на полином (a и на произволна функция) е метода на отсичането ( не трябва да се бърка с метода на секущата описан по-долу ) , който обаче изисква да са в сила следните условия:
--	известни са ни стойности а и b , за които f(a)*f(b) < 0;
--	функцията е непрекъсната в интервала [a,b];
Възможно е да имаме повече от един корен в дадения интервал и дори многократен корен , но въпреки това метода ни гарантира намирането на стойност с  , за която f( c ) = 0 ( с подходящо приближение ). Първоначалното ни налучкване е със стойност с = (a + b)/2. Ако с е корен ( при достатъчно добро приближение ) , то приключваме , иначе избираме или интервала [a,c] , или интервала [c,b] за следваща итерация (в зависимост от това дали f(a)*f(c) < 0 или f(c)*f(b) < 0) и отново продължаваме както в началото (вж. фигурата по-долу).  

 [Фиг.Алгоритъм чрез отсичане на интервал]
 [код на с++] [код на Джава]

Методът чрез отсичане е обобщен от алгоритъма на Лемер – Шур, който намира корен на функция на една комплексна променлива.

  Алгоритъм на секущата 
В основата на метода стои рекурентното отношение:

 xn+1 = xn - f(xn)((xn - xn-1) / (f(xn) - f(xn-1))
Необходими са ни две начални стойности x1 и x2 , които трябва да са достатъчно близо до корен на функцията.xn+1 е точно пресечната точка на правата през точките (xn , f(xn)) и (xn-1 , f(xn-1))  и оста Ох.  Три последователни итерации са показани на фигурата по-долу.

 [Фиг.Алгоритъм на секущата]
 [код на С++] [код на Джава]

Обобщение на метода на секущата за функции на повече от една променлива е алгоритъма на Бройдън.

  Алгоритъм Regula falsi ( Алгоритъм на грешната позиция ) 
Този метод използва свойства от метода чрез отсичане на интервал и метода на секущата. Както и при метода с отсичане започваме с първоначален интервал [a0,b0], така че f(a0)f(b0) < 0 , но самото стесняване на интервала става вече чрез намиране на пресечната точка на оста Ох с правата през точките (а0,f(a0)) и (b0,f(b0))  - следващия интервал се избира както и при метода с отсичане – взима се или [a0,c] ,или [c,b0] в зависимост от това дали f(a0)*f( c ) < 0 или f( c )*f(b0) < 0. Всъщност единствената разлика с метода на отсичането е в определянето на точката c в к-тата итерация:

 ck = (f(bk)ak - f(ak)bk) / (f(bk - f(ak)

 [код на С++] [код на Джава]

  Алгоритъм на Декер 
Алгоритъмът на Декер също комбинира метода чрез отсичане на интервал и метода на секущата (дори е един от първите алгоритми, който го прави). Започва се с интервал [a0,b0], който съдържа корен на функцията (непрекъсната в същия интервал). При метода на Декер обаче се изчисляват и двете стойности съответно за всеки от двата упоменати метода, от които заимства :

 s = bk - f(bk)((bk - bk-1) / (f(bk) - f(bk-1)))
 m = (ak + bk)/2
Освен това трябва да се спазят и следните допълнителни условия:
--	ако в началото си |f(a0)| < |f(b0)| , то разменяме a0 и b0 (  предполагаме, че по-малката по абсолютна стойност от f(a0) и f(b0) е по-добър избор понеже е може би по-близо до корен на f );
--	ако за текущата итерация s е между bk и m , то bk+1 = s, иначе bk+1 = m;
--	ако f(ak) и f(bk+1) имат противоположни знаци, то аk+1 = аk, иначе аk = bk (понеже bk и  bk+1 имат противоположни знаци );
--	повтаряме първото условие за ak+1 и bk+1 (по-малката по абсолютна стойност от f(ak+1) и f(bk+1) );
Условията ни гарантират валидност на интервала за всяка следваща итерация като освен това се стремят да избират оптимално следващия интервал. Проверката в началото за f(a0)*f(b0) < 0 е пропусната в имплементацията – при необходимост може лесно да бъде добавена.

 [код на С++] [код на Джава]

  Алгоритъм на Брент 
Алгоритъмът на Брент е лека модификация на метода на Декер,  която се базира на факта, че може да възникне ситуация, при която на всяка итерация се избира s от метода на секущата вместо m ( вж. Алгоритъм на Декер ), като при това алгоритъмът да бъде и бавно-сходящ ( bk – bk-1 по абсолютна стойност може да е доста малка стойност ). Това би забавило значително работата на алгоритъма в сравнение с метода на отсичащия интервал.  Подобрението, което Брент предлага, е да се прави допълнителна проверка преди да се присвои s за следваща итерация, която се базира на интерполационен метод за намиране на корен на полином, който е описан на [#Wiki1]. Подробно описание на метода може да бъде намерено на [#Wiki2].

 [код на С++] [код на Джава]

  Алгоритъм на Нютон 
Методът на Нютон е може би един от най-познатите методи за последователно по-добро апроксимиране на някоя от нулите на дадена функция. Неслучайно ще го разгледаме, тъй като стои в основата на някои от по-известните алгоритми за намиране корените на даден полином (например методите на Лин–Барстоу, Дуранд-Кернер и Абърт-Ерлих - описани по-долу). В някои ситуации метода е бързо-сходящ, стига разбира се първоначалното ни предложение да се намира достатъчно близо до корен на функцията. Идеята на алгоритъма е съвсем кратка и ясна – започваме с някаква точка x0 от дефиниционното множество на функцията (ще разгледаме по-подробно полиноми и затова приемаме, че х0 е произволна) и на к-тата итерация избираме следваща апроксимация като пресечната точка на допирателната към f(xk) и оста Ох. (на фигурата по-долу са показани 3 последователни апроксимации). Очевидно, ако на някоя итерация x се окаже твърде близо до локален екстремум то следващото х може да избие към +/- ∞ (другата фигура по-долу). Затова е необходимо да правим и допълнителна проверка дали производната в х не е по-малка (по-абсолютна стойност) от някаква достатъчно малка стойност.
Освен това, ако х е корен, то е необходимо на проверим и неговата кратност (тоест до кое n fn(x) e нула, където fn е n-тата прозиводна в точката х).

 [Фиг.1:Алгоритъм на Нютон] [Фиг.2:Алгоритъм на Нютон]
 [код на С++] [код на Джава]

  Алгоритъм на Лин - Барстоу 
Методът на Лин – Барстоу използва метода на Нютон за намиране на коефициенти u и v на квадратното уравнение x^2 + ux + v, такива че неговите корени са корени и на първоначално зададения полином. След това този първоначален полином се разделя на x^2 + ux + v и същото се прилага върху новополучения полином. Този процес продължава докато получения полином след поредната итерация на алгоритъма е от степен <= 2. Забележете, че методът на Нютон се използва за нагласяне на u и v (тоест се прилага върху функция на две променливи). Подробно описание на метода може да се намери на [#Wiki4]. 

 [код на С++] [код на Джава]

Както очевидно се забелязва, алгоритъмът на Лин – Барстоу наследява локалната сходимост от метода на Нютон.

  Алгоритми за последователна апроксимация на всички корени на полином 
  Алгоритъм на Дуранд – Кернер 
Алгоритъмът на Дуранд – Кернер  е един от двата най-разпространени алгоритъма ( заедно с този на Абърт) за едновременнта апроксимация на всички корени на полином на една променлива. Методът използва алгоритъма на Нютон, за да апроксимира едновременно n различни ( първоначално зададени ) точки в комплексната равнина. В основата на метода е следната идея : нека P1 , … , Pn са n – те комплексни корена на полинома f(x)  = (x – P1)(x – P2) … (x – Pn). Ако изнесем кой да е корен от n-те в дясна страна на уравнението (без ограничение на общността нека това е P1) то получаваме :

P1 = x – (f(x) / (x – P2) … (x – Pn)) и ако положим xnext = P1, 
(тоест xnext = x – P(x)/(x – P2) … (x – Pn) ) и изберем произволна стойност за х, различна от P2 …. Pn , то от една стъпка получаваме корена P1. Представете си сега, че в знаменателя вместо P2  , … , Pn в отделните множители имаме p2 , p3 … ,pn като зададени стойности (някакви приближения на корените). Сега, ако заменим вече x с P1 получаваме:

 P1 – (f(P1) / (x – p1) … (x – pn)) = P1 – получихме, че P1 е неподвижна спрямо функцията g(x) = x – f(x)/(x – p1) …. (x-pn).
Сега вече, като използваме този прост факт, получаваме лесен като идея и имплементация алгоритъм за последователно апроксимиране на n – те корена на даден полином (забележете обаче, че е необходима аритметика с комплексни числа). За всяка итерация прилагаме горната апроксимация за всеки от корените на полинома (за p1 , … , pn използваме получените стойности от предната стъпка).

 [код на С++] [код на Джава]

  Алгоритъм на Абърт – Ерлих 
Идеята е сходна с тази от алгоритъма на Дуранд – Кернер , но функцията g(x) е различна :
g(x) = x - ( p(zk) / p'(zk) )/( 1 - ( p(zk) / p'(zk) ).∑k ≠ j(1 / (zk - zj)) )     -    (p' е първата производна на функцията p)

 [код на С++] [код на Джава]
  Други алгоритми 
Ще споменем накратко и по-общи алгоритми за намиране на нулите на дадена фунцкия.

  Алгоритъм на Грефе (алгоритъм на Данделин – Грефе) 
Алгоритъмът на Грефе работи най-добре върху полиноми с прости реални корени, въпреки че може да бъде адаптиран и за полиноми с комплексни корени (и такива с по-голяма четност). Методът използва формулите на Виет за апроксимация на корените. 

  Алгоритъм на Бернули 
Алгоритъмът на Бернули е класически метод за намиране корените на полином, който използва характеристичното уравнение на полинома, за да апросимира корените.

  Алгоритъм на Лагер 
Едно от най–силните качества на метода е, че почти винаги клони към корен на полинома (за разлика от метода на Нютон). Методът използва първата и втората производна на полинома в точка хк (при к-тата итерация), за да апроксимира разстоянието между някой корен х и стойността хк. След като започваме с първоначална произволна стойност х0 не са ни нужни повече от няколко итерации, за да достигнем достатъчно добра точност.

  Алгоритъм на Дженкинс – Трауб 
Алгоритъмът на Дженкинс – Трауб е може би един от стандартите при търсене на корени на полином от общ вид (и по-точно – полиноми, при които не е известно естеството на корените или някакви особени характеристики), чиято добра имплементация обаче е значително трудна. Подробно описание може да бъде намерено на [#Wiki3], a С++ имплементация на [#JTraub].

Голяма част от гореспоменатите методи са имплементирани към програмката WinSolve (към която има и онлайн приложение за намиране на корените на полином). Mоже да послужи за много подходящ тестер на задачи, които по един или друг начин изискват да се намери корен на полином.(може да бъде свалена от [#WSol].

Целият проект на Eclipse (с имплементациите на джава и примери) може да бъде изтеглен от тук.

  Полезни Връзки 
[] http://en.wikipedia.org/wiki/Category:Root-finding_algorithms
[] http://eprints.maths.ox.ac.uk/16/1/mekwi.pdf[WSol] http://www.hvks.com/Numerical/winsolve.html[JeTr] http://lib.org.by/info/0pre-Library/Jenkins,%20Traub.%20Algorithm%20419..%20Zeros%20of%20a%20complex%20polynomial%20(CACM%201972)(3s).djvu#[Wiki1] http://en.wikipedia.org/wiki/Inverse_quadratic_interpolation[Wiki2] http://en.wikipedia.org/wiki/Brent%27s_method[Wiki3] http://en.wikipedia.org/wiki/Jenkins-Traub_algorithm[Wiki4] http://en.wikipedia.org/wiki/Bairstow%27s_method[JTraub] http://www.crbond.com/download/misc/rpoly.cpp




Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Root_finding_algorithms“.
			Категория: Алгоритми			
						
		