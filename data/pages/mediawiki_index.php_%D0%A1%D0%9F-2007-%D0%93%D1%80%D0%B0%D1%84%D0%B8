СП-2007-Графи
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			  Основни понятия 
Краен ориентиран граф ще наричаме двойката (V, E), където:

V = {v1, v2, ... vn} е крайно множество от върхове
E = {e1, e2, ... em} е крайно множество от ориентирани ребра. Всяко ребро представлява наредена двойка (vi, vj), където vi и vj са върхове.

Ако ребрата са неориентирани, т.е. двойките {vi, vj} са ненаредени, тогава графът се нарича неориентиран.
Ако в множеството на ребрата се допускат повторения, тогава говорим за мултиграф.
Ако в допълнение е дадена числова функция f : E -> R, съпоставяща на всяко ребро ek тегло f(ek), тогава графът се нарича претеглен.
Два върха vi и vj ще наричаме съседни ако съществува поне едно от ребрата (vi, vj) или (vj, vi)
Път в граф G(V, E) ще наричаме последователността от върхове v1, v2, ... vk такава, че за всяко i = 1, 2, ... k-1 е изпълнено, че реброто (vi, vi+1) принадлежи на множеството E.
Най-често ориентираните графи се представят графично в равнината чрез множество от точки (кръгчета), означаващи върховете им, и свързващи ги стрелки - ребрата. Ако графът е неориентиран, тогава вместо стрелки ще чертаем линии. 
Ако например:

V = {1, 2, 3, 4, 5, 6, 7, 8, 9}
E = {(1, 2), (1, 3), (1, 5), (2, 6), (3, 4), (3, 7), (4, 6), (4, 7), (5, 6), (5, 8), (6, 9), (7, 9), (8, 9)}

е неориентиран граф, то бихме могли да го представим графично по следния начин:

Примери за графи биха могли да бъдат транспортна карта, компютърна мрежа, страниците в интернет с връзките помежду им и т.н.

  Стандартни представяния на графи 
Има различни начини да представим един граф в компютъра. Тук ще разгледаме два от тях, които са може би най-често използваните.

 матрица на съседство
Матрицата на съседство представлява квадратна матрица A[n][n] (n = |V|), в която стойността на A[i][j] е равна на единица ако съществува реброто (i, j) и нула - в противен случай. Ако графът е претеглен, тогава вместо единица записваме директно съответната тежест на реброто и говорим за матрица на теглата. Ако графът е неориентиран, то тогава A[i][j] = A[j][i], т.е. матрицата е симетрична относно главния си диагнал. Ето как би изглеждала матрицата на съседство за неориентирания граф, даден като пример отгоре:

0 1 1 0 1 0 0 0 0
1 0 0 0 0 1 0 0 0
1 0 0 1 0 0 1 0 0
0 0 1 0 0 1 1 0 0
1 0 0 0 0 1 0 1 0
0 1 0 1 1 0 0 0 1
0 0 1 1 0 0 0 0 1
0 0 0 0 1 0 0 0 1
0 0 0 0 0 1 1 1 0

 списък на съседство
При това представяне за всеки връх от графа пазим списък на съседите му. Ето как би изглеждало то за горния граф:

1 -> {2, 3, 5}
2 -> {6, 1}
3 -> {1, 4, 7}
4 -> {3, 6, 7}
5 -> {1, 6, 8}
6 -> {2, 4, 5, 9}
7 -> {3, 4, 9}
8 -> {5, 9}
9 -> {6, 7, 8}

Най-често за компютърна реализация се използва масив от свързани списъци или ако не искаме да хабим памет за двойни кутии - масив от вектори (като под вектори се има предвид например STL-ския вектор в C++)

 "най-добро представяне"
Важно е да се разбере, че както няма най-добър алгоритъм за сортиране или най-добър алгоритъм за компресиране, то няма и най-добър начин за представяне на граф. Всичко зависи от конкретното задание. Например при списъка на съседство сложността за намиране на всички съседи е линейна по броя на съседите, а при матрицата на съседство винаги е Θ(n). При списък на съседство паметта, която ще ни трябва за представянето почти винаги е по-малка от тази при матрицата на съсество и категорично се препоръчва при по-разредени графи. Ако трябва обаче да проверим дали съществува ребро между два върха, то ако използваме матрица на съседство ще можем да отговорим на този въпрос с константна сложност, докато при списък на съседство ще направим това линейно по броя на съседите на съответния връх.

  Стандартни алгоритми върху графи 
 Depth First Search (Обхождане в дълбочина)
Обхождането в дълбочина (за по-кратко DFS) е вид обхождане, което се стреми да се "спусне" колкото се може "по-надълбоко" в графа. Нека опишем алгоритъма рекурсивно: тръгваме от даден начален връх, отбелязваме го като посетен и след това пускаме обхождането за всеки негов непосетен съсед. Т.е.:

1) Разглеждаме върха node
2) Отбелязваме го като посетен: visited[node] = true
3) За всеки негов съсед i проверяваме дали е непосетен: if(!visited[i]) и ако е така извикваме рекурсивно обхождането: DFS(i)

Подобна техника за отбелязване на посетените върхове чрез булев масив е удобна, защото действията се извършват с константна сложност. Ако не можем обаче да приложим подходящо кодиране на имената на върховете така, че те да се съберат в първите N естествени числа, винаги можем да ги поставяме в подходящ set (множество).
За даден граф в общия случай има повече от едно възможно обхождане в дълбочина. Различията идват от подредбата и изобщо от реда на обхождане на върховете съседи. Ако пуснем DFS от връх 1 на примерния граф горе, едно възможно обхождане е (1, 2, 6, 4, 3, 7, 9, 8, 5).
Да разгледаме една примерна реализация в конкретна задача. На входа получаваме първо 3 числа - брой върхове V, брой ребра E и начален връх from. Следват E на брой реда, като във всеки има две числа - x и y такива, че има неориентирано ребро между x и y. Искаме да изпишем върховете в реда на тяхното обхождане използвайки DFS.
Входът за примерния граф ще изглежда така:

9 13 1
1 2
1 3
1 5
2 6
3 4
3 7
4 6
4 7
5 6
5 8
6 9
7 9
8 9

Ето и решението на задачата на C++, което за представяне на графа ползва списък на съседите, който е реализиран с STL-ски vector:

#include <iostream>
#include <memory>
#include <vector>

using namespace std;

vector<int> *A;
int V, E, from, *parent;
bool *visited;

void DFS(int node)
{
	cout << node + 1 << endl;
	visited[node] = true;

	for(int i = 0; i < A[node].size(); i++)
		if(!visited[A[node][i]])
		{
			parent[A[node][i]] = node;
			// do some special job here
			DFS(A[node][i]);
		}
}

void input()
{
	int x, y;

	cin >> V >> E >> from;
	from--;

	A = new vector<int>[V];
	visited = new bool[V];
	memset(visited, 0, V)
	parent = new int[V];

	for(int i = 0; i < E; i++)
	{
		cin >> x >> y;
		A[x-1].push_back(y-1);
		A[y-1].push_back(x-1);
	}
}

void free_mem()
{
	delete [] visited;
	delete [] parent;
	delete [] A;
}

int main()
{
	input();
	DFS(from);
	free_mem();
	return 0;
}

На мястото на // do some special job here обикновено се извършват действията, необходими за конкретната задача. Това е моментът, в който се намираме в даден връх, точно преди да влезнем в следващ връх. За пример тук е запазван родителят на всеки възел при обхождането. DFS строи дърво, по което в даден момент можем да възстановим пътя, "извървян" дотук. Удобно е това дърво да се пази в списък на родителите и точно това прави описаната реализация.
Тъй като върховете са номерирани от 1, а в C++ номерацията започва от 0, то се налагат на няколко места прибавяния и изваждания на единица.
Оценка на сложността
За всеки един връх DFS намира наследниците му и пуска обхождане от тях. Ако използваме матрица на съседство, намираме наследниците със сложност Θ(V), а при списък на съседство това става линейно по броя на съседите на дадения връх. И имайки предвид, че правим това точно по веднъж за всеки връх (тъй като пазим visited), то окончателно получаваме сложност при използването на матрица на съседство Θ(V2), а чрез списък на съседство - Θ(V + E).

 Breadth First Search (Обхождане в ширина)
За разлика от DFS, BFS първо разглежда всички непосредствени съседи и чак след това преминава към техните наследници. Така се постига последователно обхождане "по нива". Ако пуснем BFS от връх 1 за примерния граф ще получим следното обхождане:

ниво 0 - връх 1
ниво 1 - върхове 2, 3, 5
ниво 2 - върхове 4, 6, 7, 8
ниво 3 - връх 9

Очевидно в даден път, получен при обхождане в ширина, няма как да срещнем връх от по-високо ниво преди връх от по-ниско ниво.
За реализацията на BFS е най-удобно да използваме опашка. В началото в нея има само един връх - този, от който пускаме обхождането. Докато опашката не е празна, правим следното:

1) Изваждаме върха, намиращ се в началото на опашката, и го разглеждаме
2) За всеки негов непосетен наследник:
   2.1) Отбелязваме го като посетен
   2.2) Добавяме го в опашката

Нека решим задачата  от примера за обхождане в дълбочина с BFS. Тъй като четенето на входа е същото, то ще покажем само функцията BFS:

void BFS(int node)
{
	queue<int> q;
	q.push(node);
	visited[node] = true;

	while(!q.empty())
	{
		node = q.front();
		q.pop();

		cout << node + 1 << endl;

		for(int i = 0; i < A[node].size(); i++)
			if(!visited[A[node][i]])
			{
				parent[A[node][i]] = node;
				visited[A[node][i]] = true;
				// do some special job here
				q.push(A[node][i]);
			}
	}
}

Това ще изведе на екрана пътя (1, 2, 3, 5, 6, 4, 7, 8, 9), който напълно отговаря на гореспоменатото условие за нивата. Използваната опашка отново е от STL.
Оценка на сложността
Очевидно BFS има същата сложност като DFS: Θ(V2) с матрица на съседство и Θ(V + E) със списък на съседство.

 Сравнение между DFS  и BFS
Както няма най-добро представяне на граф, така няма и най-добър алгоритъм за обхождане. Двата алгоритъма работят с еднаква сложност при съответните представяния. Все пак ако знаем, че върхът, до който се опитваме да достигнем, се намира "по-близо" до началния връх, то е по-добре да го търсим с BFS. Обратното - ако знаем, че се намира "по-далече" - то по-добре е да пуснем DFS.
BFS се използва много често в непретеглени графи, където това обхождане ни дава най-къс път. И наистина: пускайки BFS(x) при достигане на даден връх y не сме минали през връх от по-високо ниво от това на y. Т.е. броят на изминатите ребра дотук е минимален от x до y.
Все пак, когато е възможно, състезателите предпочитат да пишат DFS, тъй като неговата реализация е удивително бърза за писане:

void DFS(int node)
{
	visited[node] = true;
	for(int i = 0; i < n; i++)
		if(A[node][i] && !visited[i])
			DFS(i);
}

 Алгоритъм на Dijkstra
Алгоритъмът на Дейкстра ни дава възможност да намираме оптимални пътища в граф. Той е най-добрият начин да намерим най-къс път от един връх до всички останали (което е еквивалентно на това да намерим най-къс път от един връх до друг). Алгоритъмът се основава на прочутата Теорема на Дейкстра и отчасти можем да считаме, че едновременно принадлежи към алгоритмите от динамичното програмиране и към "лакомите" алгоритми (greedy). Като цяло алгоритъмът поддържа един масив (който ще бележим с dist[]) на най-късите пътища и го обновява на всяка стъпка. Ето и подробно описание:

1) Инициализираме масива dist[] по следния начин:
   1.1) dist[i] = a[node][i] за всеки съсед i на началния връх node
   1.2) dist[i] = MAX_VALUE за всеки несъсед на node
2) Въвеждаме множество от посетени върхове, в което в началото поставяме само node
3) Докато съществуват непосетени върхове, за които dist[i] < MAX_VALUE:
   3.1) Избираме връх j такъв, че dist[j] да е минимално
   3.2) Отбелязваме j като посетен
   3.3) За всеки непосетен връх i изпълняваме: dist[i] = min(dist[i], dist[j] + a[j][i])

(Стъпка 3.3 е известна като релаксация)
Ако след приключване на алгоритъма в dist[k] стои числото MAX_VALUE, то не съществува път между началния връх и върха k.
Нека решим някоя конкретна задача с алгоритъма на Дейкстра. Даден ни е претеглен граф G(V, E) и два върха from и to. Да се намери дължината на най-късия път от from до to, както и самият път. В конкретния пример ще търсим минимален път в графа от примера по-горе, като ще въведем следните тегла на ребрата:

Тогава входният файл ще изглежда така:

9 13 1 9
1 2 8
1 3 2
1 5 4
2 6 26
3 4 9
3 7 1
4 6 3
4 7 6
5 6 18
5 8 7
6 9 10
7 9 20
8 9 35

(като четвъртото число на първия ред е върхът to)
Ще реализираме алгоритъма като представим графа с матрица на теглата, а посетените върхове ще отбелязваме в масива visited[].

#include <iostream>

#define MAX_NODES 128
#define MAX_VALUE 2000000000

using namespace std;

int V, E, a[MAX_NODES][MAX_NODES], parent[MAX_NODES], dist[MAX_NODES], from, to, x, y, z;
bool visited[MAX_NODES];

void Dijkstra(int node)
{
	int min_dist, i;
	for(i = 1; i <= V; i++)
	{
		dist[i] = MAX_VALUE;
		visited[i] = 0;
	}
	dist[node] = 0;

	for(;;)
	{
		min_dist = MAX_VALUE;
		for(i = 1; i <= V; i++)
			if(dist[i] < min_dist && !visited[i])
			{
				node = i;
				min_dist = dist[i];
			}
		if(min_dist == MAX_VALUE)
			return;
		visited[node] = true;

		for(i = 1; i <= V; i++)
			if(a[node][i] && (dist[i] > dist[node] + a[node][i]))
			{
				dist[i] = dist[node] + a[node][i];
				parent[i] = node;
			}
	}

}

void printWay(int node)
{
	if(parent[node] != from)
		printWay(parent[node]);
	cout << parent[node] << " ";
}

int main()
{
	cin >> V >> E;
	cin >> from >> to;
	for(int i = 1; i <= E; i++)
	{
		cin >> x >> y >> z;
		a[x][y] = a[y][x] = z;
	}

	Dijkstra(from);

	if(dist[to] == MAX_VALUE)
		cout << "No way exists from node " << from << " to node " << to << "!\n";
	else
	{
		cout << dist[to] << endl;
		printWay(to);
		cout << to << endl;
	}

	return 0;
}

Получаваме отговор:

22
1 3 7 4 6 9

Забележка 1: За да бъде приложен алгоритъмът, ребрата на графа трябва да са положителни числа.
Забележка 2: Алгоритъмът не може да бъде използван за намиране на най-дълъг път.
Интересно е обаче значението на "най-къс" и "най-дълъг" път. "Най-къс" по принцип значи "най-евтин по цена на ребрата". Това обаче понякога може да бъде замаскирано. Нека разгледаме следната задача: цените на ребрата ще представляват пропускливост и ще търсим максимален по пропускливост път. Зададена по този начин, задачата може да ни обърка, защото думата максимален би ни навела на мисълта, че търсим най-дълъг път. Пътят, който търсим тук, обаче е такъв, в който "най-евтиното" ребро е максимално, и тази задача може да се реши с алгоритъма на Дейкстра, като направим малки корекции в инициализацията и релаксацията:

void Dijkstra(int node)
{
	int min_dist, i;
	for(i = 1; i <= V; i++)
	{
		dist[i] = 0;
		visited[i] = 0;
	}
	dist[node] = MAX_VALUE;

	for(;;)
	{
		min_dist = -1;
		for(i = 1; i <= V; i++)
		if(dist[i] > min_dist && !visited[i])
		{
			node = i;
			min_dist = dist[i];
		}
		if(min_dist == -1)
			return;
		visited[node] = 1;

		for(i = 1; i <= V; i++)
			if(a[node][i] && (dist[i] < min(dist[node], a[node][i])))
				dist[i] = min(dist[node], a[node][i]);
	}

}

Оценка на сложността
Написан с матрица на съседство, алгоритъмът на Дейкстра работи със сложност Θ(V2 + V2) за намирането на най-близкия връх и за релаксацията. Ако се напише със списък на съседство, общо релаксацията ще има сложност Θ(E) и така получаваме крайна сложност Θ(V2 + E). Възможно е обаче да намираме най-близкия връх използвайки пирамида. И тогава, ако представим графа със списък на съседите, получаваме обща сложност Θ((V + E)*log(V)). Ако пирамидата е Фибоначиева, това ще доведе сложността до Θ(V*log(V) + E), но в средния случай (amortized time).
Използването на пирамида в алгоритъма на Дейкстра се налага рядко по състезания, но не е изключено. Понякога след разширяване се получават огромни силно разредени графи, където използването на пирамида е задължително.





Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%A1%D0%9F-2007-%D0%93%D1%80%D0%B0%D1%84%D0%B8“.
			Категории: Състезателно-Програмиране-2007 | Структури от данни | Алгоритми | Графи			
						
		