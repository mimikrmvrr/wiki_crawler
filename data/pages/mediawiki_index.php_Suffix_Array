Suffix Array
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Suffix array е масив от суфиксите на един низ, подредени в лексикографски ред.

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }  Детайли
Да разгледаме низа "abracadabra" с дължина 11. Той има 11 суфикса: "abracadabra", "bracadabra", "racadabra", ..., "a". Подредени в лексикографски ред, суфиксите изглеждат така:

a
abra
abracadabra
acadabra
adabra
bra
bracadabra
cadabra
dabra
ra
racadabra

Всеки суфикс е напълно определен от индекса (в първоначалния низ) на първата си буква. Суфиксният масив е масив от индексите на суфиксите подредени в лексикографски ред. В конкретния пример, суфиксният масив е {10,7,0,3,5,8,1,4,6,9,2}, където индекс 0 съответства на първия символ от дадения низ.

 Приложения
Нека haystack е дадения низ, на който сме построили суфиксен масив. Нека needle е някакъв низ.
Суфиксният масив може да бъде използван като индекс за бързо намиране на всички срещания на needle в haystack. Намирането на всяко срещане на needle е еквивалентно на намирането на всеки суфикс, който започва с needle. Поради лексикографската подредба, тези суфикси ще са последователни и могат да бъдат намерени бързо с двоично търсене. При стандартна имплементация сложността на операцията "търсене на needle в haystack" е O(m*logn), където m е дължината на needle, а n - на haystack. За да избегнем повтарящите се сравнения, можем да използваме масив (от n елемента), който дава информация за дължината на най-дългите общи префикси (longest common preffixes) на последователни суфикси. При тази оптимизация, сложността на горната операция е O(m+logn).

  Конструиране 
Спомени че може да се направи от Suffix Tree и как.

  Сложност <math>O(n^2 \log n)</math> 
Най-лесният начин за конструиране на суфиксен масив е като се използва алгоритъм за сортиране. Трябва да се сортират n суфикса, което изисква <math>O(n \log n)</math> сравнения на суфикси, всяко от които от своя страна изисква <math>O(n)</math> елементарни сравнения. Общо, алгоритъмът има сложност <math>O(n^2 \log n)</math>.

  Сложност <math>O(n \log n)</math> 
Това е което в средния случай е линейно, но в най лошия е <math>O(n \log n)</math>. Ако разбереш следващото, може да не го описваш подробно.

  Сложност <math>O(n)</math> 
   Heka стрингът Т = t0t1...tn е дефиниран върху азбуката ∑ = {0..n}. Нека последният елемент на Т ни е буква, която не се среща никъде другаде в Т, и е лексикографски най - малката буква в ∑. Означаваме тази буква с '$'. Дефинираме Тi=titi+1...tn, като суфикс на Т, започващ с ti. Класифицираме всички суфикси на Т в два типа: суфиксът Тi е от тип S, ако Ti < Ti+1 и е от тип L, ако Тi+1 < Тi.(Означението Ti < Ti+1 ще използваме, за да покажем, че Ti е лексикографски по-малък от Ti+1) Последният суфикс Tn класифицираме като тип S и L едновременно, тъй като той няма с какво да бъде сравнен.
Лема 1: Всички суфикси на Т могат да бъдат класифицирани, като тип L или S за O(n) време.
Доказателство: Разглеждаме суфиксът Тi (i < n) :Случай 1: Ako ti ≠ ti+1  - сравняваме ti и ti+1 за да определим типа на Тi.Случай 2: Ako ti = ti+1  - намираме най-малкото j > i, такова че tj ≠ ti.
                 Ако tj > ti, тогава Ti, Ti+1, ... , Tj-1 са от типS.
                 Ако tj < ti, тогава Ti, Ti+1, ... , Tj-1 са от тип L.
Така всички суфикси могат да бъдат класифицирани, като тип S или L, като сканираме Т отляво на дясно за линейно време O(n).
Лема 2: Суфикс от тип S е лексикографски по-голям от суфикс от суфикс от тип L, започващи с една и съща буква.
Доказателство:Нека Ti е суфикс от тип S, a Тj е суфикс от тип L, като и двата суфикса да започват с буква c. Допускаме, че Ti < Tj.Тогава можем да запишем Ti=cαc1β и Tj = cαc2γ, където c1 ≠ c2 и α, β и γ са (възможно е и празни) стрингове.Случай 1: α съдържа буква различна от c. Нека c3 е най - лявата буква в a, която е различна от c. Тъй като Ti е суфикс от тип S,c3 > c. Аналогично за Tj c3 < c. Това води до противоречие, следователно допускането, че Ti < Tj е грешно.Случай 2: α не са съдържа буква, различна от c. Тъй като Ti е от тип S ⇒ c1 ≥ c, Tj е от тип L ⇒ c2 ≤ c ⇒ c2 ≤ c1, но Ti < Tj ⇒ c1 < c2, което води до противоречие с допускането, че Ti < Tj.
Извод 1: В суфиксен масив на Т, всички суфикси от тип S, се появяват след суфиксите от тип L.
   Heka А е масив, който съдържа индексите на всички суфикси на Т, не задължително в сортиран ред. Създаваме масив R, такъв че R[i] = k, ako A[k] = i(R пази позициите, където суфикса Ti се намира в A). Когато променяме съдържанието на масива A, трява да се грижим за обновяване на съдържанието на масива R. Нека B ни е масив от всички суфикси от тип S подредени лексикографски. Използвайки B можем да сортираме лексикографски всички суфикси на Т по следния начин:
   1. Групираме всички суфикси на Т по първата им буква в масива А, т.е всяка група съдържа всички суфикси, които започват с една и съща буква. Тази стъпка отнема линейно време O(n).
   2. Сканираме B от дясно на ляво. За всеки суфикс, посетен при сканирането, преместваме суфикса на текущия край на неговата група в A и изместваме текущия край с едно в ляво.Преместване на суфикс на дадена позиция означава да сменим местата на суфикса със суфикса заемащ дадената позиция. След като приключим сканирането на B, от Извод 1 следва, че всички суфикси от тип S са на правилните си позиции. Тази стъпка отнема O(|B|)=O(n) време.
   3. Сканираме A от ляво на дясно. За всяко A[i], ако ТА[i]-1 е суфикс от тип L, преместваме А[i] във текущото начало на групата му в А и увеличаваме текущото начало с 1. Тази стъпка отнема О(n) време и в края и А съдържа всички суфикси на Т, подредени лексикогафски. Лема 3 
доказва верността на тази стъпка.
Лема 3: В стъпка 3, когато сканирането достигне А[i], суфикса TA[i] е на правилната си позиция при лексикографско сортиране.
Доказателство:
Ще докажем лемата с индукция по i. Започваме с най - малкия суфикс в Т. Той е от тип S и неговата правилна позиция е А[0]. Нека A[1]A[2]...A[i] са първите i сортирани суфикса. Сега трябва да покажем, че когато сканирането достигне А[i+1], тогава суфикса TA[i+1] е на правилната си позиция. Допускаме, че това твърдение е грешно. Тогава съществува суфикс , сочен от А[k] (k > i + 1), който трябва да бъде на позиция 
А[i+1], т.е. ТА[k] < TA[i+1]. Тъй като всички суфикси от тип
S са вече сортирани, TA[k] и TA[i+1] са от тип L. Тъй като А е групирана по първите букви на суфиксите и суфикс не може да излезе от групата си, TA[k] и TA[i+1] започват с една и съща буква.
Нека тази буква е c. Нека ТА[i+1] = cα и TA[k] е cβ, където α и β са стрингове. Тъй като β < α, ТА[k] трябва да бъде преместен в текъщото начало на групата си преди ТА[i+1]. Следователно ТА[k] не може да стои от дясно на ТА[i+1], което води до противоречие.
   Дефинираме позицията i да бъде от тип S, ако суфикса Ti е от тип S, иначе позицията i да бъде от тип L, ако Тi е от тип L. Подниза ti...tj наричаме низ от тип S, ако i и j са позиции от тип S и всички позиции между i и j са от тип L.
   Целта ни е да сортираме всички суфикси от тип S от Т. За целта, първо ще сортираме всички, тип S подстрингове. Сортирането, генерира групи, в които всички субстрингове са идентични. Номерираме групите от 0 в последоватено нарастващ ред. След това генерираме нов стринг Т′ по следния начин: Сканираме Т отляво на дясно и за всяка позиция от тип S пишем номера на групата. От този стринг, от номерата на групите конструираме Т′. Всеки суфикс от тип S от Т отговаря на точно един суфикс от Т′ (Лема 4).Тогава сортирането на Т ще е еквивалентно, на сортирането на Т′. Сортираме Т′ рекурсивно.
   Първо трябва да сортираме всички тип S подстрингове за линейно време. За всеки суфикс Тi, дефинираме S-distance, което е разстоянието от стартовата позиция i на суфикса, до най - близката, от ляво, позиция от тип S. Запазваме тези стойности в масив Dist, като Dist[i] = {S-distance на суфикса Ti} . Ако не съществува S позиция от ляво на i, Dist[i] = 0.Сортираме S подстринговете по следния начин:
   1. За всеки суфикс от А, изчисляваме S-Distance, като сканираме T от ляво на дясно и запазваме разстоянието от текущата позиция до най - близката от ляво Sпозиция. Докато на позиция i S-Distance за Тi е известна я записваме в Dist[i]. По този начин попълваме Dist за линейно време.
   2. Нека m е най - голямата S-Distance. Създаваме m списъка, такива че, списъкът j (1 ≤ j ≤ m), съдържа всички суфикси с S-Distance = j. Списъците са подредени по реда, по който се появяват в A. Това може да се постигне, чрез сканиране на A от ляво надясно за линейно време, като се обръщаме към Dist[A[i]], за да сложим Tiв правилният списък.
   3. Сортирането на S подстринговете става като последователно
сортираме по техните j-ти букви. Това става , като обхождаmе последователно списъците и за всеки списък j вземамаме елемента на позиция i и преместваме елемента ti-j от списъка A в текущото начало на групата му.Тъй като общия размер на списъците е O(n), то сортирането става за време O(n).
Лема 4: Нека Ti и Tj са два суфикса на T и нека T′i′ и T′j′ са съответните им суфикси в Т′. Тогава, Ti < Ti ⇔ T′i′ < T′j′
Доказателство: Първо ще докажем, че T′i′ < T′j′ ⇒ Ti < Ti.  Префиксите 
Ti и Tj, отговарящи на най-дългия общ префикс на 
T′i′ и T′j′ трябва да са 
идентични. Това е, защотото, ако две групи са с един и същи номер, тогава съответстващите 
подстрингове трябва да са едни и същи. Разглеждаме най-лявата позиция в която 
T′i′ и T′j′ се различават. 
Такава позиция съществува и буквите (номерата на групите) на 
T′i′ и T′j′ в тази позиция 
определя кое от двете, T′i′ или 
T′j′ е лексикографски по-малко. Нека k е номера на 
групата в T′i′> и l, бъде номера на групата в 
T′j′> на тази позиция. Тъй като 
T′i′> < T′j′>, то k < l. 
Нека α е подстрингът отговарящ на k и β е подстринга.Случай 1: β не е префикс на α. Във този случай, k < l 
⇒ α < β, от което следва  Ti < 
Ti.Случай 2: β е префикс на α.Нека последната буква на 
β е c. Съответстващата позиция в Т е S тип позиция. 
Позицията на отговарящия на c в α, трябва да е позиция от тип L. 
Докато двата суфиксите, които започват от тези позиции започват с една и съща буква, от 
Извод 1, суфиксът то тип L трябва да бъде лексикографски по-малък от
суфикса от тип S. Следователно Ti < Tj.
От едно към едно съответствието между суфиксите T′ и и суфиксите от тип 
S в T, следва, че Ti < Ti ⇒ 
T′i′> < T′j′Извод 2: Сортирането на суфиксите на T′ намира сортирания ред на 
суфиксите тип S от T.

  Операции 
  Реализация 
Една кратка реализация на контруиране със сложност <math>O(n)</math>. Виж препратката към статията долу.

inline bool leq(int a1, int a2,   int b1, int b2) { // lexic. order for pairs
  return(a1 < b1 || a1 == b1 && a2 <= b2); 
}                                                   // and triples
inline bool leq(int a1, int a2, int a3,   int b1, int b2, int b3) {
  return(a1 < b1 || a1 == b1 && leq(a2,a3, b2,b3)); 
}
// stably sort a[0..n-1] to b[0..n-1] with keys in 0..K from r
static void radixPass(int* a, int* b, int* r, int n, int K) 
{ // count occurrences
  int* c = new int[K + 1];                          // counter array
  for (int i = 0;  i <= K;  i++) c[i] = 0;         // reset counters
  for (int i = 0;  i < n;  i++) c[r[a[i]]]++;    // count occurences
  for (int i = 0, sum = 0;  i <= K;  i++) { // exclusive prefix sums
     int t = c[i];  c[i] = sum;  sum += t;
  }
  for (int i = 0;  i < n;  i++) b[c[r[a[i]]]++] = a[i];      // sort
  delete [] c;
}

// find the suffix array SA of s[0..n-1] in {1..K}^n
// require s[n]=s[n+1]=s[n+2]=0, n>=2
void suffixArray(int* s, int* SA, int n, int K) {
  int n0=(n+2)/3, n1=(n+1)/3, n2=n/3, n02=n0+n2; 
  int* s12  = new int[n02 + 3];  s12[n02]= s12[n02+1]= s12[n02+2]=0; 
  int* SA12 = new int[n02 + 3]; SA12[n02]=SA12[n02+1]=SA12[n02+2]=0;
  int* s0   = new int[n0];
  int* SA0  = new int[n0];
 
  // generate positions of mod 1 and mod  2 suffixes
  // the "+(n0-n1)" adds a dummy mod 1 suffix if n%3 == 1
  for (int i=0, j=0;  i < n+(n0-n1);  i++) if (i%3 != 0) s12[j++] = i;

  // lsb radix sort the mod 1 and mod 2 triples
  radixPass(s12 , SA12, s+2, n02, K);
  radixPass(SA12, s12 , s+1, n02, K);  
  radixPass(s12 , SA12, s  , n02, K);

  // find lexicographic names of triples
  int name = 0, c0 = -1, c1 = -1, c2 = -1;
  for (int i = 0;  i < n02;  i++) {
    if (s[SA12[i]] != c0 || s[SA12[i]+1] != c1 || s[SA12[i]+2] != c2) { 
      name++;  c0 = s[SA12[i]];  c1 = s[SA12[i]+1];  c2 = s[SA12[i]+2];
    }
    if (SA12[i] % 3 == 1) { s12[SA12[i]/3]      = name; } // left half
    else                  { s12[SA12[i]/3 + n0] = name; } // right half
  }

  // recurse if names are not yet unique
  if (name < n02) {
    suffixArray(s12, SA12, n02, name);
    // store unique names in s12 using the suffix array 
    for (int i = 0;  i < n02;  i++) s12[SA12[i]] = i + 1;
  } else // generate the suffix array of s12 directly
    for (int i = 0;  i < n02;  i++) SA12[s12[i] - 1] = i; 

  // stably sort the mod 0 suffixes from SA12 by their first character
  for (int i=0, j=0;  i < n02;  i++) if (SA12[i] < n0) s0[j++] = 3*SA12[i];
  radixPass(s0, SA0, s, n0, K);

  // merge sorted SA0 suffixes and sorted SA12 suffixes
  for (int p=0,  t=n0-n1,  k=0;  k < n;  k++) {
#define GetI() (SA12[t] < n0 ? SA12[t] * 3 + 1 : (SA12[t] - n0) * 3 + 2)
    int i = GetI(); // pos of current offset 12 suffix
    int j = SA0[p]; // pos of current offset 0  suffix
    if (SA12[t] < n0 ? 
        leq(s[i],       s12[SA12[t] + n0], s[j],       s12[j/3]) :
        leq(s[i],s[i+1],s12[SA12[t]-n0+1], s[j],s[j+1],s12[j/3+n0]))
    { // suffix from SA12 is smaller
      SA[k] = i;  t++;
      if (t == n02) { // done --- only SA0 suffixes left
        for (k++;  p < n0;  p++, k++) SA[k] = SA0[p];
      }
    } else { 
      SA[k] = j;  p++; 
      if (p == n0)  { // done --- only SA12 suffixes left
        for (k++;  t < n02;  t++, k++) SA[k] = GetI(); 
      }
    }  
  } 
  delete [] s12; delete [] SA12; delete [] SA0; delete [] s0; 
}

  Задачи 
 Задача 2 от брой 11/2006 на PC Magazine
  Връзки 
 O(n) алгоритъм

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Suffix_Array“.
			Категории: Структури от данни | Advanced Data Structures			
						
		