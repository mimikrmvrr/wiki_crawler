Биномна пирамида
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Дефиниция на биномно дърво 
Биномното дърво се дефинира рекурсивно:

 биномно дърво от ред 0 е дърво състоящо се само от корен.
 биномно дърво от ред k има корен със степен k и неговите деца са корени на биномни дървета от ред k-1, k-2, ... , 0 (в тази последователност).
  Биномни дървета от ред 0 до 3: Всяко дърво има корен, чиито наследници са всички биномни дървета от по-нисък ред, които са оградени. Например, биномното дърво от ред 3 е свързано към биномните дървета от ред 2, 1 и 0 (оградени със синьо, зелено и червено съответно).
Биномно дърво от ред k съдържа 2k nodes, и има височина k.
Поради уникалната си структура, биномно дърво то ред k може да бъде конструирано от две биномни дървета от ред k-1 тривиално, чрез добавянето на едно от двете биномни дървета към другото, като негов най-ляв наследник. Това свойство е есенцията на операцията сливане на две биномни пирамиди, което е главното предимство на биномната пирамида пред другите традиционни пирамиди.

  Дефиниция на биномна пирамида 
Биномна пирамида се имплементира като множество от биномни дървета, които удовлетворяват свойствата на биномната пирамида:

 Всяко биномно дърво в пирамидата е подчинено на свойството минимална-пирамида: ключът на елемент е по-голям или равен на ключа на родителят му.
 Може да има само едно или нула биномни дървета от всеки ред, включително и от ред нула.
  Биномна пирамида, в която има биномни дървета от ред 0, 2 и 4.
Първото свойство осигурява в корена на всяко биномно дърво от пирамидата да се намира неговият най-малък ключ (елемент), което важи за цялата пирамида.
Второто свойство осигурява, че биномна пирамида с n елемента се състои от най-много lg n + 1 биномни дървета. Всъщност броя и редовете на тези дървета са еднозначно зададени от броя елементи n: всяко биномно дърво отговаря на еденица в двуичният запис на числото n. Например числото 13 в двуичен запис е 1101, което се представя като <math>2^3 + 2^2 + 2^0</math>, заради което биномна пирамида с 13 елемента ще се състои от три биномни дървета от ред 3, 2 и 0.

  Свойства на биномната пирамида 
Всяка от следващите операции работи за O(log n) време върху биномна пирамида с n елемента:

 Вкарване на нов елемент в пирамидата
 Намиране на елемента с минимален ключ
 Изтриване на елемента с минимален ключ от пирамидата
 Намаляне на ключа на даден елемент
 Изтриване на даден елемент от пирамидата
 Сливане на две дадени пирамиди в една
Намирането на елемента с минимален ключ може също да бъде направено за O(1) време, чрез използването на допълнителен указател към минимума.

  Операции върху биномна пирамида 
  Намиране на най-малкият елемент в пирамидата 
Поради първото свойство на биномната пирамира, че всяко биномно дърво в нея се подчинява на минимална биномна-пирамида намирането на най-малкият елемент е лесна задача, защото всичко което трябва да направим е да обходим корените на биномните дървета и да видим кой от корените е най-малък.
В зависимост от структурата, в която си пазим пирамидата можем да правим оптимизации за по-бързото намиране на този минимум. Например ако пазим биномните дървета в подреден масив, където подредбата е по ключовете на корените им, можем да реализираме двоично търсене.
За примерен код може да видите частта от функцията extract_min, която е показана в Изтриване на минималният елемент от пирамидата, в която се намира минималният елемент и се взема индексът му.

  Сливане на две пирамиди 
Поради специфичната структура на биномното дърво, сливането на две дървета от един и същ ред е тривиална задача. Просто към дървото чиито ключ на корена е по-малък добавяме другото дърво и така новото дърво е с ред, който е увеличен с 1. Ето и примерен код за сливането на две биномни дървета:


Binomial_Tree MergeTrees(Binomial_Tree a, Binomial_Tree b)
{
	if (a.order != b.order)
	{
		throw "Trees must be of the same order!";
		return Binomial_Tree(Node(0, 0));
	}
	if (a.key < b.key)
	{
		a.children.push_back(b);
		a.order += 1;
		return a;
	}
	else
	{
		b.children.push_back(a);
		b.order += 1;
		return b;
	}
}

Обърнете внимание, че в примерният код, закачането на дървото става като най-десен наследник, което е различно от дефиницията на биномно дърво която е дадена по-горе, но същински важното нещо е подредбата на наследниците по редове, по дефиниция тя е намаляваща, а в примерният код тя е направена да бъде нарастваща!
Операцията за сливане на две биномни дървета е есенцията за сливане на две биномни пирамиди, понеже тази операция е бърза за дървета, тя е бърза и за пирамиди.
Ето и какво на практика трябва да направим:

 Добавяме всички дървета от втората пирамида към първата (резултатът от сливането ще ни се намира в първата).
 В този момент за така получената пирамида не можем да гарантира, че удовлетворява условията необходими да бъде биномна пирамида. Единственото условие което може да бъде нарушено е условието, че трябва да има най-много по едно биномно дърво от всеки ред. Заради това докато има две биномни дървета от един и същ ред:
 Сливаме двете дървета от един и същ ред.
 Новото дърво което се е получило при сливането го добавяме към пирамидата.
 Двете дървета, от които се е получило новото дърво ги изтриваме от пирамидата.
Ето и примерен код:


void BinomialHeap::MergeHeaps(BinomialHeap h)
{
	for (unsigned i = 0; i < h.heap.size(); i++)
	{
		this->heap.push_back(h.heap[i]);
	}
	bool loop = true;
	while (loop)
	{
		loop = false;
		Times_Seen orderscntr[33];
		for (unsigned i = 0; i < this->heap.size(); i++)
		{
			if (this->heap[i].order > 32)
			{
				// bad error - the heap is too big!
				throw "The heap is too big! Try reducing the elements!";
				return;
			}
			orderscntr[this->heap[i].order].times++;
			orderscntr[this->heap[i].order].trees_idexes.push_back(i);
			if (orderscntr[this->heap[i].order].times > 1) loop = true;
		}
		vector<int> indexes_to_delete;
		for (int i = 0; i < 33; i++)
		{
			if (orderscntr[i].times > 1)
				for (int j = 0; j < orderscntr[i].times; j+=2)
					if (j+1 < orderscntr[i].times)
					{
						Binomial_Tree newTree = MergeTrees(this->heap[orderscntr[i].trees_idexes[j]],
										   this->heap[orderscntr[i].trees_idexes[j+1]]);
						this->heap.push_back(newTree);
						indexes_to_delete.push_back(orderscntr[i].trees_idexes[j]);
						indexes_to_delete.push_back(orderscntr[i].trees_idexes[j+1]);
					}
		}
		sort(indexes_to_delete.begin(), indexes_to_delete.end(), greater<int>());
		for (unsigned i = 0; i < indexes_to_delete.size(); i++)
		{
			int offset = indexes_to_delete[i];
			this->heap.erase(this->heap.begin() + offset);
		}
	}
}

Тази имплементация на сливане на две пирамиди има един основен недостатък, че не допуска в пирамидата да има дървета, които са от ред по-голям от 32, така се получава ограничение в броят елементи, които могат да бъдат съхранени в пирамидата. Този проблем може да бъде избегнат с използването например на hash който да върши работата на масива orderscntr. Този масив е използван, за да може чрез едно линейно минаване да се намерят индексите на всички дървета от един и съш ред и след това отново с едно линейно минаване да се слеят всички двойки дървета от един и същ ред. Това е известна оптимизация в сравнение с възможността да се сливат само първите две дървета от един и същ ред които намерим и след това отново да пускаме проверката дали има две дървета от един и същ ред. Разбира се сливането на тези дървета води до неща, с които трябва да се внимава и типично такова нещо е изтриването на дърветата, които сме сляли от пирамидата. В конкретният случай сме запазили индексите на тези дървета, но е важно те да бъдат изтрити от най-големият индекс към най-малкият, защото изтриването предизвиква изместване на индексите на всички елементи след изтритият индекс. Точно с тази цел преди да започнем изтриването, масивът с индексите се сортира в намаляващ ред.

  Изтриване на най-малкият елемент 
Необходимо е да направим следните неща:

 първо намираме минималният елемент.
 след това конструираме нова пирамида, която се състои от биномните дървета, които са деца на минималният елемент. За така конструираната пирамида сме сигурни, че удовлетворява двете свойства от дефиницията, защото децата на корена, на биномно дарво от ред k са биномни дървета от редове k-1 до ред 0 и в така конструираната пирамида няма да има биномни дървета от един и същ ред. Също и условието минимална биномна-пирамида ще бъде удоволетворено, защото минималният ключ на биномните дървета от по-нисък ред се съдържа в корена им.
 след това изтриваме биномното дърво, чиито корен е минималният елемент.
 и накрая сливаме двете пирамиди.
Ето и примерен код:


Node BinomialHeap::extract_min()
{
	Node min;
	int min_index = 0;
	if (!this->empty()) min = this->heap[0].key;
	else
	{
		throw "The heap is empty! Cannot extract!";
		return Node(0,0);
	}
	for (unsigned i = 1; i < this->heap.size(); i++)
		if (this->heap[i].key < min)
		{
			min = this->heap[i].key;
			min_index = i;
		}
	BinomialHeap heap_from_children;
	for (unsigned i = 0; i < this->heap[min_index].children.size(); i++)
		heap_from_children.heap.push_back(this->heap[min_index].children[i]);
	this->heap.erase(this->heap.begin() + min_index);
	this->MergeHeaps(heap_from_children);
	return min;
}

  Вмъкване на елемент 
Вмъкването на елемент също в голяма степен е тривиална операция след като вече имаме сливане на пирамиди

 Правим пирамида от ред 0, която съдържа желаният елемент.
 Сливаме така направената пирамида с пирамидата, към която искаме да добавим елемента.
Ето и примерен код:


void BinomialHeap::insert(const Node &newNode)
{
	this->MergeHeaps(BinomialHeap(Binomial_Tree(newNode)));
}

  Намаляне на даден елемент 
Ако искаме да намалим ключа на даден елемент който е в пирамидата (без ограничение на общността можем да разгледаме само биномното дърво, в което се намира този ключ):

 Намираме елемента, който съдържа желаният ключ.
 Сменяме стойността на ключа с новата стойност (задължително проверяваме новата стойност да бъде по-малка!).
 Докато ключа на текущият елемент е по-малък от ключа на родителя му, разменяме ключовете им и текущ става родителя.
  Изтриване на даден елемент 
За да изтрием даден елемент от пирамидата:

 Сменяме стойността на ключа му с -.
 Съставяме биномна пирамида от децата на елемента с ключ - (в  Изтриване на най-малкият елемент беше обяснено защо това е чиста операция).
 Изтриваме биномното дърво с ключ - в корена.
 Сливаме двете пирамиди.
  Сравнение на сложностите между двоична и биномна пирамиди 
  Двоична пирамида  Биномна пирамида
 Процедура  (наи-лош случай)  (наи-лош случай)
 Създаване на пирамидата  <math>\Theta(1)</math>  <math>\Theta(1)</math>
 Вмъкване на нов елемент  <math>\Theta</math>(lg n)  O(lg n)
 Намиране на минималният елемент  <math>\Theta(1)</math>  O(lg n)
 Извличане на минималният елемент  <math>\Theta</math>(lg n)  <math>\Theta</math>(lg n)
 Обединение на две пирамиди  <math>\Theta</math>(n)  O(lg n)
 Намаляне на ключ  <math>\Theta</math>(lg n)  <math>\Theta</math>(lg n)
 Изтриване на елемент  <math>\Theta</math>(lg n)  <math>\Theta</math>(lg n)

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%91%D0%B8%D0%BD%D0%BE%D0%BC%D0%BD%D0%B0_%D0%BF%D0%B8%D1%80%D0%B0%D0%BC%D0%B8%D0%B4%D0%B0“.
			Категории: Структури от данни | Advanced Data Structures			
						
		