Patricia trie
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Patricia trie/tree, Radix tree или crit bit tree е специализирана структура от данни, базираща се на trie. Използва се за съхранение на символни низове, битови низове - например числа или IP адреси.

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Същност 
Patricia trie представлява оптимизиран от гледна точка на памет trie.

  Недостатъци на trie 
 При реализацията на trie има 2 подхода, при които постигаме или бързо намиране на даден наследник, или разумно използване на паметта.
 В случай, че за всеки връх пазим указатели към k наследника, някои от които са празни, имаме достъп до наследниците с константна сложност, но за сметка на това се използва прекалено много излишна памет, когато trie-дървото е разредено. 
 Ако изберем представяне, при което наследниците са в списък, или някаква друга структура за търсене, пестим значително количество памет, но достъпа до наследник вече не е с константна сложност.
 Когато за нас е по-важна ефективността пред използваната памет, проблема със структурата от данни trie се появява в случая, когато множеството от използваните ключове в много от елементите е малко, в сравнение със това на всички възможни ключове. Т.е. ако имаме азбука с размер 26, повечето от елементите на trie имат по много малко деца (например 1-2) в сравнение с пълния брой деца, които могат да бъдат индексирани (в случая 26). Много често на практика се получава елементите на trie да имат само по 1 дете. При азбука с размер 2 това не е голям проблем, но в общия случай структурата заема много памет.
  Компресиране 
Съществуват подобрения на trie, които компресират структурата, така че тя отново да предоставя бързо търсене, но и да заема по-малко памет.

 Едно компресиране е всяка верига от по един елемент, която води до листо да бъде преобразувана до един елемент. До него се достига с ключа, с който се достига първия елемент на веригата. В този елемент, който е листо, се помни думата, до която стигаме чрез обхождане на веригата и достигане до листото, в което тя свършва. Това е т.нар. структура от данни Compact trie/tree. Тя е ефективна при дълги низове, когато често имаме думи, които от определен символ нататък нямат разклонения. Ефективността е по-голяма, когато този символ е по-близо до началото на думата. Например в alphabet, aluminium, alchemy ще имаме по един елемент с ключ 'а' и 'l' съответно, и 3 елемента с ключове 'p', 'u' и 'c', които водят до съответните думи.
 Patriciа trie надгражда Compact trie и trie по следния начин. Всеки елемент, който не е дума и има само едно дете бива слят със него. Тогава по ребрата вече можем да имаме както символ от азбуката, така и цял символен низ. Така освен плюсовете, които имаме от Compact trie, пестим памет и при думи с общ префикс.
Файл:Trie improvements.jpg
  Някои особености и факти за Patricia trie 
 Има няколко начина по-които можем да отбелязваме дали думата, образувана от думите по ребрата, чрез които достигаме елемент, е дума в структурата. Два от тях са:
 Елемента има дете, по-което стигаме, използвайки фиктивен символ (например '$'). 
 Помним в самия елемент дали той е дума или не (например с някаква булева променлива).
 При азбука от 2 символа, броят на вътрешните елементи е равен на броя на думите минус 1.
 Височината на дървото на Patricia trie е максимум n, където n е броят на думите, които са в структурата.
  Операции 
Над структурата от данни Patricia trie са дефинирани следните операции.

  Търсене 
Търсенето е идентично с това на trie.

 Ако при последователна проверка на символите на оставащата част от търсената дума със символите на думата в текущото ребро, стигнем до несъответствие, или символите на думата свършат преди достигане края на думата на реброто, значи думата не е в структурата. 
 При достигане на край на думата в дадено ребро, продължаваме да търсим надолу по неговото дете, започващо със следващата буква от търсената дума. Ако такова дете няма, значи думата не съществува. 
 Ако при достигане края на думата в дадено ребро сме изчерпили и буквите от търсената дума, значи може да регистрираме съществуване, ако елемента е отбелязан като дума. Това може да проверим в зависимост от това кой от начините за отбелязване на дума сме избрали.
  Добавяне 
За да добавим дума започваме да търсим дали тя не е вече в структурата. 

 Ако я намерим значи не добавяме нищо, т.к. тя вече е там. 
 В противен случай разглеждаме последния елемент, до който сме стигнали в търсенето. 
 Ако не сме изчерпили символите от думата, която търсим и сме стигнали края на думата в реброто, чрез което стигаме в елемента, трябва да добавим ново дете към този елемент, с остатъка от думата.
 Ако не сме изчерпили символите и не сме стигнали края на думата в реброто, чрез което стигаме в елемента, тогава разцепваме реброто на 2 - цепим го там, докъдето символите от думата са съвпаднали с неговите. Към новообразувания елемент (отначало с 1 дете) добавяме 2-ро дете с останалата част от думата.
 Ако сме изчерпили символите и сме стигнали до края на думата в реброто, с което стигаме до елемента, трябва просто да отбележим елемента като дума.
 Ако сме изчерпили символите и не сме достигнали до края на думата в реброто, тогава отново разцепваме реброто на 2 по същия начин. Новообразувания елемент (отначало с 1 дете) отбелязваме като дума (по някой от възможните начини описани по-горе).
  Изтриване 
За да изтрием дума, почваме да търсим дали тя съществува в структурата.

 Ако я няма, не трием нищо.
 Ако думата е в структурата, тогава разглеждаме един от следните случаи.
 Ако думата няма деца, просто я изтриваме, както и реброто с което стигаме до нея. В този случай проверяваме дали нейния родител не е останал само с 1 дете. Ако това е така и той не е отбелязан като дума, трябва да слеем родителя с детето, за да поддържаме дървото компресирано.
 Ако думата има точно 1 дете, тогава я сливаме с него.
 Ако думата има повече от 1 деца, тогава просто отбелязваме, че тя не е дума. В зависимост от реализациата - премахваме детето, до което стигаме с фиктивния символ ('$'), или променяме стойността с която помним дали елемента е дума.
  Сложности 
И трите операции в структурата се изпълняват за време О(к), където к е дължината на търсената дума.

  Сравнение с други структури от данни 
В следващите сравнения, ще имаме предвид, че дължината на ключовете е к, а структурата съдържа n елемента.

 Балансираните дървета предоставят търсене, вмъкване и изтриване за О(log n), докато Patricia trie - О(к). Обикновено к ≥ log n, но това не е недостатък, а дори е и предимство в случая. Това е така, защото при балансираните дървета всяко от сравненията е сравнение на символни низове, което изисква О(к), много от които са бавни заради дългите общи префикси. В trie, всички сравнения изискват константно време, но отнема О(m) сравнения, при търсене на дума със дължина m. А Patricie trie изисква по-малко елементи, т.е. по-добро е откъм памет спрямо trie.
 Patricia trie обаче наследява недостатъците на trie. Тези структури могат да се използват само при елементи, които могат да се представят като символни низове, докато балансираните дървета могат да се използват за елементи от всякакъв тип, за който имаме пълна наредба (например числата със плаваща запетая).
 Хеш-таблици имат очаквана сложност О(1) при добавяне и изтриване, но при определени ситуации сложността може да стане и О(n). Докато Patriciа tries имат гарантирана сложност О(к) в най-лошия случай при добавяне и изтриване.
  Реализация 
Имплементация на Patricia trie - Patricia trie implementation

  Приложения 
Повечето от приложенията на trie важат и за Patricia trie, например:

 Заместници на други структури от данни - вместо двоично наредено дърво или Хеш-таблици.
 Съхраняване на речници.
 При софтуер за spell-checking.
 При конструиране на асоциативни масиви с ключове, които могат да се представят като символни низове.
 Сортиране - всички думи се добавят в структурата, после се обхождат по азбучен ред.
 При някои алгоритми - например търсене с използване на wildcard символи - '*' и '?'.
  История 
Donald R. Morrison пръв описва, това което е нарекъл "Patricia trie" през 1968. Името PATRICIA е акроним и идва от "Practical Algorithm to Retrieve Information Coded in Alphanumeric". Независимо от него Gernot Gwehenberger открива и описва същата структура от данни по относително същото време.

  Връзки 
 http://www.nist.gov/dads/HTML/compactTrie.html
 http://www.nist.gov/dads/HTML/patriciatree.html
 http://www.cs.mcgill.ca/~cs251/OldCourses/1997/topic7/
 http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA/
 http://en.wikipedia.org/wiki/Patricia_tree

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Patricia_trie“.
			Категории: Структури от данни | Advanced Data Structures			
						
		