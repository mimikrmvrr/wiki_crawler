Пранка-2006-AVL
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			I. AVL дървета
AVL дърветата, кръстени на своите създатели Аделсън Велски и Ландис, са първите предложени динамично балансирани дървета. Също като червено черните дървета, те не са идеално балансирани, но двойките поддървета на всеки връх се разлчават по височина най-много с 1. Ако в обикновено балансирано дърво включим последователно сортирани данни, то по-скоро се изражда в линеен списък с J(n) височина и следователно J(n)  сложност при търсене и включване на елемент. AVL дърветата решават този проблем. При тях търсенето на елемент има сложност  J(log n) в най-лошия случай. Това е постигнато чрез налагане на ограничения върху разликата във височините между поддърветата на даден връх и ребалансиране на дървото ако тези ограничения са нарушени. Вмъкването и изтриването на елемент имат същата сложност както търсенето. 
Дефиниция 1: AVL дърво е двоично дърво за претърсване със следните свойства:
1)	поддърветата на всеки връх се различават по височина най-много с 1
2)	всяко поддърво е AVL дърво
Пример 1:

Тук всяко ляво поддърво има височина по-голяма с 1 от височината на дясното поддърво и следователно това е AVL дърво

Това не е AVL дърво тъй като поддървото с корен 8 има височина 4, а поддървото с корен 18 има височина 2

Пример 2: 
Най-лоши случаи на AVL дървета

Нека с Аn означим броя на върховете на AVL дървото с височина n (дължината на най-дългия път от корена до листо) в най-лошия случай.
Имаме: An = An-1 + An-2 + 1
При числата на фибоначи имаме:  Fn = Fn-1 + Fn-2 , F-1 = 0, F0 = 1
	An	Fn
0	1	1
1	2	1
2	4	2
3	7	3
4	12	5
5	20	8
6	33	13
Следователно An = Fn+2 – 1
Fn >([1+Ц5)/2)n/Ц5 –1
Нека f = [1+Ц5]/2
Тогава An > fn+2/Ц5 – 2
Нека сега разгледаме произволно AVL дърво с М върха и височина h. За него ще получим:
M і Ah > fh+2/Ц5 – 2
Следователно М + 2 > fh+2/Ц5
Логаритмуваме и получаваме:
logf(M + 2) > logf(fh+2/Ц5) = h + 2 – logf(Ц5)
Следователно h < 1,4404lg(M + 2) – 0,3277
От тук се получава и следната теорема:
Теорема (Аделсън Велски и Ландис): Нека е дадено двоично дърво Т с n вътрешни върха. Нека h е височината на Т. Тогава: 
	lg(n + 1) < h < 1,4404lg(h + 2) – 0,3277
Със всяко AVL дъво се свързва балансиращ фактор, представляващ височината на дясното му поддърво минус височината на лявото му поддърво. Следователно можем да дадем следната еквивалентна дефиниция на AVL дърво:
Дефиниция 2: AVL дърво е двоично дърво за претърсване в което всеки връх има балансиращ фактор –1, 0  или 1.
Пример 3:
(балансиращите фактори са изписани над всеки връх)

                                   +1
                                   30

                               /        \

                            -1            0
                            22            62

                          /             /     \

                        0             +1       -1
                        5             44       95

                                        \     /
                                         0   0
                                         51  77

Следващото двоично дърво не е AVL дърво:

                                   -1
                                   100

                               /         \

                            -2             -1
                            70             150
                                     
                         /    \          /     \

                      +1       0       +1        0
                      30      80      130       180

                    /    \               \     
                   0      -1              0   
                  10      40              140
                         /
                        0
                       36 


II. Включване на елемент в AVL дърво
Първоначално върховете се включват по същия начин както при обикновените  двоични дървета, т.е. винаги се включват като листа. След това първоначално включване обаче алгоритъма за включване на нов елемент се връща отново по пътя по който е минал за да намери мястото на включване и проверява балансиращия фактор на всеки връх от пътя. Ако някой връх се окаже небалансиран, т.е. балансиращият му фактор е +2 или –2, се изпълнява ротация върху включените върхове, свързани с небалансирания връх.
Забележка: Винаги най-много една ротация ще бъде необходима след включване на елемент. 
Ротации:
Както отбелязахме по-рано, всяко AVL дърво трябва да отговаря на определени изисквания относно балансиращия фактор за да поддържа J(log n ) време за търсене. Тези ограничения на балансиращия фактор се поддържат с помощта на няколко ротационни функции:
Дясна ротация
Лява ротация
Двойна ляво-дясна ротация (състои се от лява ротация, последвана от дясна)
Двойна дясно-лява ротация (състои се от дясна ротация, последвана от лява)

Включване на нов елемент:
Случай 1:
Балансиращ фактор на връх се променя от 0 на +1 или –1 когато връх е включен под него. В този случай не е необходима промяна при този връх. 
Пример:

                                    0
                                   40

                               /        \

                            +1            0
                            20            50

                              \         /     \

                               0       0        0
                               30     45       70

След като включим 60 получаваме: 

                                   +1
                                   40

                               /        \

                            +1            +1
                            20            50

                              \         /     \

                               0       0       -1
                               30     45       70
                                              /
                                             0
                                             60

Случай 2:
Балансиращият фактор на връх се променя  от –1 на 0 когато нов връх е включен в дясното му поддърво (случаят когато балансиращич фактор се променя от +1 на 0 при включване в лявото поддърво е аналогичен). Отново не е необходима промяна.
Пример:

                                   -1
                                   40

                               /        \

                            +1            0
                            20            50

                          /   \         /     \

                         0     0       0        0
                        10     30     45       70
                              /  \
                             0    0
                            22    32

След като включим 60 получаваме: 

                            0 <-- -1 става 0 (случай 2)
                           40

                       /        \

                    +1            +1 <-- случай 1
                    20            50

                  /   \         /     \

                 0     0       0       -1 <-- случай 1
                10     30     45       70
                      /  \            /
                     0    0          0
                    22    32         60

Случай3:
Балансиращият фактор на връх се променя от –1 на –2 когато нов връх е включен в лявото му поддърво (случаят в който балансиращият фактор се променя от +1 на +2 при включване в дясното поддърво е аналогичен). В този случай е необходима промяна в този връх и AVL дървото е възстановено с помощта на ротация
Подслучай A:
Означения:
P – бащата на поддървото което се разглежда
LC – левия син на P
RC – десния син на Р
X – включвания елемент
При включването на Х балансиращият фактор на P става –2 а на LC става –1  и –2 трябва да бъде поправен. Това се постига с помощта на дясна ротация при Р.

                             (остатъка от дървото)
                                    |
                                   -2
                                    P

                               /        \

                            -1           под
                            LC          дърво   
                                          с
                          /   \         височина
                                           n
                       под     под
                      дърво   дърво      
                        с       с
                    височина  височина
                         n       n
                        /
                       X

Прилагаме дясна ротация при връх Р и получаваме: 

                             (остатъка от дървото)
                                    |
                                    0
                                   LC

                               /        \

                            под           P
                           дърво         
                             с          /    \ 
                          височина       
                             n       под     под  
                            /       дърво   дърво
                           X          с       с
                                   височина височина
                                       n       n

Нека разгледаме и по-детайлен пример на подслучай A. 

                                   -1 
                                   80

                               /        \

                            -1            -1
                            30            100

                          /   \         /

                         0     0       0
                        15     40     90 
                       /  \       
                      0    0      
                     10    20     

Включваме 5 и проверяваме балансиращите фактори от листото нагоре до корена

                                   -2
                                   80

                               /        \

                            -2            -1
                            30            100

                          /   \         /

                        -1     0       0
                        15     40     90 
                       /  \       
                     -1    0      
                     10    20     
                    /
                   0
                   5

При връх 30 се е получил балансиращ фактор –2 който трябва да бъде поправен. Това се постига с дясна ротация след която получаваме:

				     -1 

                                   80

                               /        \

                             0            -1
                            15            100

                          /   \         /

                        -1     0       0
                        10     30     90 
                       /      /  \
                      0      0    0
                      5     20    40

В огледалния случай се ползва лява ротация при Р:

                             (остатъка от дървото)
                                    |
                                   +2
                                    P

                               /        \

                             под         +1
                            дърво        RC
                              с
                           височина    /    \
                              n
                                     под     под
                                    дърво   дърво     
                                      с       с
                                  височина  височина
                                      n        n
                                                \
                                                 X

Подлслучай Б:
Означения:
P – бащата на поддървото което се разглежда
LC – левия син на P
RC – десния син на Р
X – включвания елемент
NP – върхът който ще стане новия баща
X може да бъде добавен към кое да е от поддърветата с височина  n-1. Добавянето на Х променя балансиращия фактор на Р на –2, а на LC на +1. Балансиращия фактор на Р трябва да бъде поправен. Това става с помощта на двойна ротация.

                          (остатъка от дървото)
                                    |
                                   -2
                                    P

                               /        \

                            +1           под
                            LC          дърво   
                                          с
                          /    \       височина
                                          n
                      под       -1
                     дърво      NP
                       с       /  \
                   височина  под  под
                       n   дърво  дърво
                             n-1   n-1
                             /
                            X

За да се поправи балансиращия фактор на Р трябва да се използва двойна ляво-дясна ротация (лява ротация при десния син RC, последвана от дясна ротация при Р).

                          (остатъка от дървото)
                                    |
                                   -2
                                    P

                               /        \

                            -2           под
                            NP          дърво   
                                          с
                          /    \       височина
                                          n
                       0        под
                      LC       дърво
                    /    \      n-1
                  под    sub
                 дърво  дърво
                   с      n-1   
               височина   /
                  n      X

Окончателно, след дясна ротация при Р получаваме: 
		           (остатъка от дървото)

                                    |
                                    0
                                   NP

                               /        \

                             0            +1 
                            LC             P
                                        
                          /    \         /    \
                                        
                       под     под      под   под
                     дърво     дърво  дърво   дърво
                       с        n-1     n-1     с
                    височина    /            височина
                       n       X                n

Нека разгледаме конкретен пример на подлсучай Б: 

                                   -1
                                   80

                               /        \

                             0             0
                            30            100

                          /   \         /     \

                        -1     0       0       0
                        20     50     90      120
                       /      /  \
                      0      0    0 
                     10     40    60

След добавяне на 55, балансиращия фактор на корена става –2:

                                   -2
                                   80

                               /        \

                            +1             0
                            30            100

                          /   \         /     \

                        -1     +1      0       0
                        20     50     90      120
                       /      /  \
                      0      0    -1
                     10     40    60
                                 /
                                0
                                55

Както обсъдихме по-рано това води до двойна ротация която да възстанови дървото. Първо изпълняваме лява ротация при 30:

                                   -2
                                   80

                               /        \

                            -1             0
                            50            100

                          /   \         /     \

                       -1      -1      0       0
                       30      60     90      120
                      /  \    /
                     -1   0  0 
                     20  40  55 
                    /          
                   0           
                  10           

Накрая, дясна ротация при 80 възстановява отново дървото:

                                    0
                                   50

                               /        \

                            -1             0
                            30            80 

                          /   \         /     \

                        -1     0      -1       0
                        20     40     60      100
                       /             /       /   \
                      0             0       0     0
                     10             55      90   120

III. Изтриване  на елемент от AVL дърво
Първоначално върховете се изключват по същия начин както при обикновените  двоични дървета. След първоначалното изключване алгоритъма за изтриване на елемент проверявабалансиращите фактори на върховете от изтрития връх до корена. Ако някой връх се окаже небалансиран, т.е. балансиращият му фактор е +2 или –2 се изпълнява ротация. Тъй като тази ротация може да доведе до промяна в балансиращия фактор на по-горен връх (балансиращият фактор на по-горен връх може да стане +2 или -2 след ротацията), проверката продължава докато се стигне корена на дървото.
Случай 1:
Преди изтриване на елемент под връх, балансиращият му фактор е бил 0. Изтриване на елемент от лявото или дясното поддърво ще доведе до балансращ фактор съответно +1 или – 1.  Следователно ограниченията са спазени и тъй като това изтриване няма ефект върху по горните върхове единственото което трябва да се направи е да се смени балансиращия фактор.
При изтриване на елемент от лявото поддърво имаме:
При изтриване на елемент от дясното поддърво имаме:

Случай 2:
Балансиращият фактор преди изтриване е -1. Изтрива се елемент от лявото поддърво при което височината му намалява с 1.  В този случай балансиращият фактор става 0 и балансиращият фактор на по-горните върхове също може да се е променил, т.е. проверката продължава. (случаят с балансиращ фактор +1 и изтриване на елемент от дясната страна е същия)
Случай 3:
Балансиращият фактор преди изтриване е +1 и дясното поддърво има поддървета с равна височина, т.е. балансиращият фактор на корена му е 0. Изтрива се елемент от лявото поддърво.

При изтриване на елемент от лявото поддърво височината му намалява и балансиращият фактор на А става +2. За да се балансира отново дървото е необходима лява ротация. Няма да има ефект върху по-горните върхове.
(случаят при който балансирашия фактор преди изтриване е -1, корена на лявото поддърво е с балансиращ фактор 0 и изтриваме елемент от дясното поддърво е аналогичен, като за балансиране на дървото ползваме дясна ротация)

Случай 4:
Може да  има ефект върху по-горните върхове, следователно продължаваме проверката нагоре.
Случай 5:

Може да  има ефект върху по-горните върхове, следователно продължаваме проверката нагоре.
Характеристика на AVL дърветата:
n	C(n)	E[ h(n) ]	R(n)
5	2.2	3.0	0.213
10	2.907	4.0	0.318
50	4.930	6.947	0.427
100	5.889	7.999	0.444
500	8.192	10.923	0.461
1000	9.202	11.998	0.463
5000	11.555	14.936	0.465
10000	12.568	15.996	0.465
n = брой върхове
С(n) = среден брой сравнения за намиране на елемент
Е[h(n)] = очаквана височина на дървото
R(n) = среден брой ротации при вмъкване/изтриване на елемент
IV. Имплементация
Преди да започнем имплементацията на AVL дърветата, нека да предположим че имаме шаблон "Comparable", дефиниран така:

  // cmp_t е изброим тип, показаващ резултата от сравнението.
  enum  cmp_t {
     MIN_CMP = -1,   // по-малко
     EQ_CMP  = 0,    // равно
     MAX_CMP = 1     // по-голямо
  };

  // Клас "Comparable" съответства на произволен сравним елемент с         
  // ключово поле което има релация на наредба. Параметъра KeyType е 
  // типа на това поле	
  //
  template <class KeyType>
  class Comparable {
  private:
     KeyType  myKey;
  
  public:
     Comparable(KeyType  key) : myKey(key) {};
        // Сравни този елемент с дадения ключ и върни резултата
     cmp_t Compare(KeyType  key) const;
  
       // Върни key-field полето на даден елемент
     KeyType Key() const { return  myKey; }
  };

Също като класа “Comparable" нашето AVL дърво също ще бъде шаблонен клас с параметър KeyType: 

  // Класът AvlNode представя връх на AVL дърво. Параметъра KeyType е типа на ключовото поле
  //
  template <class KeyType>
  class AvlNode {
  private:
     Comparable<KeyType> * myData;         // Поле за данни
     AvlNode<KeyType>    * mySubtree[2];   // Указатели към поддървета
     short                 myBal;          // Балансираш фактор

     // ... изпускаме детайлите
  };

Изчисляване на новите баланси след ротация
Да предположим, че имаме следния случай: 

            A                                     B
           / \                                   / \
          /   \                                 /   \
         a     B           ==>                 A     c
              / \                             / \
             /   \                           /   \
            b     c                         a     b

От ляво имаме вида на дървото преди ротация, а от дясно – след ротация. С главни букви сме отбелязали върхове на дървото, а с малки – поддървета.
Изчисляваме новите балансиращи фактори на А и В(ht е функция, връщаща височината):

 NewBal(A) = ht(b) - ht(a)

 OldBal(A) = ht(B) - ht(a)
           = ( 1 + max (ht(b), ht(c)) ) - ht(a)

Изваждаме второто уравнение от първото: 

  NewBal(A) - OldBal(A) = ht(b) - ( 1 + max (ht(b), ht(c)) )
                          + ht(a) - ht(a)

Добавяме OldBal(A) от двете страни: 

  NewBal(A) = OldBal(A) - 1 - (max (ht(b), ht(c)) - ht(b) )

Забелязвайки, че max(x, y) - z = max(x-z, y-z), получаваме: 

  NewBal(A) = OldBal(A) - 1 - (max (ht(b) - ht(b), ht(c) - ht(b)) )

Но ht(c) - ht(b) е OldBal(B) следователно получаваме: 

  NewBal(A) = OldBal(A) - 1 - (max (0, OldBal(B)) )
            = OldBal(A) - 1 -  max (0, OldBal(B))

И така за А получихме равенството: 

  NewBal(A) = OldBal(A) - 1 - max (0, OldBal(B))

Прилагайки същите разсъждения за В получаваме: 

  NewBal(B) = ht(c) - ht(A)
            = ht(c) - (1 + max(ht(a), ht(b)) )

  OldBal(B) = ht(c) - ht(b)
  NewBal(B) - OldBal(B) = ht(c) - ht(c)
                          + ht(b) - (1 + max(ht(a), ht(b)) )
  NewBal(B) = OldBal(B) - 1 - (max(ht(a), ht(b)) - ht(b))
            = OldBal(B) - 1 - (max(ht(a) - ht(b), ht(b) - ht(b))

( ht(a) - ht(b) е - (ht(b) - ht(a)) = -NewBal(A))

  NewBal(B) = OldBal(B) - 1 - max( -NewBal(A), 0)

Забелязвайки, че min(x,y) = -max(-x, -y) получаваме: 

  NewBal(B) = OldBal(B) - 1 + min( NewBal(A), 0)

Следователно, за лява ротация показахме, че новите балансиращи фактори на А и В се получават от следните равенства:

  NewBal(A) = OldBal(A) - 1 - max(OldBal(B), 0)
  NewBal(B) = OldBal(B) - 1 + min(NewBal(A), 0)

Нека сега разгледаме случая с дясна ротация:

            A                                     B
           / \                                   / \
          /   \                                 /   \
         B     a           ==>                 c     A
        / \                                         / \
       /   \                                       /   \
      c     b                                     b     a

Ако приложим същите разсъждения, които направихме за лява ротация, окончателно ще получим:

  NewBal(A) = OldBal(A) + 1 - min(OldBal(B), 0)
  NewBal(B) = OldBal(B) + 1 + max(NewBal(A), 0)

Ето и имплементацията на лява и дясна ротация:

  enum  dir_t { LEFT = 0, RIGHT = 1 };

     // връща по малкото от две числа
  int MIN(int a, int b) { return  (a < b) ? a : b; }
  
     // връша по-голямото от две числа
  int MAX(int a, int b) { return  (a > b) ? a : b; }

     // Забележете че RotateLeft и RotateRight са статични функции 
     // защото иначе ще трябва да се пренасочват към "this" указателя

  template <class KeyType>
  void
  AvlNode<KeyType>::RotateLeft(AvlNode<KeyType> * & root) {
    AvlNode<KeyType> * oldRoot = root;

          // изпълнява ротацията
    root = root->mySubtree[RIGHT];
    oldRoot->mySubtree[RIGHT] = root->mySubtree[LEFT];
    root->mySubtree[LEFT] = oldRoot;

          // изчислява новите баланси
    oldRoot->myBal -=  (1 + MAX(root->myBal, 0));
    root->myBal    -=  (1 - MIN(oldRoot->myBal, 0));
  }


  template <class KeyType>
  void
  AvlNode<KeyType>::RotateRight(AvlNode<KeyType> * & root) {
    AvlNode<KeyType> * oldRoot = root;

          // изпълнява ротацията
    root = root->mySubtree[LEFT];
    oldRoot->mySubtree[LEFT] = root->mySubtree[RIGHT];
    root->mySubtree[RIGHT] = oldRoot;

          // изчислява новите баланси
    oldRoot->myBal +=  (1 - MIN(root->myBal, 0));
    root->myBal    +=  (1 + MAX(oldRoot->myBal, 0));
  }

Може да направим този код още по-компактен, като използваме само един метод за изпълняване на ротация. Той ще има един допълнителен параметър: посоката, на която трябва да се извърши ротацията. Можем да подадем за посока константа LEFT или RIGHT на метода и той може да пресмята посоката, противоположна на дадената като извади от 1 дадената посока (няма значение дали LEFT е 0 или RIGHT е 0 важното е  едното от тях да е 0 а другото 1):

 1 - LEFT  = RIGHT

и 

 1 - RIGHT = LEFT

Използвайки това и същите дефиниции преди това кода за ротация става:

  dir_t Opposite(dir_t dir) { return dir_t(1 - int(dir)); }

  // RotateOnce – статична член функция, изпълняваща ротация на дадена 
  //посока
  //
  template <class KeyType>
  void
  AvlNode<KeyType>::RotateOnce(AvlNode<KeyType> * & root, dir_t  dir) {
    AvlNode<KeyType> * oldRoot  = root;
    dir_t              otherDir = Opposite(dir);

          // изпълнява ротацията
    root = tree->mySubtree[otherDir];
    oldRoot->mySubtree[otherDir] = tree->mySubtree[dir];
    root->mySubtree[dir] = oldRoot;

          // изчислява новите баланси
    if (dir == LEFT)  {
       oldRoot->myBal -=  (1 + MAX(root->myBal, 0));
       root->myBal    -=  (1 - MIN(oldRoot->myBal, 0));
    } else  /* dir == RIGHT */  {
       oldRoot->myBal +=  (1 - MIN(root->myBal, 0) );
       root->myBal    +=  (1 + MAX(oldRoot->myBal, 0));
    } //else
  }

Можем да направим кода дори още по-компактен като си поиграем с равенствата за изчисляване на новите баланси. Ще използваме факта, че max(x,y) = -min(-x,-y): 
За лява ротация
oldRoot->myBal -=  (1 + MAX(tree->myBal, 0));tree->myBal    -=  (1 - MIN(oldRoot->myBal, 0));
За дясна ротация
oldRoot->myBal +=  (1 - MIN(tree->myBal, 0));tree->myBal    +=  (1 + MAX(oldRoot->myBal, 0));
Използвайки горното правило за да променим всички срещания на "MIN" с "MAX" равенствата добиват следния вид: 
За лява ротация
oldRoot->myBal -=  (1 + MAX( +(tree->myBal), 0));tree->myBal    -=  (1 + MAX( -(oldRoot->myBal), 0));
За дясна ротация
oldRoot->myBal +=  (1 + MAX( -(tree->myBal), 0));tree->myBal    +=  (1 + MAX( +(oldRoot->myBal), 0));
Забележете, че разликата при изчисляване на новите баланси за лява и дясна ротация е единствено в + и – преди знака за равенство и знака на аргумента на MAX функцията. Ще дефинираме функция, която свързва LEFT с +1 и  RIGHT с -1 и ще умножим по резултата, който връща за да изчислим новите баланси. Такава функция е:

  f(x) = 1 - 2x

f(0)  връща 1 и f(1) връща -1. Ако умножим (1 – 2х) по (RIGHT - LEFT) резултата вече няма да зависи дали LEFT е 0 или RIGHT е 0. Това е дефиниция на нова функция "g": 

  g(x) = (1 - 2x)(RIGHT - LEFT)

Ако LEFT = 0 и RIGHT = 1 то: 

  g(LEFT)  = (1 - 2*0)(1 - 0) =  1*1    = 1
  g(RIGHT) = (1 - 2*1)(1 - 0) = (-1)*1  = -1

Ако LEFT = 1 и RIGHT = 0 то: 

  g(LEFT)  = (1 - 2*1)(0 - 1) = (-1)*(-1)  = 1
  g(RIGHT) = (1 - 2*0)(0 - 1) =  1*(-1)    = -1

И така, както искахме, функцията "g" свързва LEFT с +1 и RIGHT с -1 без значение кое е 0 и кое е 1.
И така, ако дефинираме нова променлива “factor” и й зададем стойност “g(dir)” можем да изчислим новите баланси без да използваме условна конструкция:
За ротация с посока dir
oldRoot->myBal -=  factor * (1 + MAX(factor * tree->myBal, 0));tree->myBal    +=  factor * (1 + MAX(factor * oldRoot->myBal, 0));
Използзвайки това, кода на нашия метод, изпълняващ ротация, добива следния вид: 

  // RotateOnce – изпълнява ротация на дадена посока и връща 1 ако 
  // височината на дървото се е променила след ротация, иначе връща 0
  //
  template <class KeyType>
  void
  AvlNode<KeyType>::RotateOnce(AvlNode<KeyType> * & root, dir_t  dir) {
    AvlNode<KeyType> * oldRoot  = root;
    dir_t     otherDir = Opposite(dir);
    short     factor   = (RIGHT - LEFT) * (1 - (2 * dir));

          // изпълнява ротацията
    root = tree->mySubtree[otherDir];
    oldRoot->mySubtree[otherDir] = tree->mySubtree[dir];
    root->mySubtree[dir] = oldRoot;

          // изчислява новите баланси
    oldRoot->myBal -=  factor * (1 + MAX(factor * root->myBal, 0));
    root->myBal    +=  factor * (1 + MAX(factor * oldRoot->myBal, 0));
  }

Въпреки, че новата версия на метода за ротация е по-компактен и не изисква допълнителна проверка на променливата "dir", тя може да работи по-бавно от първата защото времето, необходимо да се наорави проверка на променливата "test", може да бъде по-малко от времето, необходимо да се изпълнят допълнителните умножения и изваждания. 
Сега двойна ротация може да се имплементира като серия от ротации: 

  // RotateTwice – статична член функция, която изпълнява ротация в 
  // дадена посока при даден връх, след което изпълнява ротация в 
  // обратна посока за да възстанови баланса на AVL дървото. Връща 1 
  // ако височината на дървото се промени след ротация и 0 иначе.
  //
  template <class KeyType>
  void
  AvlNode<KeyType>::RotateTwice(AvlNode<KeyType> * & root, dir_t  dir) {
      dir_t   otherDir = Opposite(dir);
      RotateOnce(root->mySubtree[otherDir], otherDir);
      RotateOnce(root, dir);
  }

Друг метод за изчисляване на балансите след ротация.
Може да се използва и друг, различен от по-горе описания метод за изчисляване на балансиращите фактори, който може би е и по-прост. Забележете обаче, че по-горния метод работи без значение какво число е балансиращия фактор.
За лява ротация имаме една от двете възможности:

                A                                        B
               / \                                      / \
              /   \                                    /   \
             a     B              ==>                 A     c
                  / \                                / \
                 /   \                              /   \
                b     c                            a     b

Балансиращи фактори
	Преди ротация		След ротация
случай 1:	A = +2 	B = +1		A = 0 	B = 0
случай 2:	A = +2 	B = 0		A = +1 	B = -1
Следователно и в двата случая  NewB = OldB -1 и newA = -newB следователно получаваме A = - (--B) за лява ротация. 
За дясна ротация възможностите са(имаме огледален образ на лява ротация): 
Балансиращ фактор
	Преди ротация		След ротация
случай 1:	A = -2 	B = -1		A = 0 	B = 0
случай 2:	A = -2 	B = 0		A = -1 	B = +1
Следователно и в двата случая NewB = OldB +1 и newA = -newB и така получаваме, че A = - (++B) за дясна ротация. 
Следователно може да използваме следната функция за изчисляване на новите баланси:

     // константа, показваща промяна във височината
  enum height_effect_t { HEIGHT_NOCHANGE = 0, HEIGHT_CHANGE = 1 };

  template <class KeyType>
  int
  AvlNode<KeyType>::RotateOnce(AvlNode<KeyType> * & root, dir_t dir)
  {
     dir_t  otherDir = Opposite(dir);
     AvlNode<KeyType> * oldRoot = root;
  
        // проверява дали поддървото otherDir е балансирано. Ако е, то 

	 // тази ротация няма да промени височината на цялото дърво. 
	 // Иначе ротацията ще намали височината на дървото.

     int  heightChange = (root->mySubtree[otherDir]->myBal == 0)
                            ? HEIGHT_NOCHANGE
                            : HEIGHT_CHANGE;
  
        // определя нов корен
     root = oldRoot->mySubtree[otherDir];
  
        // новия корен разменя своето "dir" поддърво за неговия 

	 // родител

     oldRoot->mySubtree[otherDir] = root->mySubtree[dir];
     root->mySubtree[dir] = oldRoot;
  
        // изчислява новите балансиращи фактори
     oldRoot->myBal = -((dir == LEFT) ? --(root->myBal) : ++(root->myBal));
  
     return  heightChange;
  }

За дясно-лява ротация имаме една от трите възможности: 

                A                                        B
               / \                                      / \
              /   \                                    /   \
             a     C              ==>                 A     C
                  / \                                / \   / \
                 /   \                              /   |  |  \
                B     c                            a   b1  b2  c
               / \
              /   \
             b1   b2

Балансиращи фактори
	Преди ротация		След ротация
случай 1:	A = +2	B = +1	C = -1		A = -1	B = 0	C = 0
случай 2:	A = +2 	B = 0	C = -1		A = 0 	B = 0	C = 0
случай 3:	A = +2 	B = -1	C = -1		A = 0 	B = 0	C = +1
И в трита случая получаваме: 

    newA = -max( oldB, 0 )
    newC = -min( oldB, 0 )
    newB = 0

за двойна ляво-дясна (огледален образ на двойна дясно-лява ротация) ротация имаме следните възможности:
Балансиращи фактори
	Преди ротация		След ротация
случай 1:	A = -2	B = +1	C = +1		A = 0	B = 0	C = -1
случай 2:	A = -2 	B = 0	C = +1		A = 0 	B = 0	C = 0
случай 3:	A = -2 	B = -1	C = +1		A = +1 	B = 0	C = 0
И в трита случая имаме: 

    newA = -min( oldB, 0 )
    newC = -max( oldB, 0 )
    newB = 0

Това е точно огледалния образ на това което получихме за дясно-лява ротация: Върховете А и С просто са разменили балансиращите си фактори, т.е. и в двата случая балансиращия фактор на новото ляво поддърво и балансиращия фактор на новото дясно поддърво е същия: 

    new(left)  = -max( oldB, 0 )
    new(right) = -min( oldB, 0 )
    new(root)  = 0

И така кода за двойна ротация става следния: 

  template <class KeyType>
  int
  AvlNode<KeyType>::RotateTwice(AvlNode<KeyType> * & root, dir_t dir)
  {
     dir_t  otherDir = Opposite(dir);
     AvlNode<KeyType> * oldRoot = root;
     AvlNode<KeyType> * oldOtherDirSubtree = root->mySubtree[otherDir];
  
        // определи нов корен
     root = oldRoot->mySubtree[otherDir]->mySubtree[dir];
  
        // новия корен сменя своето "dir" поддърво за своя дядо
     oldRoot->mySubtree[otherDir] = root->mySubtree[dir];
     root->mySubtree[dir] = oldRoot;
  
        // новия корен раязменя свовто "other-dir" поддърво за своя 

	 // баща

     oldOtherDirSubtree->mySubtree[dir] = root->mySubtree[otherDir];
     root->mySubtree[otherDir] = oldOtherDirSubtree;
  
        // update balances
     root->mySubtree[LEFT]->myBal  = -MAX(root->myBal, 0);
     root->mySubtree[RIGHT]->myBal = -MIN(root->myBal, 0);
     root->myBal = 0;
  
        // двойната ротация винаги намалява височината на дървото
     return  HEIGHT_CHANGE;
  }

Сега, след като имаме методи за ротация трябва единствено да знаем кога да ги извикаме. Ще дефинираме помощен метод balance() който ще бъде викан когато връх стане прекалено тежък на  определена страна: 

  enum balance_t { LEFT_HEAVY = -1, BALANCED = 0, RIGHT_HEAVY = 1 };
  
     // връща истина, ако дървото е прекалено тежко от лявата страна
  static int
  LEFT_IMBALANCE(short bal) { return (bal < LEFT_HEAVY); }
  
     // връща истина, ако дървото е прекалено тежко от дясната страна
  static int
  RIGHT_IMBALANCE(short bal) { return (bal > RIGHT_HEAVY); }
  
  // Rebalance – статична член функция за ребалансиране на дървото. 
  // Връща 1 ако височината се промени и 0 иначе.
  template <class KeyType>
  int
  AvlNode<KeyType>::ReBalance(AvlNode<KeyType> * & root) {
     int  heightChange = HEIGHT_NOCHANGE;
  
     if (LEFT_IMBALANCE(root->myBal)) {
           // трябва дясна ротация
        if (root->mySubtree[LEFT]->myBal  ==  RIGHT_HEAVY) {
              // трябва ляво-дясна ротация
           heightChange = RotateTwice(root, RIGHT);
        } else {
              // трябва дясна ротация
           heightChange = RotateOnce(root, RIGHT);
        }
     } else if (RIGHT_IMBALANCE(root->myBal)) {
           // трябва лява ротация
        if (root->mySubtree[RIGHT]->myBal  ==  LEFT_HEAVY) {
              // трябва дясно-лява ротация
           heightChange = RotateTwice(root, LEFT);
        } else {
              // трябва лява
           heightChange = RotateOnce(root, LEFT);
        }
     }
  
     return  heightChange;
  }

Определяне кога височината на текущото поддърво се е променила
След като сме включили или изтрили елемент от текущото поддърво трябва да определим дали височината на текущото поддърво се е променила за да можем да подадем информацията нагоре по рекурсията на предишните инстанции на методите. Най простия случай е точката на включване. Тъй като сме създали връх, който не е съществувал преди това сме повишили височината на включения връх от 0 на 1. следователно трябва да предадем стойност 1 (ще използваме “1” за TRUE и  “0” за FALSE) на предишното ниво на рекурсия за да покажем увеличаването на височината на текущото поддърво.

       |            after insertion               |
      NULL         ================>              |
                                                  A

Останалите случай при включване са също лесни. Ако “height-change-indicator”, върнат при включване в поддърво на текущото ниво е 0, то тогава няма промяна във височината. Структурата на някое от поддърветата може да се промени поради включване и/или ротация, но ако височината на дървото не се промени, то няма да се промени и височината на текущото ниво 

       |            след включване                |
       |           ================>              |
       A                                          A
      / \                                        / \
     /   \                                      /   \
    b     c                                    b     d

Ако текущото ниво е балансирано след включване на връх (но преди пробване на ротации) то тогава сме направили едното поддърво равно по височина на другото. Следователно височината на текущото ниво не се променя и се връща 0. 

       |            след включване                |
       |           ================>              |
       A                                          A
      /                                          / \
     /                                          /   \
    b                                          b     c

Преди да напишем кода за включване, имаме нужда от метод за сравняване на елементи докато обхождаме дървото. Методът Compare()ще връща <0, ==0, или >0 за <,==,> съответно. 

  // Compare – сравнява ключа с дадения елемент използвайки даден 
  // критерий (min, max или равенство). Връща:
  //               EQ_CMP ако ключовете са еквивалентни
  //               MIN_CMP ако ключа е по-малък от ключа на елемента
  //               MAX_CMP ако ключа е по-голям от ключа на елемента
  //
  template <class KeyType>
  cmp_t
  AvlNode<KeyType>::Compare(KeyType key, cmp_t cmp) const
  {
     switch (cmp) {
        case EQ_CMP :  // стандартно сравнение
           return  myData->Compare(key);
  
        case MIN_CMP :  // намира най-малкия елемент на даденото дърво
           return  (mySubtree[LEFT] == NULL) ? EQ_CMP : MIN_CMP;
  
        case MAX_CMP :  // намира най-големия елемент на дървото
           return  (mySubtree[RIGHT] == NULL) ? EQ_CMP : MAX_CMP;
     }
  }

Сега вече може да напишем метода за включване на елемент в AVL дърво: 

  // Insert – включва даден ключ в дървото. Връща върха, ако той вече 
  // съществува. Иначе връща NULL за да покаже, че ключа е успешно 
  // включен. След преключване параметъра “change” ще бъде ‘1’ ако  
  // височината на дървото се е променила иначе ще бъде ‘0’.
  //
  template <class KeyType>
  Comparable<KeyType> *
  AvlNode<KeyType>::Insert(Comparable<KeyType> *   item,
                           AvlNode<KeyType>    * & root,
                           int                   & change)
  {
        // проверка дали дървото е празно
     if (root == NULL) {
           // включване на нов елемент
        root = new AvlNode<KeyType>(item);
        change =  HEIGHT_CHANGE;
        return  NULL;
     }
  
        // инициализация
     Comparable<KeyType> * found = NULL;
     int  increase = 0;
  
        // сравняваме елементите и определяме в коя посока да търсим
     cmp_t  result = root->Compare(item->Key());
     dir_t  dir = (result == MIN_CMP) ? LEFT : RIGHT;
  
     if (result != EQ_CMP) {
           // Insert into "dir" subtree 
        found = Insert(item, root->mySubtree[dir], change);
        if (found)  return  found;   // вече го има
        increase = result * change;  // определяме промяната в 

				       // балансиращия фактор

     } else  {   // ключа е вече в дървото на този връх
        increase = HEIGHT_NOCHANGE;
        return  root->myData;
     }
  
     root->myBal += increase;    // промяна на балансиращия фактор 
  
    // ---------------------------------------------------------------
    // ребалансиране ако е необходимо – височината на текущото дърво
    // се повишава само ако височината на неговото поддърво се е  
    // повишила и текущото дърво няма нужда от ротация.
    // ---------------------------------------------------------------
  
     change =  (increase && root->myBal)
                    ? (1 - ReBalance(root))
                    : HEIGHT_NOCHANGE;
     return  NULL;
  }

Изтриването на елемент е по-сложно от включването. Височината на текущото дърво може да намалее поради две причини: или е имало ротация, която е намалила височината на поддърво (следователно и текущото ниво), или намаляването на височината на поддърво е довела до балансирано текущо ниво ( поддървото е “подкъсено” до височината на другото поддърво). Това че е имало ротация обаче не означава, че височината на поддървото е намаляла. Има специален случай, при който ротацията не променя височината на текущото поддърво. 
Нека имаме следното дърво

                          C
                         / \
                        A   E
                           / \
                          D   F

При изтриване на А получаваме следното небалансирано дърво: 

                           C
                            \
                             E
                            / \
                           D   F

Този тип небалансирано дърво не може да се получи при включване на елемент, а само при изтриване. Забележете, че корена има балансиращ фактор 2, но корена на по-тежкото му поддърво има балансиращ фактор 0 (другия случай ще бъде -2 и 0). Изпълнявайки лява ротация за да възстановим баланса получаваме:

                          E
                         / \
                        C   F
                         \
                          D

Това дърво има същата височина както преди ротацията. Следователно, можем да определим дали изтриването е причинило промяна във височината на поддървото като проверим дали едно от двете се е случило: 
1.	дали новия баланс (след изтриване) е 0 и не е имало ротация. 
2.	дали е имало ротация, но не от специалния тип който споменахме по-горе 
(ротациа -2:0 или 2:0). 

  // Delete – изтрива даден ключ от дадено дърво. Връща NULL ако ключа 
  // не е открит, иначе връща указател към върха, който е бил изтрит 
  // от дървото. След приключване параметъра "change" ще бъде 1 ако 
  // височината на дървото се е промкенила в резултат на изтриването    
  // иначе ще бъде 0.
  //								
  template <class KeyType>
  Comparable<KeyType> *
  AvlNode<KeyType>::Delete(KeyType              key,
                           AvlNode<KeyType> * & root,
                           int                & change,
                           cmp_t                cmp)
  {
        //проверка дали дървото е празно
     if (root == NULL) {
           // ключа не е открит
        change = HEIGHT_NOCHANGE;
        return  NULL;
     }
  
        // инициализация
     Comparable<KeyType> * found = NULL;
     int  decrease = 0;
  
        // сравняване на елементите и определяне в коя посока да се 
        // търси
     cmp_t  result = root->Compare(key, cmp);
     dir_t  dir = (result == MIN_CMP) ? LEFT : RIGHT;
  
     if (result != EQ_CMP) {
           // изтриване от поддървото "dir"
        found = Delete(key, root->mySubtree[dir], change, cmp);
        if (! found)  return  found;   // not found - can't delete
        decrease = result * change;    // set balance factor decrement
     } else  {   // Found key at this node
        found = root->myData;  // set return value
  
        // -----------------------------------------------------------
        // в тази точка знаем че "result" е 0 и "root" сочи към върха, 
        // който трябва да изтрием. Има три случая:
        //
        //    1) върхът е листо. Изтриваме го и излизаме.
        //
        //    2) върхът е клон (има само един син). Пренасочваме 
        // "root" (указателя към този връх) към сина.
        //
        //    3) върхът има два сина. Разменяме елементите с 
        // наследника на "root" (най-малкия елемент в дясното му 
        // поддърво) и изтриваме наследника от дясното поддърво на 
        // "root".
        //       идентификатора "decrease" трябва да бъде променен ако    
        // височината на поддървото е намаляла поради изтриването на 
        // наследника на "root".
        // -----------------------------------------------------------
  
        if ((root->mySubtree[LEFT] == NULL) &&
            (root->mySubtree[RIGHT] == NULL)) {
               // We have a leaf -- remove it
           delete  root;
           root = NULL;
           change = HEIGHT_CHANGE;  // височината се променя от 1 на 0
           return  found;
        } else if ((root->mySubtree[LEFT] == NULL) ||
                   (root->mySubtree[RIGHT] == NULL)) {
              // имаме само един син – той става новия корен 
           AvlNode<KeyType> * toDelete = root;
           root = root->mySubtree[(root->mySubtree[RIGHT]) ? RIGHT : LEFT];
           change = HEIGHT_CHANGE;    // само скъсихме поддървото
              // нулираме указателите към поддърветата 
           toDelete->mySubtree[LEFT] = toDelete->mySubtree[RIGHT] = NULL;
           delete  toDelete;
           return  found;
        } else {
              // имаме двама сина – намираме наследника и заместваме 
              // текущата данна с тази на предшественика
           root->myData = Delete(key, root->mySubtree[RIGHT],
                                 decrease, MIN_CMP);
        }
     }
  
     root->myBal -= decrease;       // изчисляваме новия балансиращ 
                                    // фактор 
  
     // --------------------------------------------------------------
     // ребалансираме ако е необходимо – височината на текущото дърво  
     // се променя ако се случи едно от двете: (1) изпълнена е 
     // ротация, която променя височината на поддървото (2) височината   
     // на поддървото е намаляла и сега е равна на височината на 
     // другото поддърво (следователно сега, за разлика от преди, 
     // текущото дърво има балансиращ фактор 0).
     // --------------------------------------------------------------
     //change = (decrease) ? ((root->myBal) ? ReBalance(root)
     //                                     : HEIGHT_CHANGE)
     //                    : HEIGHT_NOCHANGE ;
     if (decrease) {
        if (root->myBal) {
           change = ReBalance(root);  // ребалансираме и проверяваме 
                                      // дали височината е променена
        } else {
           change = HEIGHT_CHANGE;    // балансирано, защото 
                                      // поддървото е намаляло 
        }
     } else {
        change = HEIGHT_NOCHANGE;
     }
  
     return  found;
  }

Сега вече разполагаме с функции за манипулация и поддръжка на AVL дървета. Основните методи са: 

RotateOnce(), RotateTwice(), ReBalance(), Insert(), Delete().

Единствения метод който все още липсва е метода Search(), който не се различава от обикновеното претърсване на двоично дърво: 

  // Search – търси ключ по даден критерий за сравнение. Връща NULL 
  // ако не го намери, иначе връща указател към адреса на елемента
  template <class KeyType>
  Comparable<KeyType> *
  AvlNode<KeyType>::Search(KeyType            key,
                           AvlNode<KeyType> * root,
                           cmp_t              cmp)
  {
     cmp_t result;
     while (root  &&  (result = root->Compare(key, cmp))) {
        root = root->mySubtree[(result < 0) ? LEFT : RIGHT];
     }
     return  (root) ? root->myData : NULL;
  }

И да не забравяме конструктора и деструктора: 

  template <class KeyType>
  AvlNode<KeyType>::AvlNode(Comparable<KeyType> * item)
     : myData(item), myBal(0)
  {
     myBal = 0 ;
     mySubtree[LEFT] = mySubtree[RIGHT] = NULL ;
  }
  
  template <class KeyType>
  AvlNode<KeyType>::~AvlNode(void) {
     if (mySubtree[LEFT])  delete  mySubtree[LEFT];
     if (mySubtree[RIGHT]) delete  mySubtree[RIGHT];
  }

V. Предимства на AVL дърветата пред хеш таблиците
·	Хеш таблиците са бързи (О(1)) за статични данни, но изискват скъпи операции за увеличаване размера на таблицата, ако той предварително не може да бъде определен.
·	 Хеш таблиците също така могат да използват излишно количество памет. 
·	Избирането на ефективна хеш функция също може да бъде скъпа и отнемаща много време операция. 
·	Има варианти на хеш таблици които правят изтриването на елемент скъпа операция.
·	За разлика от дърветата, хеш таблиците не правят наредба
·	Операциите:
1.	намиране на най-малък елемент
2.	намиране на най-голям елемент
3.	намиране на следващ елемент
4.	намиране на предишен елемент
при AVL дърветата имат сложност O(log n)





Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%9F%D1%80%D0%B0%D0%BD%D0%BA%D0%B0-2006-AVL“.
			Категории: Структури от данни | Advanced Data Structures			
						
		