Splay дървета
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Splay дървото е частен случй на двоично дърво за търсене.Специфично свойство за него е,че държи елементите,към които сме се обръщали по-скоро,по-близо до корена.Така времето за търсене на елемент,към който сме се обръщали скоро, е по-малко от времето за обръщение към "по-старите" елементи.

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Приложение 
Поради по-простите си за писане операции splay дървото е по-лесно за кодване.Въпреки това амортизираните му сложности са логартмични (както е при "по-гъзарските" дървета като RB- и AVL-дърветата) при случайно подбиране на  операциите, които извършваме върху него.Това означава, че макар и може да не е подходящо за използване например на състезания, където обикновено тестовете са максимално прецакани, в общия случай  splay дървото се държи прилично.Splay дървета се използват например за имплементация на кешове или за запомняне на скорошни промени.Например,ако искаме да напишем търсачка,която показва кои търсения сме извършвали скоро,е подходящо да използваме splay дърво.
За разлика от по-изисканите си събратя,  splay дървото не е придирчиво и не се оплаква дори когато в него пъхаме елементи с еднакви ключове.Освен това с никоя операция не променяме съседството им. Така лесно могат да се обходят всички елементи с еднакви ключове.

  Сплейване 
След всяка операция splay дървото извършва операцията сплейване-тази операция довежда елемента,към който сме се обърнали, до корена чрез рекурентно извършвани ротации.Трите ротации,които се извършват при сплейване,се наричат zig-zag,zig-zig и zig.След извършване на първите две текущия връх отива на мястото на дядо си и рекурентно продължаваме изпълнението на ротации от него.zig се извършва само ако текущия връх има баща,но не и дядо.

zig-zag се прилага ако текущият връх е десен наследник на баща си а баща му-ляв на дядото.Симетрична ротация се извършва при симетричната ситуация - ако текущият връх е ляв наследник на баща си,който е десен наследник на дядото.Тогава първо правим лява ротация около p,а след това-дясна около g.
<graphviz>
digraph G {
g->p
A[shape="triangle"]
B[shape="triangle"]
C[shape="triangle"]
D[shape="triangle"]
g->D
p->A
p->x
x->B
x->C
g2[label="g"]
x2[label="x"]
p2[label="p"]
g2->x2
x2->p2
A2[shape="triangle",label="A"]
B2[shape="triangle",label="B"]
C2[shape="triangle",label="C"]
D2[shape="triangle",label="D"]
g2->D2
p2->A2
p2->B2
x2->C2
x3[label="x"]
p3[label="p"]
g3[label="g"]
x3->p3
x3->g3
A3[shape="triangle",label="A"]
B3[shape="triangle",label="B"]
C3[shape="triangle",label="C"]
D3[shape="triangle",label="D"]
g3->C3
g3->D3
p3->A3
p3->B3
}
</graphviz>

zig-zig се прилага когато текущият връх е ляв наследник на баща си и бащата е ляв син на дядото.Симетричен е случая когато x и p са десни наследници.Тогава първо извършваме дясна ротация около дядото g и след това около p:
<graphviz>
digraph G {
g->p
p->x
A[shape="triangle"]
B[shape="triangle"]
C[shape="triangle"]
D[shape="triangle"]
g->D
x->A
x->B
p->C
p2[label="p"]
x2[label="x"]
g2[label="g"]
p2->x2
p2->g2
A2[shape="triangle",label="A"]
B2[shape="triangle",label="B"]
C2[shape="triangle",label="C"]
D2[shape="triangle",label="D"]
g2->C2
g2->D2
x2->A2
x2->B2
x3[label="x"]
A3[shape="triangle",label="A"]
B3[shape="triangle",label="B"]
C3[shape="triangle",label="C"]
D3[shape="triangle",label="D"]
x3->A3
p3[label="p"]
p3->B3
g3[label="g"]
p3->g3
x3->p3
g3->C3
g3->D3

}
</graphviz>
Тази операция е единствената,която различава splay дървото от дърво,в което на всяко ниво ротираме,така че текущия връх да се размени с баща си.

zig се прилага ако текущият връх има баща,но няма дядо. Лесно се съобразява,че при всяко сплейване ще бъде приложена максимум веднъж.Ако например текущият връх е ляв наследник на баща си,то ще извършим дясна ротация около бащата:
<graphviz>
digraph G {
p->x
A[shape="triangle"]
B[shape="triangle"]
C[shape="triangle"]
x->A
x->B
p->C
A2[shape="triangle",label="A"]
B2[shape="triangle",label="B"]
C2[shape="triangle",label="C"]
x2[label="x"]
x2->A2
p2[label="p"]
x2->p2
p2->B2
p2->C2
}
</graphviz>
Симетричен е случаят ако текущият връх е десен наследник на баща си.Тогава извършваме лява ротация около бащата.

  Вмъкване на нов елемент 
Вмъкване на нов елемент(x) се извършва по следния начин:първо опитваме да намерим x  в дървото.
Ако го намерим, го сплейваме до корена и, в зависимост от имплементацията на дървото(дали позволява повторение или не),или приключваме или слагаме нов елемент x като корен на дървото.За целта "скъсваме" съответното ребро(ако новия елемент е по-голям от корена,късаме дясното ребро,а иначе късаме лявото),излизащо от текущия корен,и правим новия x баща и на двата върха,които са били инцидентни с това ребро.Така новия x става корен на дървото.
Ако,когато добавяме x,не го намерим в дървото,то сплейваме последния връх,през който сме минали при търсенето,и отново правим новия x корен на дървото както в по-горния случай.
Например нека добавим 12 в долното дърво:
<graphviz>
digraph G {
t[shape="none",label=""]
a[label="7"]
b[label="4"]
c[label="9"]
d[label="3"]
e[label="5"]
f[label="8"]
g[label="11"]
h[label="6"]
a->b
a->c
b->d
b->e
c->f
c->g
e->t
e->h
}
</graphviz>
Първо откриваме, че 12 го няма в дървото,като 11 е последният елемент,през който минаваме при търсенето.Следователно сплейваме 11 с един zig-zig:
<graphviz>
digraph G {
t[shape="none",label=""]
a[label="7"]
b[label="4"]
c[label="9"]
d[label="3"]
e[label="5"]
f[label="8"]
g[label="11"]
h[label="6"]
c->a
c->g
a->b
a->f
b->d
b->e
e->t
e->h
t2[shape="none",label=""]
a2[label="7"]
b2[label="4"]
c2[label="9"]
d2[label="3"]
e2[label="5"]
f2[label="8"]
g2[label="11"]
h2[label="6"]
o[shape="none",label=""]
p[shape="none",label=""]
c2->a2
c2->p
g2->c2
g2->o
a2->b2
a2->f2
b2->d2
b2->e2
e2->t2
e2->h2
}
</graphviz>
Сега 12 е по-голям от 11 следователно трябва да "скъсаме" дясното ребро от корена,такова обаче няма, следователно просто правим 12 баща на 11.
<graphviz>
digraph G {
t[shape="none",label=""]
a2[label="7"]
b2[label="4"]
c2[label="9"]
d2[label="3"]
e2[label="5"]
f2[label="8"]
g2[label="11"]
h2[label="6"]
o[shape="none",label=""]
p[shape="none",label=""]
x[shape="none",label=""]
12->g2
12->x
c2->a2
c2->o
g2->c2
g2->p
a2->b2
a2->f2
b2->d2
b2->e2
e2->t
e2->h2
}
</graphviz>
Празните ребра не са необходими,но не можах да открия как да показвам иначе дали някой връх е ляв или десен наследник.

  Търсене 
След търсене просто сплейваме намерения елемент или(ако не сме намерили търсения елемент) последния елемент през който сме минали при търсенето.Например ако по-горе бяхме извършили не изтриване,а търсене на 12 щяхме да получим дървото където 12 не е добавен.

  Изтриване на елемент 
При изтрване на елемент(x) първо търсим елемента,който трябва да изтрием.Ако не го намерим просто сплейваме последния връх,през който сме минали(А) и приключваме.В противен случай запомняме А и след това сплейваме x.После премахваме x  от дървото като е възможно да получим две несвързани дървета(ако x е имал двама наследници).Сега сплейваме елемента А,който сме запомнили, докато стане корен на своето дърво и го правим корен на цялото дърво(тоест правим евентуалния корен на другото дърво наследник на А).С това приключва изтриването на елемент.

  Външни препратки 
 Готина демонстрация на AVL, Splay и Red/Black дърветата
 Английска статия за splay дърветата

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Splay_%D0%B4%D1%8A%D1%80%D0%B2%D0%B5%D1%82%D0%B0“.
			Категории: Структури от данни | Advanced Data Structures			
						
		