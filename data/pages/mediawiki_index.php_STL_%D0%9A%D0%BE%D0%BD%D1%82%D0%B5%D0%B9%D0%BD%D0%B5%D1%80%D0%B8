STL Контейнери
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   set и multiset 
Set и Multiset са сортирани свързани контейнер, които запазват обектите от тип Key. 
Разликата между двете е, че в Set елементите не може да са с еднаква стойност, докато тези в multiset могат да се повтарят. 
Алгоритмите са реализирани върху базата за червено-черните дървета.
Двете най-важни неща за тях са, че алгоритмите изискват елементите им да са сортирани, и също така когато елементите им се изведат те са винаги във възходящ ред. Вмъкването на сортирана редица е много бързо: както Set, така и Multiset гарантират, че вмъкването на редица от елементи е с линейна сложност, ако редицата е вече сортирана.
Set/Multiset има специалното свойство, че когато вмъкваш нов елемент, това не пречи на iterator-ите на другите елемент. Изтриването на елемент от set/multiset също не пречи по никакъв начин на iterator-ите на другите елементи, естествено изключение прави iterator-а на изтрития елемент.
Пример за set:


struct ltstr
{
  bool operator()(const char* s1, const char* s2) const
  {
    return strcmp(s1, s2) < 0;
  }
};

int main()
{
  const int N = 6;
  const char* a[N] = {"isomer", "ephemeral", "prosaic", 
                      "nugatory", "artichoke", "serif"};
  const char* b[N] = {"flat", "this", "artichoke",
                      "frigate", "prosaic", "isomer"};

  set<const char*, ltstr> A(a, a + N);
  set<const char*, ltstr> B(b, b + N);
  set<const char*, ltstr> C;

  cout << "Set A: ";
  copy(A.begin(), A.end(), ostream_iterator<const char*>(cout, " "));
  cout << endl;
  cout << "Set B: ";
  copy(B.begin(), B.end(), ostream_iterator<const char*>(cout, " "));   
  cout << endl;

  cout << "Union: ";
  set_union(A.begin(), A.end(), B.begin(), B.end(),
            ostream_iterator<const char*>(cout, " "),
            ltstr());   
  cout << endl;

  cout << "Intersection: ";
  set_intersection(A.begin(), A.end(), B.begin(), B.end(),
                   ostream_iterator<const char*>(cout, " "),
                   ltstr());    
  cout << endl;

  set_difference(A.begin(), A.end(), B.begin(), B.end(),
                 inserter(C, C.begin()),
                 ltstr());
  cout << "Set C (difference of A and B): ";
  copy(C.begin(), C.end(), ostream_iterator<const char*>(cout, " "));
  cout << endl;
}

Пример за Multiset:


int main()
{
  const int N = 10;
  int a[N] = {4, 1, 1, 1, 1, 1, 0, 5, 1, 0};
  int b[N] = {4, 4, 2, 4, 2, 4, 0, 1, 5, 5};

  multiset<int> A(a, a + N);
  multiset<int> B(b, b + N);
  multiset<int> C;

  cout << "Set A: ";
  copy(A.begin(), A.end(), ostream_iterator<int>(cout, " "));
  cout << endl;
  cout << "Set B: ";
  copy(B.begin(), B.end(), ostream_iterator<int>(cout, " "));   
  cout << endl;

  cout << "Union: ";
  set_union(A.begin(), A.end(), B.begin(), B.end(),
            ostream_iterator<int>(cout, " "));
  cout << endl;

  cout << "Intersection: ";
  set_intersection(A.begin(), A.end(), B.begin(), B.end(),
                   ostream_iterator<int>(cout, " "));
  cout << endl;  

  set_difference(A.begin(), A.end(), B.begin(), B.end(),
                 inserter(C, C.begin()));
  cout << "Set C (difference of A and B): ";
  copy(C.begin(), C.end(), ostream_iterator<int>(cout, " "));
  cout << endl;
}


Някой работи, които са полезни(нека А да ни е set/multiset): 
А.erase(x) – изтрива елемента х от А; 
А.erase(първи_iterator,втори_iterator) – изтрива всички елементи от първи_iterator до втори_iterator от А; 
А.lower_bound(x) – намира първия елемент, по-голям или равен от х в А; 
А.upper_bound(x) – намира първия елемент, строго по-голям от х в А; 
А.clear() – изтрива всички елементи от А; 
А.insert(x) – вмъква х в А; 
А.insert(първи_iterator, втори_iterator) – вмъква редицата от елементи от първи_iterator до втори_iterator в А; 
А.find(x) – намира iterator-a на елемента със стойност х от А(ако няма такъв елемент връща iterator – края на А); 
А.size() – намира дължината на А; 
А.begin() – връща iterator-а на 1-я елемент от А; 
А.end() – връща iterator-а на последния елемент на А; 
A.count(x) – връща колко пъти х се среща в А(само за multiset); 
A.swap(….) – разменя елементите на два set/multiset 
  map и multimap 
Map/multimap e сортиран свързан контейнер, който има 2 обекта – един от тип Кey, a другия от тип Data. Маp e двойков свързан контейнер, което значи, че тина на стойностите му е pair<const Key, Data>. Мар е свързан контейнер, в който елементите не могат да се повтарят, т.е. не може да има два или повече елемента с една и съща стойност, докато в multiset елементите могат да се повтарят.
Map/multimap има специалното свойство, че когато вмъкваш нов елемент, това не пречи на iterator-ите на другите елемент. Изтриването на елемент от map/multimap също не пречи по никакъв начин на iterator-ите на другите елементи, естествено изключение прави iterator-а на изтрития елемент.
Пример за map:


struct ltstr
{
  bool operator()(const char* s1, const char* s2) const
  {
    return strcmp(s1, s2) < 0;
  }
};

int main()
{
  map<const char*, int, ltstr> months;
  
  months["january"] = 31;
  months["february"] = 28;
  months["march"] = 31;
  months["april"] = 30;
  months["may"] = 31;
  months["june"] = 30;
  months["july"] = 31;
  months["august"] = 31;
  months["september"] = 30;
  months["october"] = 31;
  months["november"] = 30;
  months["december"] = 31;
  
  cout << "june -> " << months["june"] << endl;
  map<const char*, int, ltstr>::iterator cur  = months.find("june");
  map<const char*, int, ltstr>::iterator prev = cur;
  map<const char*, int, ltstr>::iterator next = cur;    
  ++next;
  --prev;
  cout << "Previous (in alphabetical order) is " << (*prev).first << endl;
  cout << "Next (in alphabetical order) is " << (*next).first << endl;
}

И един пример за multimap:


struct ltstr
{
  bool operator()(const char* s1, const char* s2) const
  {
    return strcmp(s1, s2) < 0;
  }
};

int main()
{
  multimap<const char*, int, ltstr> m;
  
  m.insert(pair<const char* const, int>("a", 1));
  m.insert(pair<const char* const, int>("c", 2));
  m.insert(pair<const char* const, int>("b", 3));
  m.insert(pair<const char* const, int>("b", 4));
  m.insert(pair<const char* const, int>("a", 5));
  m.insert(pair<const char* const, int>("b", 6));

  cout << "Number of elements with key a: " << m.count("a") << endl;
  cout << "Number of elements with key b: " << m.count("b") << endl;
  cout << "Number of elements with key c: " << m.count("c") << endl;

  cout << "Elements in m: " << endl;
  for (multimap<const char*, int, ltstr>::iterator it = m.begin();
       it != m.end();
       ++it)
   cout << "  [" << (*it).first << ", " << (*it).second << "]" << endl;
}

Някой работи, които са полезни(нека А да ни map<K, V>/multimap<K, V>): 
A.insert (pair<K, V>(k, v)) - вмъква двойката (k, v) в A 
А[key] - връща втория елемент на първата двойка, чиито първи елемент е key. Ако няма такава, я създава. 
А.erase(x) – изтрива елемента х от А; 
А.erase(първи_iterator,втори_iterator) – изтрива всички елементи от първи_iterator до втори_iterator от А; 
А.lower_bound(x) – намира първия елемент, по-голям или равен от х в А; 
А.upper_bound(x) – намира първия елемент, строго по-голям от х в А; 
А.clear() – изтрива всички елементи от А; 
  vector 
Един обект std::vector е подобен на масив по това, че осигурява произволен достъп до елементите поставени в поредица.
Все пак за разлика от традиционния масив един обект std::vector (по време на работа) може да променя размерите си
динамично,така че да поддържа произволен брой елементи.Един обект std::vector може бързо да вмъкне или отстрани
елементи от края на неговата последователност,но вмъкването или отстраняването в края не е толкова ефикасно.Това е
така, защото обектът std::vector трябва да премести позициите на елементите, за да настани новия елемент или да 
затвори мястото, оставено от отстраненият елемент.Достъпът до елементите на вектор се осъществява чрез итератори.
Дефиницията на шаблона за клас std::vector  се съдържа във файла "vector" (#include <vector>).
Обект std::vector се конструира по няколко начина :
std::vector<тип> име;                                 	      //създава празен вектор от типа име който може да съдържа данни от типa тип
std::vector<тип> име(размер);		      //създава вектор с начален размер размер
std::vector<тип> име(размер, стойност);        //създава вектор с начален размер размер, всеки елемент на който е инициализиран със стойност
std::vector<тип> име(друг_вектор);	      //използва конструктора за копиране - създава вектор - копие на съществуващия друг_вектор
std::vector<тип> име(първи,последен);             //създава вектор от интервал от елементи, определени от итераторите първи и  последен
Шаблонът за клас std::vector дефинира пълно множество от оператори в това число и оператора за сравняване.Една програма може да определи
дали два вектора са равни и кой е по-голям или по малък от друг.За равни вектори се смятат 2 вектора с равен брой елементи и еднакви елементи.
Функции-членове на вектори :
assign(първи, последен)	Замества елементите на вектора с елементите, определени от итераторите първи и последен.(започва от началото на дека) 
assign(брой, стойност)		Замества елементите на вектора с брой копия на стойност.(започва от началото на дека) 
at(n)				Връща стойността на елемента, намираща се на позиция "n" във вектора. 
back( )				Връща последния елемент във вектора. 
begin( )				Връща итератор, който сочи към първия елемент във вектора. 
capacity( )			Връща текущия максимален брой елементи, които могат да се съберат във вектора. 
clear( )				Изтрива всички елементи от вектора. 
empty( )			Връщя true, ако векторът е празен. 
end( )				Връща итератор, който сочи към края на вектора. (край на вектора е адреса след този на последния елемент) 
erase(начало, край)		Изтрива интервал от елементи от вектор сочени от итераторите начало и край. 
erase(n)			Изтрива елемент от вектора, сочен от итератора "n". 
front( )				Връща елемента в началото на вектора. 
insert(i, x)			На позиция определена от итератора "i" вмъква стойността на "x". 
insert(i, начало, край)		На позиция определена от итератора "i" вмъква интервала от стойности определен от итераторите начало и край 
insert(i, n, x)			На позиция определена от итератора "i" вмъква "n" копия на "x" 
max_size( )			Връща максималният размер на вектора(най големият брой елементи, които могат да се поберат). 
pop_back( )			Отстранява последния елемент на вектора. 
push_back(x)			Поставя стойността "x" в края на вектора. 
rbegin( )			Връща обратен итератор, който сочи след последния елемент във вектора. 
rend( )				Връща обратен итератор, който сочи (преди) първия елемент във вектора. 
reverse( )			Обръща реда на елементите. 
resize(n, x)			Прави размера на "n"-тия елемент "x" елемента. 
size( )				Връща броя на елементите на вектора. 
swap(vector)			Разменя съдържанието на 2 вектора. 
  list 
Един обект std::list е подобен на вектор или дек,с изключение на това че списъците не осигуряват произволен достъп.
Все пак един обект  std::list е ефикасен при поставянето на елементи във, или отстраняването на елементи от произволно
място в последователност.Освен това, подобно на вектор или дек един обект  std::list може да променя размерите си
динамично при необходимост.Достъп до елементите може да се осъществи също и чрез итератори.
Дефиницията на шаблона за клас std::list  се съдържа във файла "list" (#include <list>).Обект std::list се конструира по няколко начина :std::list<тип> име; //създава празен списък от типа име, който може да съдържа данни от типa тип
std::list<тип> име(размер);			     //създава списък с начален размер размер
std::list<тип> име(размер, стойност);             //създава списък с начален размер размер, всеки елемент на който е инициализиран със стойност
std::list<тип> име(друг_списък);	   	     //използва конструктора за копиране - създава списък - копие на съществуващия друг_списък
std::list<тип> име(първи,последен);                 //създава списък от интервал от елементи, определени от итераторите първи и  последен
Шаблонът за клас std::list дефинира пълно множество от оператори в това число и оператора за сравняване.Една програма може да определи
дали два списъкa са равни и кой е по-голям или по малък от друг.За равни списъци се смятат 2 списъка с равен брой и еднакви елементи.Функции-членове на списък :assign(първи, последен)	Замества елементите на списъка с елементите, определени от итераторите първи и последен.(започва от началото)
assign(брой, стойност)		Замества елементите на списъка с брой копия на стойност.(започва от началото)
back( )				Връща последния елемент във списъка.
begin( )				Връща итератор, който сочи към първия елемент във списъка.
clear( )				Изтрива всички елементи от списъка.
empty( )			Връщя TRUE ако списъкът е празен.
end( )				Връща итератор, който сочи към края на списъка.(край на списъка е адреса след този на последния елемент)
erase(начало, край)		Изтрива интервал от елементи от списък сочени от итераторите начало и край.
erase(n)			Изтрива елемент от списък, сочен от итератора "n".
front( )				Връща елемента в началото на списък.
insert(i, x)			На позиция определена от итератора "i" вмъква стойността на "x".
insert(i, начало, край)		На позиция определена от итератора "i" вмъква интервала от стойности определен от итераторите начало и край
insert(i, n, x)			На позиция определена от итератора "i" вмъква "n" копия на "x"
max_size( )			Връща максималният размер на списъка(най големият брой елементи, които могат да се поберат).
merge(listref)			Вмъква всички елементи от списъка listref  в текущия списък.
pop_back( )			Отстранява последния елемент на списъка.
pop_front( )			Отстранява първия елемент на списъка.
push_back(x)			Поставя стойността "x" в края на списъка.
push_front(x)			Поставя стойността "x" в началото на списъка.
rbegin( )			Връща обратен итератор, който сочи след последния елемент във списъка.
remove(val)			Отстранява всички прояви на val всписъка.
remove_if(val)			Отстранява всички прояви на елементите, за които предикатът пред връща стойност вярно.
rend( )				Връща обратен итератор, който сочи първият елемент във списъка.
reverse( )			Обръща реда на елементите в списъка.
resize(n, x)			Прави размера на "n"-тия елемент "x" елемента.
size( )				Връща броя на елементите на списъка.
sort( )				Сортира списъка въз основа на предиката по подразбиране.
sort(pred)			Сортира списъка въз основа на посочения предикат pred.
swap(vector)			Разменя съдържанието на 2 списъка.
unique( )			Отстранява всички дублиращи се елементи.
unique(pred)			Отстранява всички елементи, необходими за създаването на уникални елементи въз основа на посочения предикат.
  deque 
Един обект std::deque е подобен на вектор.Обектите дек са ефикасни при поставянето на елементи във,или отстраняването на елементи от началото и
края на последователност, докато обектите вектор са ефикасни само при добавянето на елементи в края на последователността.Подобно на вектор един
обект дек може да промени размерите си динамично при необходимост, но вмъкването или отстраняването на елементи от произволно друго място 
в последователността не е толкова ефикасно.Достъпът също се осъществява чрез итератори.
Дефиницията на шаблона за клас std::deque  се съдържа във файла "deque" (#include <deque>).
Обект std::deque се конструира по няколко начина :
std::deque<тип> име;                                 	      //създава празен дек от типа име който може да съдържа данни от типa тип
std::deque<тип> име(размер);		      //създава дек с начален размер размер
std::deque<тип> име(размер, стойност);	      //създава дек с начален размер размер, всеки елемент на който е инициализиран със стойност
std::deque<тип> име(друг_дек);		      //използва конструктора за копиране - създава дек - копие на съществуващия друг_дек
std::deque<тип> име(първи,последен);             //създава дек от интервал от елементи, определени от итераторите първи и  последен
Шаблонът за клас std::deque дефинира пълно множество от оператори в това число и оператора за сравняване.Една програма може да определи
дали два дека са равни и кой е по-голям или по малък от друг.За равни се смятат 2 дека с равен брой елементи и еднакви елементи.
Функции-членове на дек :
assign(първи, последен)	Замества елементите на дека с елементите, определени от итераторите първи и последен.(започва от началото на дека)
assign(брой, стойност)		Замества елементите на дека с брой копия на стойност.(започва от началото на дека) 
at(n)				Връща стойността на елемента, намираща се на позиция "n" във дека. 
back( )				Връща последния елемент във дека. 
begin( )				Връща итератор, който сочи към първия елемент във дека. 
clear( )				Изтрива всички елементи от дек. 
empty( )			Връщя TRUE ако декът е празен. 
end( )				Връща итератор, който сочи към края на дек.(край на вектора е адреса след този на последния елемент) 
erase(начало, край)		Изтрива интервал от елементи от дек сочени от итераторите начало и край. 
erase(n)			Изтрива елемент от дека, сочен от итератора "n". 
front( )				Връща елемента в началото на дека. 
insert(i, x)			На позиция определена от итератора "i" вмъква стойността на "x". 
insert(i, начало, край)		На позиция определена от итератора "i" вмъква интервала от стойности определен от итераторите начало и край 
insert(i, n, x)			На позиция определена от итератора "i" вмъква "n" копия на "x" 
max_size( )			Връща максималният размер на дек(най големият брой елементи, които могат да се поберат). 
pop_back( )			Отстранява последния елемент на дек. 
pop_front( )			Отстранява първия елемент на дек. 
push_back(x)			Поставя стойността "x" в края на вектора. 
push_front(x)			Поставя стойността "x" в началото на вектора. 
rbegin( )			Връща обратен итератор, който сочи след последния елемент във дек. 
rend( )				Връща обратен итератор, който сочи първият елемент във дек. 
resize(n, x)			Прави размера на "n"-тия елемент "x" елемента. 
size( )				Връща броя на елементите на дек. 
swap(other_deque)		Разменя съдържанието на 2 дека. 




Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/STL_%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B8“.
			Категории: Структури от данни | STL			
						
		