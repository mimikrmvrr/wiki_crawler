Rabin-Karp
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Rabin-Karp е алгоритъм за търсене на низове, съдаден от Michael O. Rabin и Richard M. Karp, който търси шаблон, например подстринг, в текст. За текст с дължина n и шаблон с дължина m, средното и най-доброто време на алгоритъма е O(n), но в най-лошия случай (много малко вероятен) е O(nm), поради което не се използва много за търсене на единичен стринг. Обаче той има уникалното предимство да намира който и да е от к низа или по-малко, за време O(n) в средния случай, независимо от големината  на к.
Едно от най-обикновените практически приложения на Rabin-Karp е откриване на плагиатство. Например, ако ученик по литература има да пише тема по някакво призведение, учителят може да намери различни материали за това произведение и да извлече списък от всички изречения в тях. Тогава с Rabin-Karp може да търси в темата на ученика изречения, които са почти същите, като тези от материалите. В случая броя на стринговете, които търсим е много голям, поради което използването на алгоритъм за търсене на единичен стринг е непрактично.

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Търсене на подниз в низ 
Основна задача при търсенето на низове е намиране на подниз с фиксирана дължина m, наричан шаблон, в текст с дължина n. Например да се намери "sun" в изречението "Hello sunshine in this vale of tears." Един прост (наивен) алгоритъм е този, който търси подниза на всички позиции:

1 function NaiveSearch(string s[1..n], string sub[1..m])
2     for i from 1 to n
3         for j from 1 to m
4             if s[i+j-1] ≠ sub[j]
5                 jump to next iteration of outer loop
6         return i
7     return not found

Този алгоритъм работи добре при много случаи, но дава относително дълго време за работа на някои примери, като търсене на 10,000 "а"-та последвани от "б" в стринг от 10 млн. "а"-та. Това е най-лошия случай и времето за изпълнение е Θ(mn).

  Rabin-Karp и хеш функциите
Rabin-Karp използва хеш функции за увеличаване бързината на изпълнение.
Алгоритъмът е следния:

1 function RabinKarp(string s[1..n], string sub[1..m])
2     hsub := hash(sub[1..m])
3     hs := hash(s[1..m])
4     for i from 1 to n
5         if hs = hsub
6             if s[i..i+m-1] = sub
7                 return i
8         hs := hash(s[i+1..i+m])
9     return not found

Всеки от редовете 2, 3, 6 и 8 изискват Ω(m) време. Втори и трети ред, обаче, се изпълняват само веднъж, а шестият се изпълнява, само ако двете хеш стойности съвпаднат, което може да се случи не повече от няколко пъти. Ред 5 се изпълнява n пъти, но изисква константно време. Така че единственият проблем е ред 8.
Ако преизчисляваме хеш стойнотите на подстринга s[i+1..i+m], това би изисквало Ω(m) време и понеже това се прави на всеки цикъл, алгоритъмът ще изисква Ω(mn) време. Трикът за решаване на този проблем е да се отбележи, че hs вече съдържа хеш стойностите на s[i..i+m-1]. Ако успеем да да използваме това и да изчисляваме хеш стойностите за константно време, то нашият проблем ще е решен.
Постигаме го чрез така наречения rolling hash. Rolling hash е хеш функция, специално проектирана за тази цел. Прост пример е добавянето на стойностите на всеки знак в подстринга. След това можем да използваме тази формула за изчисление на хеш стойността за константно време:

s[i+1..i+m] = s[i..i+m-1] - s[i] + s[i+m]

Тази проста функция работи, но ще доведе до изпълнение на ред 6 по-често, от колкото други по-усъвършенствани rolling hash функции. Забележете, че ако нямаме късмет или използваме много лоша хеш функция, като например константна функция, ред 6 може да се изпълни 
n пъти за всяка итерация на цикъла. Тогава целия алгоритъм ще отнеме Ω(mn) време - най-лошия случай.

  Използвани хеш функции 
Ключът към производителността на алгоритъма на Rabin-Karp е ефективното изчисляване на хеш стойностите на последователните поднизове на текста. Една от популярните и ефективни rolling хеш функции третира всеки подниз като число с определена основа, като основата е обикновено голямо просто число. Например, ако поднизът е "hi" и основата е 101, хеш стойността би била 104 × 1011 + 105 × 1010 = 10609 (ASCII кодът на 'h' е 104, а на 'i' е 105).
Главното предимство, постигнато чрез такова представяне, е, че е възможно да се изчисли хеш стойността на следващия подниз от предхождащия като се извършват само константен брой операции, независимо от дължините на поднизовете.
Например, ако имаме текста "abracadabra" и търсим шаблон с дължина 3, можем да изчислим хеша на "bra" от хеша на "abr" (предхождащият подниз) като извадим числото, добавено за първото 'а' на "abr", т.е. 97 × 1012 (97 е ASCII кода на 'a' и 101 е използваната основа), умножим по основата и добавим число за последното 'а' на "bra", т.е. 97 × 1010 = 97. Ако въпросните поднизове са дълги, този алгоритъм постига голяма икономия в сравнение с много други схеми на хеширане.
Теоретически съществуват други алгоритми, които могат да осигурят удобно преизчисляване, т.е. умножение на ASCII стойностите на всички символи една с друга, така че преместването на подниз би изисквало само разделяне на ASCII кода на първия символ и умножаване с този на последния. Ограничението обаче е размерът на целочисления тип данни и необходимостта да бъде използвана модулна аритметика, за да се намалят чрез мащабиране хеш резултатите. В същото време, наивните хеш функции, които не биха дали големи числа бързо, като например просто събиране на ASCII стойности, е вероятно да причинят много повече хеш колизии и така да забавят алгоритъма. Поради тази причина описаната хеш функция е обикновено предпочитаната в алгоритъма Rabin-Karp.

  Търсене на няколко шаблона 
Може да напишем прост вариянт на Rabin-Karp алгоритъма, който използва Bloom filter или Set структура от данни, за да проверява дали хеша на даден стринг принадлежи на множеството от хешове на шаблоните, които търсим:

function RabinKarpSet(string s[1..n], set of string subs, m) {
    set hsubs := emptySet
    for each sub in subs
        insert hash(sub[1..m]) into hsubs
    hs := hash(s[1..m])
    for i from 1 to n
        if hs ∈ hsubs
            if s[i..i+m-1] = a substring with hash hs
                return i
        hs := hash(s[i+1..i+m])
    return not found
}

Тук сме приели, че всички поднизове са с фиксирана дължина m, но това приемане може да се премахне. Просто сравняваме текущата хеш стойност с хеш стойностите на всички подстрингове едновременно, използвайки бързо търсене в Set структурата данни, и след това проверяваме всяко открито попадение с всички подстрингове, които имат тази хеш стойност.
Други алгоритми могат да търсят единични стрингове за време O(n) и следователно, за да намерят к шаблона им е необходимо O(nk) време. За разлика от тях, алгоритъмът на Rabin-Karp по-горе може да намери всичките к шаблона за O(n+k) очаквано време, защото хеш таблицата проверява дали хеш стойността на подстринг е равна на хеш стойността на някой от шаблоните за време O(1).

  Връзки 
 Хеш Функции
 Wikipedia - Rabin-Karp

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Rabin-Karp“.
			Категории: Алгоритми | Низове			
						
		