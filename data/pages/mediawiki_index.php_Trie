Trie
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			  trie за ключове "to", "tea", "ten", "i", "in", и "inn"
 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Ресурси 
Trie, или prefix tree, е наредено дърво, което се използва за съхраняване на асоциативни списъци, където ключовете са символни низове. За разлика от наредeно двоично дърво, върховете не съхраняват ключът асоцииран с дадения връх, вместо това неговата позиция в дървото показва с какъв ключ е асоцииран.Всеки наследник на даден връх има общ префикс с низа асоцииран с този връх, а коренът е асоцииран с празния низ. Стойностите не са асоциирани с всеки връх,а само с листа и някои вътрешни върхове.
В показания пример ключовете са наредени по върховете, а стойностите под тях. Всяка дума има число асоциирано с нея.Trie може да се разглежда като детерминиран краен автомат, въпреки че символът на всяко ребро е свързан с някаква наредба.
Не е задължително ключовете да се съхраняват във върховете. (На фигурата просто е илюстрирано как работи trie.)

  Преимущества и недостатъци пред наредено двоично дърво 
Главни прeимущества на trie пред наредено двоично дърво (НДД):

 Търсенето на ключ е по-бързо.Търсенето на ключ с дължина m отнема в най-лошия случай O(m). При НДД отнема O(log n) време, където n е броя на елементите в дървото, защото търсенето зависи от дълбочината на дървото, която е логаритмична относно броя елементи. Също така и операциите, които се използват в trie по време на търсене, като индексиране на списък по символ, са бързи на реални машини.
 Tries използват по-малко памет, когато съхраняват голям брой къси символни низове, защото ключовете не се пазят експлицитно, а върховете са поделени по ключовете.
 Tries са по-удобни при използването на най-дълъг общ префикс, когато бихме желали да открием ключа с най-дълъг префикс. Също така позволяват да свържем стойностите на цяла група ключове с общ префикс.
 Няма нужда trie да се поддържа балансиран, което при (НДД) изисква голям брой сложни операции  * self-balancing binary search tree
Недостатъци:

 Trie може да поддържа само лексикографска наредба на ключовете.
 Trie може да заема много памет при определени обстоятелства, когато съдържа малък брой много дълги символни низове(Patricia_trie решава този проблем).
 Алгоритмите за Trie са по сложни от тези за (НДД).
 Не винаги е лесно да се съхраняват данни като символни низове.Например сложни обекти или числа с плаваща запетая.
Trie е най-подходящ, когато ключовете са с различна дължина и очакваме да има търсене на ключове, които ги няма в структурата. Ако ключовете очакваме да имат фиксирана дължина и всички търсения да са успешни, тогава можем да подобрим структурата като комбинираме всеки връх с единствен наследник  (например "i" и "in" ), получавайки Patricia_trie. Това спестява място, когато имаме дълги пътища в trie, който нямат разклонения, например когато в структурата има много ключове, които имат общ префикс или когата ключовете са съставени от уникални символи.

 Сложности
Може да се смята, че в trie се търси с O(1). Това не е съвсем правилно, защото ключовете се вземат с фиксирана дължина. Нека да имаме N различни ключа, долната граница на дължината на най-дългата дума всъщност е logkN където k е размера на азбуката. Откъдето следва че времето за търсене е Ω(log N).Същтото е и при (НДД).
Истинското преимущество на Trie е, че прави цената на всяко сравнение по-малка.В (НДД) предвиждаме сравняване на символни низове, което е със сложност O(m) в най-лошия случай, където m е дължината на по-късия. В trie единствените сравнения, които правим са между символи за константно време.

  Приложения 
  като заместител на други структури данни
Както показахме trie има няколко преимущества пред (НДД), също така може да се използва вместо Хеш-таблици, със следните прeимущества:

 Теоретично скоростта за търсене е еднаква, но на практика trie е по-бърз.
 Най-лош случай на търсене в хеш таблица е O(N).
 Няма колизии. 
 Няма нужда от хеш функция.
 Trie може да поддържа лексикографска наредба на ключовете.
Естествено има и известни недостатъци:

 Не е лесно да се представят всички ключове като символни низове.
 По-неефективен е отностно памет от хеш-таблицата.
  Представяне на речник 
Често срещано приложение на Trie е лексикографкси сортиран речник. Trie е подходящ за такава цел, защото поддържа ефективно търсене,вмъкване и триене на елемент. Въпреки това, ако единствената ни цел е да съхраняваме думи(т.е ако не се нуждаем да пазим допълнителна информация за всяка дума), минимален краен детерминиран автомат ще е по-подходящ.
Trie също е подходящ за реализация на алгоритми за съвпадение на подстрингове (например алгоритми за spell checking).

  Алгоритми 
Следният псевдо код показва основния алгоритъм за проверка дали даден символен низ е в Trie. Обърнете внимание, че children е списък от наследниците на върха.Казваме че даден връх е  "terminal" ako съдържа валидна дума.

function find(node, key) {
  if (key is an empty string) {  # base case
    return is node terminal?
  } else {  # recursive case
    c = first character in key  # this works because key is not empty
    tail = key minus the first character
    child = node.children[c]
    if (child is null) {  # unable to recurse, although key is non-empty
      return false
    } else {
      return find(child, tail)
    }
  }
}

  Наредба 
Лексикографска наредба на множество от ключове може да бъде постигната с този прост алгоритъм:

 Вмъкваме всички ключове.
 Извеждаме всички ключове в сортиран ред което е вид обхождане в дълбочина.

  Търсене в текст 
Специален вид Trie е suffix tree, който се използва за индексиране на всички суфикси на даден текст за да може да се търси бързо в текста.

  Допълнителна информация 
 NIST's Dictionary of Algorithms and Data Structures: Trie
 Tries by Lloyd Allison
 An Implementation of Double-Array Trie
 de la Briandais Tree
 Trie implementation in php
 Patricia trie

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Trie“.
			Категории: Структури от данни | Advanced Data Structures			
						
		