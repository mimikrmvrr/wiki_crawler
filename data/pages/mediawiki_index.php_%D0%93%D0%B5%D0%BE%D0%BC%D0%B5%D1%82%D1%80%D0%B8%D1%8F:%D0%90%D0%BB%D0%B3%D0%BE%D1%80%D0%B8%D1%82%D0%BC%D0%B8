Геометрия:Алгоритми
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Ето сега идва и интересната част.Ще видим как "сухата" теория влиза в действие при алгоритмите :).

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }  Взаимно положение на точка и права в равнината
Нека имаме уравнение на права g:Ax+By+C=0 и т.D с координати (xd,yd), а (x1,y1), (x2,y2) са координатите на две точки от правата.
Тогава т.D може да приема три положения:
1.Да принадлежи на правата.
2.Да е под нея. 
3.Да е над нея.
("под" - намира се в долната полуравнина спрямо правата g: и "над" - намира се в горната полуравнина спрямо правата g:)
//картинка да се покажат положенията
Най-лесният начин е да се провери това е чрез заместване на координатите на т.D в уравнението на правата  g:.
=>
Axd+Byd+C?=0
При заместване могат да се получат три възможности:
1.Резултатът да е по-голям от 0: Т.е. точката е над правата.
2.Резултатът да е по-малък от 0: Тоест точката да е под правата.
3.Резултатът да е равен на 0: Тоест точката е от правата.
(ето защо и се появява този "?" в уравнението на правата)
Ето го и самият алгоритъм написан на С++.



int main()
{
int x1,x2,y1,y2,xd,yd;
cin>>x1>>y1;//Координатите на първата точка от правата
cin>>x2>>x2;//Координатите на втората точка от правата
cin>>xd>>yd;//Координатите на точката, която ще проверяваме

//Основна част... 

     if((xd*(y1-y2)+yd*(x2-x1)+(x1*y2-x2*y1))==0) cout<<"Точката е на правата"<<endl;

     if((xd*(y1-y2)+yd*(x2-x1)+(x1*y2-x2*y1))>0) cout<<"Точката е над правата "<<endl;

     if((xd*(y1-y2)+yd*(x2-x1)+(x1*y2-x2*y1))<0) cout<<"Точката е под правата"<<endl;

   return 0;
}


 Успоредност и перпендикулярност
Понеже по-горе показах формулата, мисля че няма смисъл да се пише сорс, защото алгоритъмът произлиза директно от нея.

 Лице на изпъкнал многоъгълник
Лицето на изпъкнал многоъгълник се намира много лесно по формулата:
<math>  S=\frac{1}{2}*\begin{vmatrix}\begin{vmatrix} x0 & y0 \\ x1 & y1 \end{vmatrix} +  \begin{vmatrix} x1 & y1 \\ x2 & y2 \end{vmatrix} +
..... + \begin{vmatrix} xn & yn \\ x0 & y0 \end{vmatrix}\end{vmatrix}
</math>
Където, (x0,y0), (x1,y1), (x2,y2) ..... (xn,yn) са координатите на върховете на дадения изпъкнал многоъгълник.
Ето и примерна реализация на С++:


#include <iostream.h>
#include <vector>
#include <math.h>
using namespace std;

//структура за координатите 
struct A
{
int x;
int y;
};



int main()
{

	int N;
	cin>>N;//брой върхове на многоъгълника

	int S=0;//инициализация на лицето на многоъгълника

	int i,j;


	vector <A> vertex;
	for(i=1;i<=N;i++)//въвеждане на координатите на върховете на многоъгълника
	{
		A help;
	cin>>help.x;
	cin>>help.y;
	vertex.push_back(help);
	}
	
        //основна част на алгоритъма....
	for(i=0;i<vertex.size()-1;i++)
		S=S+vertex[i].x*vertex[i+1].y-vertex[i+1].x*vertex[i].y;
	
	S=S+vertex[vertex.size()-1].x*vertex[0].y-vertex[vertex.size()-1].y*vertex[0].x;
	

	cout<<abs(S)/2<<endl;
	return 0;
}

 Изпъкнала обвивка
В какво се състои задачата:Трябва да намерим обвивката от точки (техните координати), която обхваща всички крайни точки.

  само точките
//картинка1 само точките

  точките с готовата обвивка
//картинка2 точките с готовата обвивка
Ще ви представя така наречения Graham Scan, който работи с доста добра сложност от 
O(<math>   \log (N) </math>*N)
Идея:
1.Намираме точката, която ни е с най-малки х и у координати.Нека тя да е т.D.
2.Точката се премахва от множеството и след това сортираме в низходящ ред всички останали точки по косинус от ъгъла м/у правата, която се получава м/у т.D и точката която разглеждаме и правата успоредна на абцисата минаваща през т.D.
//картинка3 пример за двете прави

  пример за намиране на косинуса
//картинка4 пример за намиране на косинуса
3.Поставяме в стека с точките от обвивката т.D и първата от сортираните (защото те винаги са част от обвивката).
4.Нека т.В - последна добавена точка в стека, т.С - предпоследна добавена точка в стека
Взимаме следващата точка А от сортираните и проверяваме дали т.В(последна точка в стека) е в положителна полуравнина спрямо правата, минаваща през т.С(предпоследна в стека) и т.А:
ако е в положителна полуравнина добавяме т.А към стека,
иначе премахваме т.В от обвивката и продължаваме със стъпка 4, докато не обходим всички точки.
Бележка:
Не трябва да имаме в списъка две еднакви точки. Ако имаме такъв случай алгоритъма не работи коректно и не получаваме правилната обвивка.
Ето и сорс код:



#include <iostream.h>
#include <math.h>
#include <algorithm>
#include <vector>
using namespace std;
struct A{//структура да пазим координатите по двойки
int x;
int y;
};
int N;//брой точки
int sx=10000,sy=10000;//координатите на най-малката точка





vector <A> masiv;

int used[100];


bool CMP(A i,A j)
{

        //проверка коя от двете точки е по-голяма по синус...
	if((i.x-sx)/(sqrt(pow(i.x-sx,2)+pow(i.y-sy,2)))>(j.x-sx)/(sqrt(pow(j.x-sx,2)+pow(j.y-sy,2))))
		return 1;
	else return 0;
}



int main()
{




cin>>N;

int it;
int i;
for(i=1;i<=N;i++)//въвежда координатите
{	A temp;

	cin>>temp.x>>temp.y;
	masiv.push_back(temp);

	if(sy>masiv[masiv.size()-1].y)//проверява дали нямаме точка с по-малка ордината
	{
		it=masiv.size()-1;
		sy=masiv[masiv.size()-1].y;
		sx=masiv[masiv.size()-1].x;
	}
	

        //проверяра дали нямаме точка с по-малка абциса
	if(masiv[masiv.size()-1].y==sy&&masiv[masiv.size()-1].x<sx)
	{
		it=masiv.size()-1;
		sx=masiv[masiv.size()-1].x;
	}
}
masiv.erase(masiv.begin()+it);//изтрива намерената точка

sort(masiv.begin(),masiv.end(),CMP);//сортира по синус-а

cout<<endl<<endl<<endl<<endl;
for(i=0;i<masiv.size();i++)
	cout<<masiv[i].x<<" "<<masiv[i].y<<endl;

vector<A> stack;

//основна част... 


A temp;
temp.x=sx;
temp.y=sy;




stack.push_back(temp);//вкарва в обвивката най-малката точка
stack.push_back(masiv[0]);//вкарва и първата точка от сортираното множество

for(i=1;i<masiv.size();i++)//обхожда всички останали точки
{
	int x1,x2,x3,y1,y2,y3;
	
	int status=0;

	while(status==0)//докато не вкараме последната точка
	{
	x3=masiv[i].x;
	y3=masiv[i].y;
	x1=stack[stack.size()-2].x;
	y1=stack[stack.size()-2].y;
	x2=stack[stack.size()-1].x;
	y2=stack[stack.size()-1].y;


	if((x1*y3+y1*x2+x3*y2)-(x2*y3+y2*x1+x3*y1)>0)//ако е в положителната полуравнина
		stack.pop_back();//маха B от обвивката
	else {//иначе
		stack.push_back(masiv[i]);//вкарва А в обвивката
		status=1;}
	}
}
 

for(i=0;i<stack.size();i++)
	cout<<stack[i].x<<" "<<stack[i].y<<endl;




return 0;
}




 Взаимно положение на точка и многоъгълник
  1. Принадележност на точка в триъгълник 
Нека имаме триъгълник ABC и разглеждана точка O. Ако Sabc < Soab + Sobc + Soca, тогава точката О се намира извън триъгълника. В противен случай, ако някое от лицата Soab, Sobc или Soca е равно на нула, точката лежи на съответната страна. Щом никое от предишните не е изпълнено, точката О принадлежи на вътрешността на триъгълника.

  2. Принадележност на точка в изпъкнал многоъгълник 
Първият начин за проверка е аналогичен на проверката за принадлежност на точка в триъгълник. Ако Sabc..xy < Soab + Sobc + .. + Soxy + Soya, тогава точката O лежи извън триъгълника. В противен случай е вътре или на някоя страна.
Този подход има линейна по броя на върховете реализация. Съществува по-ефективна идея - чрез двоично търсене:
Избираме един връх от многоъгълника за начален (например върха Ax). Разглеждаме ъгъла с връх Ax и рамена минаващи през Ax-1 и Ax+1. Ако точката не принадлежи на ъгъла, значи е извън многоъгълника. Ако точката е вътре в ъгъла избираме върха A[n/2-x] (т.е. този, който разделя другите върхове на две равни части) и построяваме лъч с начало Ax през него. Този лъч разделя първоначалния ъгъл на две части и точката със сигурност е в някоя от тях. Проверяваме в коя и повтаряме действието с разделянето на ъгъла, в който се намира. Това продължава докато не ограничим точката между лъчи през два съседни върха Ay и Ay+1. Тогава ако точката принадлежи на триъгълника АxAyAy+1, то тя принадлежи и на многоъгълника, иначе е извън него.

  3. Принадележност на точка в произволен прост (несамопресичащ се) многоъгълник 
Една от идеите е следната - да си представим, че многоъгълникът представлява ограда и искаме да разберем дали тя загражда дадена точка или не. Нека забележим следното свойство на оградата - можем да наречем едната й страна вътрешна, а другата външна. Ако сме били откъм вътрешната страна и прескочим оградата сме отвън, ако пък сме били отвън и прескочим - озоваваме се вътре. Сега нега застанем в точката и тръгнем в някоя произволна посока. Когато срещнем ограда я прескачаме и ако сме били отвън ставаме вътре и обратно. При второ прескачане пак сме се върнали отвън/отвътре. Така на всеки две пресичания на оградата пак сме в тази област, в която е точката. Нека продължим така докато пред нас вече няма стени. Тогава се намираме със сигурност отвън. Ако сме прескочили четен брой пъти стената, значи и точката е била извън многоъгълника, в противен случай е била вътре.
Реализираме тази идея, като си изберем произволен (удобен за реализация) лъч с начало в разглжданата точка и за всяка страна на многоъгълника проверим дали не се пресича с лъча. Ако лъчът минава през край на отсечка ще преброим този край два пъти, което променя броя на пресичанията. Този проблем най-лесно се решава като изместим лъча в някоя друга посока. Една модификация на този алгоритъм може за бъде чрез използване на отсечка, а не лъч. За целта трябва да знаем някоя точка, която е със сигурност извън многоъгълника. Тогава аналогично броим пресечните точки на отсечката и страните на многоъгълника.
Друга идея е следната - заставаме в точката и започваме да се движим с поглед по многоъгълника. Ако сме вътре в него, за до обходим целия, ще трябва да направим едно пълно завъртане около оста си, защото той ни обгражда от всички страни. Ако пък сме отвън, колкото и да се завъртаме настрани в даден момент посоката ще се сменя и погледът ни пак ще се връща напред.
Реализираме тази идея като съберем всички насочени ъгли AxOAx+1, които съответстват на всяка страна от многоъгълника. Ако сборът е 0 градуса, значи точката O е извън многоъгълника. Ако сборът е 360 градуса, точката O е вътре.

 Взаимно положение на точка и окръжност
Алгоритъмът следва директно от формулата за окръжност.Център (x1,y1) и R радиус
(x − x1)^2 + (y − y1)^2 = R^2
и x и y са координатите на точката, която проверяваме.
При заместване се получава (x − x1)^2 + (y − y1)^2 ?= R^2 има 3 случая:
1.Ако е по-голямо от R^2 => е извън окръжността.
2.Ако е равно на R^2 => принадлежи на окръжността
3.Ако е по-малко от R^2 => е вътре в окръжността

 Намиране на пресечните точки на множество от отсечки
	Дали две отсечки се пресичат може да се определи със константна сложност. Най-лесния за писане алгоритъм за намирането на пресечните точки на множество от отсечки е като проверяваме всяка отсечка за пресичане със останалите. Но както се досещате този алгоритъм има сложност винаги O(n^2), което го прави доста неефективен при голям брой отсечки. Съществува алгоритъм който има по-добра сложност при наличието на не много пресечни точки. Той е доста по-сложен като реализация, но неговото бързодействие зависи и от изхода и е със сложност O((n+k)logn), кадето к е броя на пресечните точки.
Алгоритъм на Bentley-Ottmann





Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%93%D0%B5%D0%BE%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%8F:%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8“.
			Категории: Геометрия | Алгоритми			
						
		