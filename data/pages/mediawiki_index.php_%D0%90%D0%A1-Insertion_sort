АС-Insertion sort
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Анализ на алгоритъма:
Inssertion sort вмъква всеки елемент на правилното му място в масива, който накрая остава сортиран. Най-простото реализиране на този алгоритъм изисква два списъка - този който ще трябва да се сортира и втори в който ще се вмъкват елементите на правилното им място. За да спестят място повечето хора използват In-Place, което работи като като сортира елементите в същия списък и просто премества даден елемент в на неговото място в сортираната област.
Както и bubble sort, така и insertion sort имат сложност <math>O(n^2)</math>. Въпреки това insertion sort е около два пъти по-ефективен.
Pros: Лесен и прост за реализиране
Cons: Неефикасен за големи списъциЕмперически анализ:

Горната графика показва <math>n^2</math> сложността на insertion sort.
Insertion sort е "златната среда" при избор на алгоритъм за сортиране на списъци от по няколко хиляди елемента или по-малко. Алгоритъма е доста по-лесен от shell sort, но съвсем малко по-неефикасен. Освен това insertion sort е около два пъти по-бърз от bubble sort, и почти 40% от selection sort. Insertion sort не бива да се използва обаче за сортиране на списъци с големина повече от няколко хиляди елемнта или непрекъснато сортиране на списъци по-големи от няколкостотин елемента.
Примерен код:


void insertionSort(int numbers[], int array_size)
{
  int i, j, index;

  for (i=1; i < array_size; i++)
  {
    index = numbers[i];
    j = i;
    while ((j > 0) && (numbers[j-1] > index))
    {
      numbers[j] = numbers[j-1];
      j = j - 1;
    }
    numbers[j] = index;
  }
}






Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%90%D0%A1-Insertion_sort“.
			Категории: Алгоритми | Сортиране			
						
		