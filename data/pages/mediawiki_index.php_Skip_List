Skip List
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Въведение 
Структурата на skiplist се базира на една идея за оптимизация на обикновения list, която да подобри скоростите на добавяне, търсене и изтриване. По самата си идея той си е списък, но всеки негов възел има не само указател към следващия след него елемент, но и към други по-далечни елементи. Нека направо да преминем към идеята, защото според мен така най-лесно ще се разбере. Да допуснем, че нашият списък се състои от 6 възела.
<graphviz>
digraph g {
	graph [rankdir = "LR"];
	node [
		fontsize = "12"
	];
	"head" [
		label = "<f5> Връзка_5: null | <f4> Връзка_4: null | <f3> Връзка_3: |<f2> Връзка_2: |<f1>Връзка_1 | <f0> Глава"
		shape = "record"
	];

       "node0" [

		label = "<f1> Връзка_1: |<f0> Стойност: 4"
		shape = "record"
	];
	"node1" [
		label = "<f2> Връзка_2:| <f1> Връзка_1:  |<f0> Стойност: 8"
		shape = "record"
	];

       "node2" [

		label = "<f1> Връзка_1:  |<f0> Стойност: 9"
		shape = "record"
	];

       "node3" [

		label = "<f3> Връзка_3: null| <f2> Връзка_2: | <f1> Връзка_1: |<f0> Стойност: 11"
		shape = "record"
	];

       "node4" [

		label = "<f1> Връзка_1:|<f0> Стойност: 15"
		shape = "record"
	];

       "node5" [

		label = "<f2> Връзка_2: null | <f1> Връзка_1: null |<f0> Стойност: 21"
		shape = "record"
	];
	"head":f1 -> "node0":f1 

       "head":f2 -> "node1":f2
       "head":f3 -> "node3":f3

	"node0":f1 -> "node1":f1        

       "node1":f1 -> "node2":f1
       "node1":f2 -> "node3":f2
       "node2":f1 -> "node3":f1
       "node3":f1 -> "node4":f1
       "node3":f2 -> "node5":f2
       "node4":f1 -> "node5":f1

}
</graphviz>
Имаме един специален възел, наречен глава, който е с не по-малко връзки от който и да е елемент в списъка. Освен него си имаме нашите 6 възела, като всеки е свързан със следващия след него, но вторият е свързан и с четвъртия, а четвъртият и с шестия. Главата е директно свързана с първия, втория и четвъртия. Каква е концепцията? Всеки възел има поне една връзка, като за всяка степен на двойката, която дели индекса му, получава по още една връзка(за това например четвъртия има 3 връзки). Ще казваме, че един възел е с височина i, ако притежава i на брой връзки и ще казваме, че дадена връзка е на височина i, ако тя е връзката с индекс i за дадения възел. Всяка връзка на височина i свършва в първия възел след нея, който има връзка на височина i. Ако няма повече такива възели, връзката сочи към празния указател. Елементите в структурата ги поддържаме сортирани по техните стойности. 
Очевидно, така построен, нашият списък ще поддържа логаритмичнa скорост на find: ако например искаме да намерим някой елемент, първо проследяваме най-високата връзка на главата. Ако тя сочи към null или пък към елемент, който е със стойност по-голяма от търсената - слизаме едно ниво във височината на връзките. Ако ли пък дадената връзка сочи към елемент с по-ниска стойност, се прехвърляме към него и продължаваме търсенето от същото ниво. Така докато стигнем до нулево ниво или намерим търсения връх (в първия случай това ще ни доведе до това че търсения възел не съществува). 
Описаният алгоритъм проследява връзките, като не допуска да се премине във връх с по- голяма стойност от търсената и  всъщност е много близък до двоичното търсене: на всяка стъпка взимаме средата на интервала и сравняваме с търсената стойност. Например, ако в горния пример търсим 9, ще минем през главата, ще подминем нулевите връзки 4 и 5, ще слезем на ниво 3, ще сверим с 11 и ще видим, че <math>11 > 9</math>. Ще слезем още едно ниво надолу ще сравним с втория възел: <math>8 < 9 =></math> ще преминем към втория възел, ще вземем неговата връзка на ниво 2 и ще видим че тя сочи към възел с по- голяма стойност (знам че тази проверка в момента изглежда ненужна, но ще придобие смисъл по- нататък), ще слезем още едно ниво надолу и сверявайки вече ще открием възела с търсената стойност. Ако търсим 11, направо отиваме във възел номер 4 (след като сме слезли от нива 5 и 4).
Да напомня, че и двоичните дървета поддържат същата логаритмична сложност на find. Като се замислим обаче откриваме, че delete и insert не са с така хубави сложности: ако например искаме да вмъкнем елемент по средата на списъка, очевидно, че ще трябва да променим височините на всички елементи оттам нататък, иначе структурата няма да се запази. Това дава линейна сложност, а това е незадоволително. За това хората са измислили и реализирали структурата:

  Skip List 
Наистина идеята на тази структура е почти същата като на гореописаната. Разликата идва в това, че умните хорица, които са я измислили, са се решили да жертват своята толкова прецизна детерминираност, за да постигнат по-добри сложности. Те решават да определят височината на даден възел при създаването му, като не я променят повече и като гледат съотношението на възлите с височина едно към тези с височина две да е горе-долу правилно. Второто го правят, като просто взимат едно събитие с вероятност на случване 1/2 и проверяват дали то се е случило ( напр. взимат едно random число и проверяват дали е повече от половината на възможния максимум или дали е четно). При всеки положителен отговор, височината му се увеличава с едно и се задава нов въпрос и така до отрицание или достигане на предварително зададена максимална височина. Недетерминираността е единственото нещо, което отличава skiplist от описаната по-горе структура. Малко по-долу съм описъл операциите по нея и сами ще се убедите че е така. 
С редица изследвания хората са доказали, че тази стуктура запазва логаритмична сложност на търсенето, като в същото време delete и insert също проявяват логаритмична сложност. Това прави структурата съвършена, защотото е лесна за реализация, а сложностите й са добри. Последното изречение би било вярно ако си нямахме stl и вградено червено-черно дърво. Но ако по някаква причина нямате stl (пишете на Borland C или на достатъчно стар компилатор или пък поръчителят ви забранява да го ползвате), то ето ви решението.

  Методи на структурата 
  Find 
Този метод наистина е съвсем същият като описания по-горе: 

ако отиваме след дадената стойност, слизаме едно ниво надолу; 
ако сме преди нея - следваме връзката;
ако намерим дадената стойност - връщаме.
  Insert 
Първата стъпка при вмъкването е да определим височината на новия елемент. Вече описах по-горе как става това. Веднъж определили височината на даден възел, той си я запазва до изтриването му. Както при find започваме обхождането от максималната височина. В началото докато не слезем до височината на новия връх си процедираме както при find. Когато слезем до толкова ниско, че да има връзка с моментната височина и в новия връх, започваме да накъсваме старите връзки, а именно: ако връзката v ни води до елемент с по-голяма стойност, то на връзката със съответната височина от новия възел придаваме стойността на v, а v започва да сочи към новия елемент(точно сякаш сме накъсали връзката с блока от връзки на новия възел). После слизаме едно ниво надолу и повтаряме операцията от възела на v. Тук при този метод не можем да спрем преди да стигнем до връзката от най-ниско ниво, защото иначе рискуваме при по-нататъшни операции (например delete на междинен елемент) да ни се наруши структурата на skiplist. 
Нека сега дам и един пример. Нека например имаме горния списък и да искаме да вмъкнем елемент със стойност 10. Да кажем че с нашите мистериозни начини сме определили че трябва да е с височина 2. Започваме от ниво 5. Виждаме че съответната връзка на главата не сочи наникъдеи за това слизаме едно ниво надолу. Аналогично подминаваме и ниво 4 и стигаме до трето ниво където връзката ни сочи към елемент със стойност 11.  <math>11 > 10 =></math> слизаме още едно ниво надолу. Тамошната връзка ни сочи към елемент със стойност по-малка от 10, затова я следваме. Сега новата връзка на ниво 2 ни сочи към елемент с по-висока от 10 стойност, но вече сме на достатъчно ниско ниво, така че е време да понакъсаме връзките. Връзка 2 на новия ни елемент започва да сочи към елемента със стойност 11, а тази на елемента със стойност 8 започва да сочи към новия елемент. Сега слизаме едно ниво надолу, като още сме във възела със стойност 8. Новата връзка от него сочи към елемент със стойност <math>9 < 10</math> следваме я. Сега отново имаме връзка, сочеща към елемент със стойност по-голяма от тази на новия елемент, така че пак накъсваме връзките: връзка 1 на елемента със стойност 9 вече сочи към новия елемент, а връзка 1 на новия сочи към елемента със стойност 11. Повече нива за обработка нямаме. Резултатът в крайна сметка ще е:
<graphviz>
digraph g {
	graph [rankdir = "LR"];
	node [
		fontsize = "12"
	];
	"head" [
		label = "<f5> Връзка_5: null | <f4> Връзка_4: null | <f3> Връзка_3: |<f2> Връзка_2: |<f1>Връзка_1 | <f0> Глава"
		shape = "record"
	];

       "node0" [

		label = "<f1> Връзка_1: |<f0> Стойност: 4"
		shape = "record"
	];
	"node1" [
		label = "<f2> Връзка_2:| <f1> Връзка_1:  |<f0> Стойност: 8"
		shape = "record"
	];

       "node2" [

		label = "<f1> Връзка_1:  |<f0> Стойност: 9"
		shape = "record"
	];

       "node3" [

		label = "<f3> Връзка_3: null| <f2> Връзка_2: | <f1> Връзка_1: |<f0> Стойност: 11"
		shape = "record"
	];

       "node4" [

		label = "<f1> Връзка_1:|<f0> Стойност: 15"
		shape = "record"
	];

       "node5" [

		label = "<f2> Връзка_2: null | <f1> Връзка_1: null |<f0> Стойност: 21"
		shape = "record"
	];

       "node6" [

		label = "<f2> Връзка_2:  | <f1> Връзка_1:  |<f0> Стойност: 10"
		shape = "record"
	];
	"head":f1 -> "node0":f1 

       "head":f2 -> "node1":f2
       "head":f3 -> "node3":f3

	"node0":f1 -> "node1":f1        

       "node1":f1 -> "node2":f1
       "node1":f2 -> "node6":f2
       "node2":f1 -> "node6":f1
       "node3":f1 -> "node4":f1
       "node3":f2 -> "node5":f2
       "node4":f1 -> "node5":f1
       "node6":f2 -> "node3":f2
       "node6":f1 -> "node3":f1

}
</graphviz>

  Delete 
При delete нещата са почти същите като при insert. Следваме връзките докато не стигнем до някоя, която да сочи към нашия елемент (елемента с търсената стойност). Тогава просто я пренасочваме да сочи към съответната връзка на нашия елемент и слизаме едно ниво надолу. И така до най-ниското ниво. Отново логично сложността на метода е <math>log n</math>.

  Изследвания 
След много изледвания хората са доказали, че тази структура проявява сложности на всички операции <math>log n</math> при рандом функция, която връща правилно разпръснати числа. Многото изследвания са необходими заради недетерминистичното поведение на skiplist.
До сега описвах структурата, като височината на всеки възел се определяше от това колко пъти подред е изпълнено едно условие с вероятност 1/2. Хората обаче се запитали какво ще стане, ако променят тази вероятност. Така те въвели параметъра на skiplist вероятност, т. е. вероятността на условието при всяка проверка да е изпълнено. На мен ми се струваше излишна тази работа, но се оказва, че операциите на структурата били по-бързи при вероятност 1/4. Освен това, ако помните, казах, че всеки връх има предварително зададена максимална височина. И за това са правени изследвания и се оказало, че оптималната височина е <math>log_{1 \over p} n</math> , където p е вероятността, а n е очаквания среден брой елементи в структурата, така че, както се сещате, на конструкторът на нашата структура трябва да се задава освен вероятност и очакван среден брой елементи.

  Мои наблюдения 
Е, време е да кажа и аз какво открих. Правих няколко теста и видях, че при малък брой елементи вероятностите 1/4 и 1/2 са неотличими, но при голям вече разликата е забележима. Оказа се, че при по-големи тестове почти винаги 1/4 дава по-добри времена; при сортиран вход дава почти същите времена като на червено-черното дърво. Още: правих си тестове и с височините и за двете вероятности, като правих изкуствени отклонения от оптималната.  Оказа се, че наистина това е оптималната въпреки, че имаше и някои доста стряскащи групи от по 5-6 теста, в които височина с 2 по-малко от оптималната излизаше най-подходяща. Може би една от причините е, че в доста голяма част от тестовете половината от операциите бяха за началното въвеждане на числата, но според мен точно така ще е, ако се използва в реална обстановка, затова смятам, че тези резултати са реални.

  Моя реализация 
Тук може да намерите header, в който е реализирана структурата. skiplist.h

  Други страници в мрежата 
SkipLists Tomas Anasastio
SkipList Wikipedia
Симулатор на SkipList

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Skip_List“.
			Категории: Структури от данни | Advanced Data Structures			
						
		