Динамично оптимиране
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Динамичното оптимиране е подход, който се използва много често при решаване на задачи от ученически и студентски състезания. Може да се използва за решаване на задачи, които имат оптимална подструктура. Това означава, че една задача може да се "разбие" на няколко по-малки и решенията за по-малките задачи да се използват, за да се намери решението за по-голямата.

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Въведение 
Когато една задача има оптимална подструктура това означава, че оптималните решения за някои подзадачи на дадената могат да се използват за намиране на търсеното решение. Когато се решава една такава задача по метода на динамичното оптимиране тя първо се разбива по подходящ на подзадачи. Тези подзадачи се решават като пак се използва динамично оптимиране. След това намерените решения се комбинират, за да се получи отговора на голямата задача.
Когато една задача се разбие на подзадачи, тези подзадачи също се разбиват на по-малки и т.н. В един момент се достига до тривиални задачи отговора, за които лесно може да бъде намерен.
Някоя по-малка задача може да се използва при решаването на няколко по-големи задачи. Ако веднъж се запомни получения отговор той може да се използва многократно при решаване на по-големи задачи. Например задачата за намиране на числата на Фибоначи може да се реши с метода динамично оптимиране. За намиране на 6-то число са нужни 5-то и 4-то, а за намиране на 5-то - 4-то и 3-то. По този начин стойността на 5-то число е нужна два пъти. Ако се пресметне веднъж тя може да бъде запомнена и при следващия запитвания направо да се използва запомнената стойност.
Метода динамично оптимиране може да бъде приложен по два начина - отгоре-надолу и отдолу-нагоре. Когато е дадена една задача А и отговора за нея може да бъде получен чрез задачи В и С може рекурсивно да се решат задачите В и С и след това да се обедини отговора за тях. Същото може да се направи за задачи В и С. Ако този метод се използва директно при задачата за числата на Фибоначи ще се получи едно много неефктивно решение. Някои от подзадачите ще се пресмятат по няколко пъти. Ето защо тук е полезно да се използва запаметяване (memoization). Когато в хода на рекурсията е решена една задача за първи път отговора за нея се запомня и при следващо запитване направо се използва готовата стойност. По този начин силно се намалява сложността по време на решението. За сметка на това се използва допълнителна памет. Ето защо при този подход трябва да се направи компромис между скорост и използвана памет. Този начин на пресмятане на задачите върви отгоре-надолу - от големите задачи към по-малките. Често такъв вид решение е най-интуитивно за написване. Един недостатък при него е че не може да позволи прекалено голяма дълбочина на рекурсията заради препълване на използвания стек.
При подхода отдолу-нагоре първо се пресмятат по-малките задачи, след което изчислените стойности се използват за намиране на отговора за по-големите. Така се избягва използването на рекурсия, но понякога този вид решения са по-трудни за измисляне. Също така в някои случаи е възможно да се решават само тези подзадачи, които ще са нужни, а не всички.

 Представяне на сума с минимален брой монети
Задача:
Дадени са n монети със стойности съответно: 
C(1), C(2), ..., C(n), и сума S. Да се намери представяне на сумата S с минимален брой монети измежду наличните. 
Стойностите C(1), C(2), ..., C(n), както и сумата им S са цели положителни числа.
Решение:
Настоящата задача се решава леко с методите на динамичното оптимиране. Дефинираме целевата функция F(X) така: 

     F(0) = 0;

     F(X) : ako X == C(i) => F(X)=1 ,  иначе F(X) = F(X – C(i))] + 1 ;

където: F(X) е търсеният минимален брой необходими монети за представяне на сумата, а C(i) е стойността на i-тата монета. 
Стойностите на F(X) ще изчисляваме последователно, започвайки от X=1. 
Така при изчислението на F(X) за някакво конкретно X всички необходими ни предишни стойности на F ще бъдат вече пресметнати (Стойностите на монетите са цели и строго положителни). 
За всяка сума X ще пазим освен минималния брой монети, за който се постига, и индекса на последната добавена монета. 
Това ще ни позволи за произволно вече разгледано X да възстановим едно конкретно множество от монети, за което се постига екстремалната стойност на F(X). 
Намирането на такова множество ни е необходимо, за да си гарантираме, че всяка монета участва в сумата неповече от веднъж. Условията за да може да участва j-тата монета в i-тата сума са:

     1. C(j) ≤ i 

     2. Сумата i–C(j) да може да се получи с наличните монети

     3. j да не участва в получаването на сумата i–C(j) 

При проверката дали се удовлетворява третото условие (което е еквивалентно на естественото изискване всяка монета да участва неповече от веднъж в сумата) се налага явно намиране на участващите в сумата i–C(j) монети.
Аналогична операция се извършва и накрая, след изчисляването на F(S) за получаване на конкретно множество от монети, за които се постига. 
Възстановяването на конкретно множество се извършва със сложност O(S) (или O(n), тъй като S зависи от n. 
Виж по-долу.) Нека последният добавен елемент при получаването на сумата да е бил j1. 
Тогава предпоследният j2 ще бъде последният, съответстващ на сумата i–C(j1). 
Предпредпоследния елемент j3 получаваме като съответen на сумата i–C(j1)–C(j2) и т. н. Процесът продължава до достигане на сума без предшественик, а именно нулевата. 
Ще се опитаме да оценим сложността на предложения алгоритъм. 
Функцията FindMin() съдържа два вложени цикъла от тип for със сложности съответно O(Sum) и O(n), в тялото на които се съдържа обръщение към функцията MozheJ(), която от своя страна има сложност от порядъка на O(n). 
Тогава общата алгоритмична сложност е от порядъка на O(Sum.n.n). 
Нека M е максималната стойност на монета. Тогава Sum ≤ M.n. Оттук получаваме O(M.n3) или, след изключване на константата M ─ O(n3). 
Характерно за горния алгоритъм е, че като страничен ефект намира минималния брой необходими монети, както и самите монети, не само за търсената сума, а и за всички суми, по-малки или равни на Sum. 
Тогава, ако положим Sum да бъде общата стойност на наличните монети, то в масива Sumi ще получим минималните представяния на всевъзможните суми на монетите. 
При това отново със сложност O(n3)!!! 

 Движение на североизток
Задача: Имаме Матрица N*M ( N,M <1000 ) и всяка клетка съдържа даден брой ябълки. Трябва като тръгнем от най-горе най-ляво и стигнем до най-долу най-дясно да вземем колкото се може повече ябълки, като имаме право да се движим единствено надолу и надясно.
Тук очевидно подхода търсене с връщане не може да ни послужи, за това трябва да потърсим по умно решение чрез мотода на Динамичното оптимиране. Първо трябва да забележим, че има само 2 начина да се стигне до клетка: от ляво (освен ако не сме в първата колона) или от горе (освен ако не сме на първия ред). За да намерим най-доброто решение за тази клетка, трябва да сме намерили решенията за всички клетки, от които може да стигнем до тази клетка.
От горното наблюдение може да се извади следната релация:
S[i][j]=A[i][j] + max(S[i-1][j], if i>0 ; S[i][j-1], if j>0) (където i представлява реда и j колоната на таблицата, горния-ляв край с координати {0,0}; и A[i][j] броя ябълки намиращи се в клетка i,j.
S[i][j] трябва да бъде пресмятано като тръгнем от ляво на дясно по всеки ред и сменяме редовете от горе надолу.
Псевдокод:

For i = 0 to N - 1
  For j = 0 to M - 1
  S[i][j] = A[i][j] +
     max(S[i][j-1], if j>0 ; S[i-1][j], if i>0 ; 0)

Отговора стои в клетка S[n-1][m-1]

 Най-дълга растяща подредица
Тук ще опишем една задача, която може да се реши с помощта на подхода динамично оптимиране. В нея се иска за една редица от числа да се намери дължината на най-дългата подредица числата, в която са в нарастващ ред. Първо трябва да се раздели задачата на подзадачи. Нека дефинираме като задача това да се намери дължината на най-дългата нарастваща подредица, която завършва в дадено число с индекс N. Ако числата са N на брой, то задачата приложена за числото с индекс K (K<N), може да се разгледа като подзадача на дадената. Решението за K=1 е тривиално. Ако искаме да пресметнем отговора за някое по-голямо K трябва да се прегледат всички числа преди K-то, които са по-малки от него и от тях да се избере това, в което завършва най-дългата нарастваща подредица. По този начин се използват решенията за подзадачите на дадената. Решенията за подзадачите могат да се пресметнат отдолу-нагоре или отгоре-надолу. При подхода отгоре-надолу е нужно да се запонят вече пресметнатите отговори тъй като в противен случай те ще се изчисляват всеки път наново, когато са нужни. Възможно е задачите да се решават отдолу-нагоре. Задачата за едно число е тривиална. Всяка следваща се решава на базата на по-малките, които вече са пресметнати както беше описано по-горе. Накрая за отговор се взема решението за тази от подзадачите, който е най-голям. По този начин сложността на решението е O(N^2).
Интересно е че тази задача може да бъде решена по по-оптимален начин като отново се използва динамично оптимиране. За целта се дефинира различна задача за решаване. Търси се колко е максималния елемент, с който може да завършва една нарастваща подредица с N числа. В началото решението за никоя подзадача не е известно. Числата започват да се обхождат последователно отляво-надясно. За всяко число X се търси най-дългата подредица, която може да завършва с число, което е по-малко от X. След като бъде намерена тази редица (нека тя е с дължина L) следва, че ако числото X бъде "прилепено" в края и ще се получи редица, която е с дължина L+1. Проверява се дали пресметната досега оптимална стойност за редица с дължина L+1 не е по-голяма от числото X. Ако е така стойността за редица с дължина L+1 се подобрява. По този начин след като бъдат обходени всички числа от редицата ще са намерени оптималните стойности за различните по дължина възможни редици. Проверява се най-дългата редица, която може да се получи и нейната дължина е отговора на поставената задача. Когато за дадено число се прави търсене сред досега намерените стойности от динамичното оптимиране може да се използва двоично търсене, за да се намери бързо търсената стойност. Това е така, защото колкото по-дълга е една подредица образувана от някакви числа толкова по-голямо е минималното число, с което може да завършва. Следователно ако стойностите пресметнати в даден момент се подредят според дължините на редиците, на които отговарят те ще образуват нарастваща редица и ще позволяват да се търси сред тях с двоично търсене. По този начин сложността на този алгоритъм е O(NlogN). От този пример се вижда как подхода динамично оптимиране може да се използва по различни начини за решаване на една задача.

 FLOWERS - IOI 1999
В предната задача динамичното оптимиране зависи от един параметър. Понякога се налага да се използват два или повече аргумента, за да се опише една задача. Тази задача, давана на Международната олимпиада по информатика през 1999 година, може да се реши с метода на динамично оптимиране като се използват два аргумента. Условието можете да прочетете тук. Като задача може да се дефинира въпроса по какъв начин най-оптимално може да се поставят първите N цветя в първите M вази. Нека отговора за тази задача е D[N][M]. Когато се решава една такава задача се разглеждат два случая. В единия случай цветята с номер N се поставят във ваза с номер M. Тогава търсената стойност е D[N-1][M-1] + A[N][M], където A[N][M] е естетическата стойност на това цветятя с номер N да стоят във вазата с номер M. В другия случай цветята с номер N не стоят във вазата с номер M. Следователно D[N][M] =  D[N][M-1], тъй като първите N цветя ще се поберат в първите M-1 вази. Като отговор на задачата се взема по-малката от двете стойности. Накрая отговора на задачата е D[F][V], като F е броят на видовете цветя, а V е броя на вазите.

 StarAdventure - SRM 208 Div 1
Това е една доста по сложна задача, за която ни трябва доста по-добро наблюдение, за да я сведем до динамично решение.
Задача:
Имаме матрица (N x M). Във всяка клетка има по няколко ябълки. Започвате от горния ляв ъгъл на матрицата. Можете да вървите надясно или надолу по една клетка, като трябва да стигнете до долния ляв ъгъл. След това трябва да се върнете до горния ляв ъгъл на матрицата, като вървите нагоре и наляво по една клетка. Когато пристигнете там пак се връщате в долния десен ъгъл. Когато минете през клетка вземате всички ябълки в нея. Намерете максималния брой ябълки които може да съберете.
Ограничения: 1 < N, M <= 50 ; всяка клетка съдържа между 0 и 1000 ябълки.
Първото нещо, което забелязваме е, че тази задача много прилича на задачата Движение на североизток, където трябва само веднъж да минем от горе ляво до долу дясно, като съберем максимален брой ябълки. Ще е много по-добре ако се помъчим да сведем нашата задача до тази. Първо забелязваме, че относно втория път няма значение дали тръгваме от долния десен ъгъл нагоре или обратното, защото може просто да посетим същите клетки, само че в обратен ред. Така получаваме, че имаме три пътя от горе до долу, което доста намалява трудността на проблема. Може да считаме тези три пътя като ляв, среден и десен. Когато два пътя се пресичат (като на фигурата по надолу) 
Файл:Http://www.topcoder.com/i/education/dynProg 1.gif
може да считаме, че те всъщност са като тази картинка, без това да пречи на резултата.
Файл:Http://www.topcoder.com/i/education/dynProg 2.gif 
По този начин получаваме три пътя, които може да считаме за един ляв, един десен и един среден. Освен това виждаме, че за постигане на оптимален резултат не трябва да се пресичат (освен в най-горния ляв ъгъл и най-долния десен). За всеки ред y (освен за първия и последния), x кординатите на реда (x1[y] , x2[y] и x3[y]) ще бъдат : x1[y] < x2[y] < x3[y] . Като вече сме направили това динамичното решение става доста по-ясно. Нека приемем че сме на ред y. Нека приемем, че сме намерили решенията за x1[y-1] , x2[y-1] and x3[y-1] . От тях може да намерим и оптималното решение за ред y. Сега само трябва да намерим как да минаваме от единия ред на другия. Нека направим масив Max[i][j][k], който представлява максималния брой ябълки събрани до y-1 включително, със трите пътя свършили съответно в колона i, j, и k. За следващия ред y добавяме към Max[i][j][k] (получен преди това) броя ябълки стоящи в клетки (y,i), (y,j) и (y,k). С това слизаме една стъпка надолу. След като сме направили такава стъпка може да считаме, че тези пътища могат да се движат и на дясно. За да пречим на пътищата да се пресичат, първо местим левия път,  след това средния и накрая десния.

 Заключение
Динамичното оптимиране е много мощен метод, който се използва за решаване на многожество задачи давани по ученически и студентски състезания. Има различни начини, по които може да се приложи и методи за оптимизиране на стандартния подход.





Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%BD%D0%BE_%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D1%80%D0%B0%D0%BD%D0%B5“.
			Категория: Алгоритми			
						
		