Най-близка двойка точки
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Файл:ClosestPair.png  Най-близката двойка точки е в червено.
 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Задачата 
Нека е дадено множество Q, състоящо се от n точки в равнината (n >= 2). Най-близка двойка точки ще наричаме, тези две точки, които са най-близо по отношение на евклидовото разстояние. Ако p1=(x1,y1) и p2=(x2,y1), то евклидовото разстояние между тях е sqrt((x1-x2)^2+(y1-y2)^2). Ако две точки от Q съвпадат, то разстоянието между тях е 0. Да се намери разстоянието между най-близката двойка точки.
Решението по-долу съвсем лесно може да бъде реализирано така, че да връща и точките, между които разстоянието е най-малко.

  Brute-force алгоритъм 
Очевидно, можем да пресметнем разстоянието между всеки две точки от Q и да намерим минимума. Сложността на този алгоритъм е О(n^2). Съществува, обаче, и по-бързо решение на задачата.

  Алгоритъм разделяй и владей 
При всяко извикване, на рекурсивната функция f(P,X,Y) се подават като параметри: P - подмножество на Q, X,Y - масиви, съдържащи и двете координатите на точките от P и сортирани в нарастващ ред съответно по x-координата,y-координата. Ако броят на елементите в P e по-малък или равен на 3 се изпълнява brute-force алгоритъма. Функцията f(P,X,Y) връща разстоянието между най-близката двойка точки измежду точките от P.

  Разделяй 
Намираме вертикална права l, която "разделя" множеството P на две множества L i R, така че L съдържа ceil(|P|/2) елемента, а R съдържа floor(|P|/2) елемента и, разбира се, всички точки от L са наляво от l или върху l и всички точки от R са надясно от l или върху l. Масивът X се разделя на масиви X_l и X_r, които съдържат точките съответно от L и R, сортирани в нарастващ ред по x-координатата си. Масивът Y се разделя на масиви Y_l и Y_r, които съдържат точките съответно от L и R, сортирани в нарастващ ред по y-координатата си. 

  Владей 
След като сме разделили P на L и R, правим две рекурсивни извиквания. Нека m_l = f(L,X_l,Y_l) и m_r = f(R,X_r,Y_r). Нека m = min(m_l,m_r).

  Обединение 
Най-близката двойка точки от P е или тази на разстояние m, или двойка, такава че едната и точка е от L, а другата от R. Сега ще определим има ли такава двойка, чиeто разстояние е по-малко от m. Ако съществува такава двойка, то и двете точки трябва да са на разстояние по-малко или равно на m от правата l. За да намерим такава двойка, ако съществува, ще направим следното:

 Създаваме масив Y', който съдържа всички точки от У, без тези на разстояние по-голямо от m от правата l. Масивът Y' също е сортиран.
 Последователно, за всяка точка p от Y', пресмятаме разстоянието до всяка от следващите 7 (седем) точки от Y'. Едновременно с това, обновяваме минимума m' на престметнатите разстояния между точките от Y'.
 Ако m' < m, то функцията връща m'. В противен случай, функцията връща m.
  Детайли при имплементацията 
При описанието, изпуснахме някои детайли, които са определящи за сложността на алгоритъма.
Основната трудност е в осигуряването масивите X_l, X_r, Y_l, Y_r да са сортирани по подходящата координата при извикванията на f(). Също така необходимо е да осигурим сортирането на Y' по y-координатата. Тъй като параметъра X, е сортиран преди да бъде подаден на f(), то разделянето на множеството P на L и R, става лесно за линейно време. Формираме X_l / X_r, като вземем съответно първите |L| / последните |R| елемента от P.
След като сме разделили P на L и R, и имаме сортирания по y-координати масив Y (така е подаден на f()), можем да разделим Y на Y_l и Y_r за линейно време по следния начин. Разглеждаме последователно точките от Y. Ако Y[i] е в L, добавяме я към края на Y_l. В противен случай, добавяме я към края на Y_r. Аналогично можем да формираме и масива Y'.
Важно е да отбележим, че за да работи алгоритъма, трябва при първото извикване на рекурсивната функция f() да подадем коректни данни. Т.е. нужно е предварително да сортираме масивите X и Y съответно по x-координати и y-координати. Това може да стане за време O(n*logn).

  Сложност 
Така описания алгоритъм има сложност O(n*logn)

  Коректност на алгоритъма 
Като цяло коректността е очевидна с изключение на две неща.
Първо лесно се забелязва, че при ограничението за край на рекурсията |P|<=3, си осигуряваме, че няма да опитваме да решаваме задачата за |P|=1 (което, разбира се, няма смисъл).
Второ, малко по-трудно е да се докаже, че за всяка точка p от Y' е нужно да разглеждаме само следващите седем точки от Y'. Интересно е, но няма да го пиша сега.





Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%9D%D0%B0%D0%B9-%D0%B1%D0%BB%D0%B8%D0%B7%D0%BA%D0%B0_%D0%B4%D0%B2%D0%BE%D0%B9%D0%BA%D0%B0_%D1%82%D0%BE%D1%87%D0%BA%D0%B8“.
			Категории: Алгоритми | Геометрия			
						
		