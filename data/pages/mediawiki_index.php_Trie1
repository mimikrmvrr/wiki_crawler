Trie1
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Обща информация 
TRIE е дървовидна структура, която се използва за запазване и извличане на разнообразни данни на принципа: ключ - стойност, като ключът се възприема като дума над дадена азбука. Тъй като, различни обекти лесно могат да бъдат представени като последователност от букви, то и употребата на тази структура е възможна в разнообразни случаи от ежедневието. Особенността на пазенето на ключовете в TRIE-а е, че не е обособено специално място за всеки ключ, а във върховете на дървото се пазят само букви от азбуката на ключа. Той се получава при обхождане на дървото и така подобни ключове с обща начална част могат да споделят общ маршрут от върха до края на общата си част, което се отразява в пестене на памет. TRIE е широко използвана стуктура, в най-различни алгоритми и има разновиностни като suffix trie и patricia tree.

  Структурата отблизо 
Както всяка една структура от данни, така и тази може да бъде реализирана по различни начини в зависимост от обстоятелствата (размер на азбуката, различни неща които искаме да извлечем освен наличието на ключа и т.н.).Тук ще се спрем на по-общата дефиниция, като само ще предложим различни подходи, за оптимизиране, реализацията на които ще оставим на читателя, като упражнение. За удобство нататък ще използваме понятията дума и ключ взаимозаменяемо, тъй като в случая те се припокриват.
Нека T е кореново дърво.
Нека A е азбука и v е дума от тази азбука.
Всеки връх на Т съдържа следната информация:
- буква от А
- флаг (или брояч)  - интерпретира се като: Дали пътя от корена до този връх е ключ или е префикс на ключ(ове) и трябва да продължим на вътре за да го намерим (аналогично ако е брояч - колко пъти е бил добавен този ключ(дума), нещо изключително полезно, ако се интересуваме колко пъти е била добавена тази дума или ако по време на работа искаме да изключваме ключове, но за това по нататък)
- ако флагът е вдигнат то тогава може да използваме и допълнителни полета като стойности асоциирани с този ключ
- списък на наследници (в предложения алгоритъм структурата на дървото ще реализираме чрез масив с размер = броя букви от азбуката. Трябва да отбележим че това е изключително неефективен подход от гледна точка на памет, особено при по-голяма азбука, но много бърз като времете за достъп при търсене на следващата буква от даден ключ ще е О(1). )
Всяко ребро се характеризира със буквата на върха към който сочи, за да знаем накъде да поемем от текущия връх, ако търсим дадена дума.

  Пример: 
TRIE след добавяне на думите: "лютеница", "любов", "люспа", "лютиер", "асфалтобетон", "лют", "асфалт"

Сивите квадратчета изобразяват върхове с вдигнат флаг, а празното квадратче в началото е празната дума.
Всики TRIE започва с празната дума, както всеки език над дадена азбука съдържа празната дума (освен празният език естествено)

  Сложност: 
 - Като обхождаме дървото, търсейки даден ключ с дължина М то можем да го намерим със сложност О(М) , ако той е бил добавен
 - Като добавяме можем да добавим ключ със сложност О(М), където М представлява дължината на думата.
 - пaмет: зависи ако думите са много различни, то повече, ако по си приличат по-молко.


 Обаче: тази сложност за търсене е ако ползваме масив, за представяне на наследниците, което за големи азбуки е на практика, 
   
 неприложима. Това налага употребата на помощни структури като свързани списъци, хештаблици, и т.н. Важно е да се отбележи, че 
 
 освен да е свързан списъкът е добре и да е поддържан в сортиран вид, защото така няма нужда обхождаме целия списък за да 
 
 проверим дали от текущият връх излиза буквата която търсим, а освен това се запазва и едно основно свойство на структурата - при 
 
 обхождане в инордер да изкараме съдържанието в лексикографски ред(при масива и хеш-а просто вземаме съответното ребро по 
 
 азбучен ред, при сортитания списък - подред). И така търсенето спада по ефективност, но пък паметта е задоволителна.

  Алгоритъма (на псевдоезик): 
   procedure insert(string s, trienode t) 
   is
   begin
   
   if t is null then
   t:=create_new_trienode(s[1]); -- pyrvata bukva ot tekushtata duma
   end if;
   
   s:=substr(s,2);
   
   if s= then
       t.isEnd:=true;
   else
       insert (s,t.childrens[s[1]]);
   end if;
   
   end insert ;
   


   function is_in(string s,trienode t) return боолеан
   is
   begin
   if length(s) = 1 then 
         
     if t.isEnd then
        return true; 
     else
        return false;
     end if;
   
     elsif t.children[ s[2]  ] is not null then
       
          is_in(substr(s,2),t.children[ s[2]  ]);
       
       else return false;
       
       end if;
   
   end get;

  Връзкi: 
   http://www.nist.gov/dads/HTML/trie.html  
   http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Trie/
   http://linux.thai.net/~thep/datrie/datrie.html
   http://tom.biodome.org/briandais.html
   http://www25.brinkster.com/denshade/Trie.php.html


  Виж още: 
   * suffix tree
   * suffix trie
   * Radix tree
   * Directed acyclic word graph aka DAWG
   * Ternary search tries
   * Acyclic deterministic finite automata
   * Deterministic finite automata
   * Judy array
   * Search algorithm
   * Extendible hashing
   * Absinthe tree


  Допълнителна информация: 
   * R. de la Briandais: File Searching Using Variable Length Keys. Proceedings of the Western Joint Computer Conference, 1959, pages 

295–298.

   * E. Fredkin: Trie Memory. Communications of the ACM, 3(9):490-499, Sept. 1960.
   * Donald Knuth. The Art of Computer Programming, Volume 3: Sorting and Searching, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89685-0. Section 6.3: Digital Searching, pp.492–512.





Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Trie1“.
			Категории: Структури от данни | Advanced Data Structures			
						
		