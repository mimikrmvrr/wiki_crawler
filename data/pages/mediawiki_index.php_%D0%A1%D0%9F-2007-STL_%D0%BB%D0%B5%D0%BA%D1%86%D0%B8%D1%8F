СП-2007-STL лекция  Клас “pair”   Функция “sort”   Функция “next_permutation”   Клас “string”   Класове “istringstream” и “ostringstream”   Клас “vector”   Клас “stack”   Клас “queue”   Клас “priority_queue”   Итератори   Класове “set” и “multiset”   Класове “map” и “multimap” 
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Безспорна е ползата от STL библиотеката на състезания. В тази лекция ще разгледаме някои примери и добри практики свързани с нейната употреба. Предварителните знания, които са необходими, са какво представляват templates, както и какво е STL.

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Клас “pair” 
Често в различни задачи ни се налага да дефинираме собствени структури. Така например при геометрични задачи в равнината ще ни се наложи да дефинираме:


struct point { double x, y; }; // пример 1
struct edge { int from, to, cost; }; // пример 2
struct product { string name; int amount; }; // пример 3

В случаите, в които структурата ни ще се състои от 2 полета, можем да избегнем дефинирането й като използваме pair.
Така структурата point може да бъде представена като:
pair <double, double>
Структурата name пък от своя страна като:
pair <string, amount>

Разбира се, можем да представим структурата edge като:
pair< pair<int, int>, int>
Подобно представяне обаче е неестествено и само ще ни усложни работата при писане на по-нататъшния код. Затова е препоръчително да използваме pair, само когато наистина искаме структура, състояща се от точно 2 полета.

Класът pair предоставя две член променливи с публичен достъп, съответно именувани first и second.
Пример за използване на pair е:


pair <string, int> product;
product.first = "krastavici";
product.second = 3;	
cout<<product.second<<" "<<product.first<<endl;

STL предотставя удобен начин за конструиране на pair - фукнцията make_pair. Така в горния пример можем да имаме:


pair <string, int> product = make_pair("krastavici", 3);

Важно е да се отбележи, че в pair са предефинирани операторите <, ==, >, както и операторът за присвояване =. Сравнението се извършва първо по полето first и ако стойностите в него са равни - по полето second. Т.е. ако имаме:


pair <string,int> a = make_pair("b",3);
pair <string,int> b = make_pair("a",1);
pair <string,int> c = make_pair("b",3);
pair <string,int> d = make_pair("a",2);

то изразът (b < d) && (d < a) && (a == c) ще има стойност true.

  Функция “sort” 
Функцията sort, дефинирана в библиотеката <algorithm>, е удобна за използване и по същество представлява имплементация на алгоритъма quick sort.
Параметрите, които подаваме, са указател към началото на редицата, която сортираме, и указател към елемента след края на редицата.

Пример за използване на sort:


void print(int * arr, int len)
{
	for (int i = 0 ; i < len ; i++)
		cout<<arr[i]<<' ';
	cout<<endl;
}

int main()
{
	int a[5] = { 4, 2, 4, 1, 5 };
	sort(a, a + 5);
	print(a, 5); // резултат 1, 2, 4, 4, 5
	int b[4] = { 5, 1, 2 };
	sort(b, b + 2); // резултат 1, 5, 2
	print(b, 3);
	sort(b + 1 ,b + 3);
	print(b, 3); // резултат 1, 2, 5
	return 0;
}

Знаем, че в средния случай, този алгоритъм има сложност Θ(N*log N), а в най-лошия - Θ(N2). Знаем също така,че най-лошият случай се получавам, когато елементите, които сортираме, са подредени първоначално в обратен ред. Въпреки това ние можем да очакваме sort да работи със сложност Θ(N*log N) във всеки един случай, дори когато подаваме елементи, които са подредени в обратен ред.


#define len 1000000
int a[len];

int main()
{	
	for (int i = 0; i < len; i++)
		a[i] = len - i;
	sort(a, a + len); // минава достатъчно бързо
	return 0;
}

Функцията “sort” нормално използва оператора < за да определи дали един елемент е по-малък от друг, в процеса на сортирането. Тъй като този оператор е предефиниран в класа pair, резултатът от изпълнението на следната програма ще е 1-3 2-2 3-1.


int main()
{	
	pair <int, int> a[3] = { make_pair(2, 2),
		make_pair(1, 3), make_pair(3, 1) };
	sort(a, a + 3);
	for (int i = 0 ; i < 3; i++)
		cout<<a[i].first<<'-'<<a[i].second<<' ';
	return 0;
}

Вместо да използваме естествената подредба на елементите, които сравняваме, можем и да подадем като трети параметър на sort указател към функция, която имплементира някаква наша логика за сравнение. Контрактът на тази фукнция е да връща резултат true, ако първият й аргумент е по-малък от втория. Така например, ако искаме да използваме горния пример, но елементите да са сортирани по второто поле, бихме могли да направим:


bool cmp(const pair<int, int> a, const pair<int, int> b) 
{
	return a.second != b.second ? 
		a.second - b.second < 0:
		a.first - b.first < 0;
}

int main()
{	
	pair <int, int> a[3] = { make_pair(2, 2),
		make_pair(1, 3), make_pair(3,1) };
	sort(a, a + 3, cmp);
	for (int i = 0 ; i < 3; i++)
		cout<<a[i].first<<'-'<<a[i].second<<' ';
	return 0;
}

Резултатът от горната програма ще е 3-1 2-2 1-3.

  Функция “next_permutation” 
Друга важна фукнция, дефинирана в библиотеката <algorithm>, е next_permutation.
Тя размества елементите от някаква последователност като по този начин генерира следващата пермутация, които тези елементи образуват. Като аргументи функцията приема указател към началото на последователността и указател към елемента след края на последователността.


int main()
{	
	int a[4] = { 1, 3, 2, 4 };
	next_permutation(a, a + 4);
	print(a, 4); // резултат : 1 3 4 2
	next_permutation(a, a + 2);
	print(a, 4); // резултат : 3 1 4 2
	return 0;
}

Резултатът от изпълнението на фукнцията next_permutation е булева стойност, която представлява дали има следваща пермутация в дадената последователност. Затова добра практика за генериране на всички пермутации е следната:


int b[5] = { 1, 2, 3 };
print(b, 3);
while (next_permutation(b, b + 3))
	print(b, 3);

Важно е да се отбележи, че функцията next_permutation работи коректно, когато имаме равни елементи в последователността. Например:


int a[4] = { 1,1,3,3 };
print(a,4);
while (next_permutation(a,a+4))
	print(a,4);

ще изпечата пермутациите 1133, 1313, 1331, 3113, 3131, 3311.

Аналогично на sort и в next_permutation можем да подаваме като трети аргумент сравняваща фукнция. Тя е с абсолютно същия контракт като тази в sort. Затова ще се спрем само на пример за подобно използване.


bool cmp(const pair<int, int> a, const pair<int, int> b) 
{
	return a.second != b.second ? 
		a.second - b.second < 0:
		a.first - b.first < 0;
}

int main()
{	
	pair <int, int> a[3] = { make_pair(3,1),
		make_pair(2,2), make_pair(1,3) };
	while (next_permutation(a, a + 3, cmp)) 
	{
		for (int i = 0 ; i < 3; i++)
			cout<<a[i].first<<'-'<<a[i].second<<' ';
		cout<<endl;
	}
	return 0;
}

Можем да очакваме, че N последователни извиквания на next_permutation върху една и съща последователност ще доведат до сложност Θ(N), независимо от дължината на последователността.

  Клас “string” 
Класът string, дефиниран в библиотеката <string>, е един от най-силните елементи на STL. Той предотставя удобен начин за работа със символни низове, като ни спестява много усилия.

Започваме с това, че в него са предефинирани операторите =, += и [].
Благодарение на това следният код е абсолютно коректен:


int main()
{	
	string a = "alabala";
	cout<<a<<endl;
	a += "_suffix";
	cout<<a<<endl;
	cout<<a[3]<<endl;
	return 0;
}

Важно е да се отбележи, че символите в string са индексирани от 0!

Можем да сравняваме два стринга с <, ==, >, като казваме че a < b, ако а е лексикографски преди b.

В следния пример са показани други полезни член фукнции на класа string.


int main()
{	
	string a = "alabala!!!";	
	cout<<a.empty()<<endl; 	// да се използва вместо а=""
	cout<<a.length()<<endl;  // дължината на а
	a.erase(4, 3);	 // трие три символа от а, започвайки от позиция 3
	cout<<a<<endl;	
	a.erase(5);	 // трие всички символи в а,от позиция 5 нататък
	cout<<a<<endl;
	cout<<a.find("lab")<<endl;  // връща индекса на първото срещане на "lab" в а
								// Ако няма такова - връща константата string::npos
	a.insert(4, "ala");	// вкарва низа "ala" в а на позиция 4
	cout<<a<<endl;	
	a.replace(3, 2, "ffff"); // заменя 2 символа в а, започващи от позиция 3, с низа "ffff"
	cout<<a<<endl;
	cout<<a.substr(1, 3)<<endl;	// връща подниза на а с дължина 3, започващ от позиция 1
	getline(cin, a);  // чете ред от cin
	cout<<a<<endl;
	cin>>a;	// чете дума от cin
	cout<<a<<endl;
	return 0;
}

Класът string предотставя конструктор, който създава string с определена дължина и съдържащ само даден символ.


int main()
{	
	string a(5, 'c'); 
	cout<<a<<endl; // резултатът е ccccc
	return 0;
}

Голямата функционалност и леснотата на използване прави класа string изключително полезен в състезателното програмиране.

  Класове “istringstream” и “ostringstream” 
Ще разгледаме два класа, дефинирани в <sstream>, които представляват входен поток от string и изходен поток към string.

Класът istringstream е наследник на класа istream и като такъв се държи, точно както очакваме от един входен поток. Това, което го прави различен, е наличието на конструктор, който създава потока от string.
Така например резултатът от следната програма ще е 1<>alabala<>2<>.


int main()
{	
	string a = "1 alabala 2"; 
	istringstream iss(a);
	string next;
	while (iss >> next)
		cout<<next<<"<>";
	return 0;
}

Класът ostringstream е наследник на ostream и като такъв също се държи, точно както очакваме от един изходен поток. Това, което го прави различен, е наличието на метода str, който връща като резултат string, стойността на който е конкатенацията от всички елементи, вкарани в потока по реда на тяхното вкарване.
Така например резултатът от следната програма ще е 1.2 delimiter1 1 delimiter2 43.


int main()
{		
	ostringstream oss;
	oss<<1.2<<" delimiter1 "<<true<<" delimiter2 "<<43;
	cout<<oss.str();	
	return 0;
}

  Клас “vector” 
Друг клас от STL с много широка употреба в състезателното програмиране е класът vector, дефиниран в библиотеката <vector>. Той представлява контейнер, линейна последователност с променлива дължина, в която е предефиниран операторът [], което означава че можем да достъпваме елементите на vector по същия начин, както елементите на масив.

Началната големина на вектора може да се задава в конструктора. Ако тя не е указана, то по подразбиране тя е 0.
Размерът на вектора може да бъде променян чрез член фукнциите:

clear – изчиства съдържанието на вектора, размерът става 0
resize – променя размера на вектора на приемания аргумент
push_back – приема за аргумент елемент и го слага в края на вектора. Размерът се увеличава с 1
pop_back – изстрива последния елемент (ако има такъв). Ако векторът не е празен, размерът се намалява с 1
Пример за използване на вектор:
В следната програма от cin се прочита числото n, след което се прочитат n числа и се извеждат на екрана.
Вариант 1:


int main()
{		
	int n;
	cin>>n;
	vector <int> a(n);
	for (int i = 0; i < n; i++)
		cin>>a[i];	
	for (int i = 0; i < n; i++)
		cout<<a[i]<<" ";
	return 0;
}

Вариант 2:


int main()
{		
	int n;
	cin>>n;
	vector <int> a;
	for (int i = 0; i < n; i++)
	{
		int tmp;
		cin>>tmp;
		a.push_back(tmp);
	}
	for (int i = 0; i < n; i++)
		cout<<a[i]<<" ";
	return 0;
}

По-добре е да се използва първия вариант, понеже още в самото начало ще бъде заделена необходимата памет и няма да има допълнителни заделяния при извикване на push_back, както е случая при втория вариант. (Това е така, понеже процесът по алокиране и заделяне на динамична памет е забележимо бавен, а тази операция се изпълнява всеки път, когато се промяна размера на вектора. От това програмата ни става доста по-бавна - бел. ред.)
Въобще, ако в даден момент ние знаем точния брой на елементите, които нашият вектор ще трябва да съдържа, добра практика е да използваме конструктор със задаване на този брой или да викаме метода resize, ако векторът е вече конструиран.

Фукнцията sort, която вече разгледахме, може да бъде използвана за сортиране на vector. Това става като вместо двойка указатели се подават двойка итератори.
По-нататък ще разгледаме по-подробно какво представляват итераторите, затова засега само ще дадем пример за използване на sort при vector.


int main()
{			
	const int len = 5;
	vector <int> a(len);
	for (int i = 0; i < len; i++)
		a[i] = len - i;
	for (int i = 0; i < len; i++)
		cout<<a[i]<<" "; // 5 4 3 2 1
	sort(a.begin() + 2, a.end() - 1);
	cout<<endl;
	for (int i = 0; i < len; i++)
		cout<<a[i]<<" "; // 5 4 2 3 1
	sort(a.begin(), a.end());
	cout<<endl;
	for (int i = 0; i < len; i++)
		cout<<a[i]<<" "; // 1 2 3 4 5
	return 0;
}

Сега ще разгледаме два случая, при които класът vector е много подходящ начин за представяне на данни.

Нека имаме граф с N <= 100000 върха и M <= 500000 насочени ребра, като всяко ребро има определена цена (или в общия случай наричано "тегло") – число с плаваща запетая. Добро представяне на този граф е списък на съседите. Тук няма да даваме дефиниция какво представлява това представяне, тъй като се предполага че това вече се знае.
Следният програмен фрагмент демонстрира как можем да имплементираме представяне на графа чрез списък на съседите посредством употребата на vector.
Върховете са индексирани от 0!


vector < vector < pair<int,float> > > Graph(N);
for (int i = 0; i < M; i++)
{
	int from, to;
	float cost;
	cin>>from>>to>>cost;
	Graph[from].push_back(make_pair(to, cost));
}

Друга структура, която е удобно да бъде представена с vector, е индексното дърво.
Отново няма да даваме дефиниция за структурата, а само ще разгледаме примерна имплементация чрез vektor.
В следния фрагмент индексното дърво съдържа 2H елемента и съответно има височина H + 1.
Стойностите в даден възел от дървото представляват сумата от елементите за областта, която този възел покрива.


int numOfEls = 1 << H;
vector < vector <int> > IndexTree(H + 1);
IndexTree[0].resize(numOfEls);
for (int i = 0; i < numOfEls; i++)
	cin>>IndexTree[0][i];
for (int i = 1; i <= H; i++)
{
	numOfEls = numOfEls >> 1;		
	IndexTree[i].resize(numOfEls);
	for (int j = 0; j < numOfEls; j++)
		IndexTree[i][j] = IndexTree[i - 1][2 * j] + IndexTree[i - 1][2 * j + 1];
}

Когато работим с вектор, а също и с контейнерите, които ще разгледаме по-нататък, е важно да се отбележи, че ако искаме да проверим дали даден контейнер a е празен, трябва да изполваме методите a.empty(), вместо изразът !а.size(), тъй като по контракт метода isEmpty е с константа сложност, докато метода size не е.

  Клас “stack” 
Ще разгледаме друг контейнер – класът stack, дефиниран в библиотеката <stack>. Както знаем, стекът е структура от данни, в която можем само да модифицираме елемента, стоящ на върха, и никой друг. Затова логично можем да предположим, че в stack нямаме предефиниран оператор [], понеже не можем да достъпваме произволни елементи.

Член функциите, които ще ни се наложи да употребяваме най често, са:

push - вкарва елемент на върха на стека
pop - премахва най-горния елемент от стека (ако има такъв)
top - взема най-горния елемент от стека

Важно е да разберем, че макар че vector предотставя цялата функционалност на stack, когато наистина се нуждаем от структурата от данни стек, е по-добре да използваме класа stack. Това е така, първо защото stack работи около 2 пъти по-бързо от vector, понеже не заделя големи блокове памет наведнъж, и второ защото ограничавайки функционалността само до тази, която ни е необходима, се улеснява използването и се намаля риска да допуснем имплементационна грешка.

Пример за използването на 'stack в реална задача е следния:
Нека искаме да направим обхождане в дълбочина на графа, описан в раздела за векторите. Ако реализираме това обхождане чрез рекурсия, рискуваме при определен тип граф, рекурсията да стане твърде дълбока и да се получи препълване на стека.
Затова можем да реализираме обхождането итеративно, като използваме класа stack.
(Междувпрочем, трябва да се отбележи, че всяка една рекурсивна фукнция може да бъде реализирана итеративно!)

За решаването на задачата на върха на стека ще пазим двойката:
(връх от графа, в който се намираме ; номер на следвашия съсед на този връх, който трябва да посетим)
Ще започнем обхождането на графа от върха с номер 0.


bool * viz = new bool [ N ];
for (int i = 1; i < N; i++)
	viz[i] = false;
viz[0] = true;
stack < pair <int, int> > dfs;
dfs.push(make_pair(0, 0));
while (!dfs.empty())
{
	const pair <int, int> top = dfs.top();
	dfs.pop();
	const int vertex = top.first;
	const int next = top.second;
	if (!next)
		cout<<"Coming into vertex "<<vertex<<endl;
	if (next < (int)Graph[vertex].size())
	{
		dfs.push(make_pair(vertex, next + 1));
		const int toVisit = Graph[vertex][next].first;
		if (!viz[ toVisit ])
		{
			viz [ toVisit ] = true;
			dfs.push(make_pair(toVisit,0));
		}
	}
}

  Клас “queue” 
Следващият контейнер, който ще разгледаме, е класа queue дефиниран в библиотеката <queue>.
Знаем какво представлява опашката, така че само ще споменем член фукнциите, които ще ни се наложи да използваме най-често. Това са 

push - слага елемент на края на опашката
pop - премахва първия елемент от опашката
front - взема първия елемент от опашката
Следният пример илюстрира използването на queue за обхождане в широчина на нашия граф:


bool * viz = new bool [ N ];
for (int i = 1 ; i < N ; i++)
	viz[i] = false;
viz[0] = true;
queue <int> bfs;
bfs.push(0);
while (!bfs.empty())
{
	const int vertex = bfs.front();
	cout<<"Coming to vertex "<<vertex<<endl;
	bfs.pop();
	for (int i = 0; i < (int)Graph[vertex].size(); i++)
	{
		const int toVisit = Graph[vertex][i].first;
		if (!viz[toVisit])
		{
			viz[toVisit] = true;
			bfs.push(toVisit);
		}
	}
}

  Клас “priority_queue” 
Контейнерът priority_queue е дефиниран в библиотеката <queue> (също както класът queue) и предотставя възможности за добавяне на елемент и за вземане и изтриване на "най-горния" (с най-голяма стойност) елемент.

По същество priority_queue е контейнер-адаптор – т.е. имплементацията е реализирана върху някакъв друг контейнер – по подразбиране това е vector, но може и да е някой друг.
Още по-точно имплементацията е "random access container" поддържан като пирамида.
Това гарантира сложност Θ(N*logN) при добавяне и премахване на елемент.

Пример за използване на priority_queue (числата се извеждат в низходящ ред):


int main()
{
	priority_queue<int> a;
	a.push(3);
	a.push(5);
	a.push(1);
	while (!a.empty()) 
	{
		cout<<a.top()<<endl;
		a.pop();		
	}
	return 0;
}

Разбира се, можем да сравняваме елементите в priority_queue с наша логика.
Това може да стане по следния начин:


struct cmp 
{
	bool operator() (const int &a, const int &b) const 
	{
		return a > b;
	}
};

int main()
{
	priority_queue<int, vector<int>, cmp> a;
	a.push(3);
	a.push(5);
	a.push(1);
	while (!a.empty()) 
	{
		cout<<a.top()<<endl;
		a.pop();		
	}
	return 0;
}

В горния пример числата се извеждат във възходящ ред.
cmp извършва сравнението на елементите като смисъла на връщаната bool стойност от оператора е дали елемента а е по-малък от елемента b.
С vector <int> задаваме контейнера, на който ще се базира приоритетната опашка.

Като основен недостатък на priority_queue можем да споменем липсата на функционалност за промяна на стойностите на елементите.
Т.е. ако в даден момент в приоритетната опашка имаме елементи A, B и C със стойности съответно 1, 3 и 5, не можем да сменим стойността на C от 5 на 2, и това да се отрази в опашката.

Едно възможно решение на този проблем е следното:
Когато ни се наложи смяна на стойността на даден елемент, всичко което правим е да добавим този елемент с новата му стойност в опашката. По този начин в опашката можем да получим повече от 1 запис за един и същи елемент. Когато ни се наложи да вземем най-големия елемент от опашката, първо проверяваме дали стойността му е актуална – т.е. последната добавена в опашката за този елемент. Ако не е, то премахваме този най-голям елемент и вземаме следващия.

Недостатък на горното решение е, че се увеличава необходимата памет и намалява (макар и не много съществено) производителността на приоритетната опашка.
Все пак в повечето задачи този недостатък няма да е от голямо значение и можем да си го позволим.

Пример за използване на горното решение е реализирането на алгоритъма на Дейкстра със сложност Θ(M*logN). Обръщаме внимание, че правим обхождането на елементите на вектора чрез итератори! Малко по-надолу ще разгледаме какво представляват те.


float dist[N];

struct cmp 
{
	bool operator() (const int &a,const int &b) const 
	{
		return dist[a] > dist[b];
	}
};


void deikstra()
{	
	const float MAXDIST = 1000000000.0;
	bool * viz = new bool[N];
	priority_queue<int, vector <int>, cmp> heap;
	for (int i = 1; i < N; i++)
		dist[i] = MAXDIST;
	for (int i = 0; i < N; i++)
		viz[i] = false;
	heap.push(0);
	while (!heap.empty()) 
	{
		const int vertex = heap.top();
		heap.pop();
		if ( viz[vertex] )
			continue;
		viz[vertex] = true;
		for (vector< pair<int,float> >::iterator it = Graph[vertex].begin();
			it != Graph[vertex].end(); it++)
		{
			int to = it->first;			 
			float totalCost = it->second + dist[vertex];			
			if (totalCost < dist[to])
			{
				dist[to] = totalCost;
				heap.push(to);
			}
		}
	}
}

  Итератори 
За да преминем към важните контейнери set, multiset, map и multimap, ще трябва първо да разгледаме какво представляват итераторите и как се използват.

Контейнерите се делят на два вида според това дали можем да обхождаме елементите им. От разгледаните до сега контейнери можем да обхождаме всички елементи единствено на vector, а на останалите – не.

Контейнерите, чиито елементи могат да бъдат обходени (итерирани), предотставят удобен механизъм за това – итератори.

Междувпрочем, ние вече разгледахме два примера за използване на итератори – при сортиране на vector чрез функцията sort се подават итератори. Също така при обхождане на елементите на vector чрез алгоритъма на Дейкстра също използвахме итератор.

И така, итераторите в STL представляват позиции на елементи в различни STL контейнери. Тъй като итераторите винаги са асоциирани със специфичен тип контейнер, декларирането на итератор става използвайки контейнера, към който те са асоциирани.
Пример:


vector<double>::iterator values_iter; 
vector<double>::const_iterator const_values_iter;

Итераторите се делят на два вида според това дали елементите могат да бъдат модифицирани чрез тях – константни и некостантни (съответно не даващи и даващи право да се модифицират елементите - бел. на ред.).
Итераторите се делят на три вида според това какви възможности за итериране предлагат:

Forward – възможна е итерация само в една посока, без връщане назад
Bidirectional – възможна е итерация и в двете посоки
Random access – възможна е итерация и в двете посоки със прескачане на елементи.

Следната таблица илюстрира възможностите, които предотставя всеки един от тези три типа:

 Оператор
 Описание
 Forward
 Bidirectional
 Random access
 !=, ==
 Сравнение на итератори
 да
 да
 да
 ++
 Итериране 1 позиция напред
 да
 да
 да
 --
 Итериране 1 позиция назад

 да
 да
 +=, -=, +, -
 Итериране на произволен брой


 да
Класът vector, който разгледахме по-горе, предотставя Random access итератори. Той предотставя методи begin() и end(), които връщат итератори съответно към първия елемент и края на вектора (т.е. позицията след края на вектора - бел. на ред.).

Достъпването на елемента, който "стои зад итератора" става като използваме итератора като указател към този елемент. Пример:


vector < pair <int,int> > A(3);
for (vector <pair <int,int> > :: iterator it = A.begin();
	it != A.end(); it++)
	cout<<it->first<<' '<<it->second<<endl;	

Гарантирано е, че всяка една итерация е с константна сложност, както и че итерирането на произволен брой позиции във всяка посока при Random access итераторите също е с константна сложност.

  Класове “set” и “multiset” 
Класът set, дефиниран в библиотеката <set>, представлява съвкупност от елементи, никой два от които не са равни.
Елементите са сортирани в нарастващ ред.
Структурата от данни, върху която е изграден set, е червено-черно балансирано дърво. Така имаме гаранция че добавянето, търсенето и премахването на елемент стават със сложност Θ(logN), където N e броя на елементите в set-а.
Итераторите, предотставени от set, са bidirectional.

Добавянето на елемент става чрез член функцията insert(), търсенето – чрез find() и изтриването – чрез erase().

Също както в priority_queue, можем да зададем наша логика за сравнение на елементите в set-а.

Пример за употреба на set:


struct ltstr
{
  bool operator()(const char* s1, const char* s2) const
  {
    return strcmp(s1, s2) < 0;
  }
};

void iterateOver(set<const char*, ltstr> * s)
{
	for (set<const char*, ltstr>::iterator it = s->begin();
		it != s->end(); it++)
		cout<<*it<<' ';
	cout<<endl;
}


int main()
{
	const int N = 6;
	const char* a[N] = {"isomer", "ephemeral", "prosaic", 
                      "nugatory", "artichoke", "serif"};
	set<const char*, ltstr> A(a, a + N); // конструктор с указатели към масив
	set<const char*, ltstr> B;	// конструктор по подразбиране
	iterateOver(&A);
	B.insert(a[1]);
	B.insert(a[2]);
	iterateOver(&B);
	A.erase(A.find(a[3]));
	A.erase(A.find(a[1]));
	iterateOver(&A);
	set<string> C;  // използваме нормалната подредба на string
	C.insert("bbb");
	C.insert("aaa");
	for (set<string>::iterator it = C.begin(); it != C.end(); it++)
		cout<<(string)*it<<' ';
	return 0;
}

Разликата между класовете set и multiset, е че multiset може да съдържа повече от един елемент с еднакъв ключ. Метода count() дава възможност за преброяването на елементите с даден ключ.


const int N = 10;
int a[N] = {4, 1, 1, 1, 1, 1, 0, 5, 1, 0};    
multiset<int> A(a, a + N);
cout<<A.count(1);

Често срещан проблем е следния:
Нека имаме set(или multiset) от естествени числа подредени във възходящ ред. Искаме да започнем итерация от първото число, чийто ключ е по-голям или равен на 3, но в контейнера нямаме елемент със стойност 3. Решението е да добавим елемент с ключ 3, след което да вземем итератор към него, да извършим итерацията и накрая да изтрием елемента 3, който сме добавили.


bool flag = false;
if (!A.count(3))
{
	A.insert(3);
	flag = true;
}
for (set <int>/*multiset<int>*/::iterator it = A.find(3);
	it != A.end(); it++)
		/* do something here */;
if (flag)
	A.erase(A.find(3));

  Класове “map” и “multimap” 
Класовете map и multimap, дефинирани в библиотеката <map>, дават възможност за съпоставяне между ключ и стойности. Разликата между тях е, че в map на един ключ може да бъде съпоставена най-много една стойност, докато в multimap – много.

Добавянето на елемент става чрез метода insert(), на който се подава двойката (ключ; стойност). Пример:


map/*multimap*/ <string, int> months;
months.insert(make_pair("January", 31));

В map за удобство е предефиниран оператора [], което прави достъпването на елементи възможно по следния начин:


map/*!!!не работи при multimap!!!*/ <string, int> months;
months["January"] = 31;
cout<<months["January"];

Макар този оператор да е доста удобен за използване, с него трябва да се винмава много. Проблемът идва от това, че когато по този начин правим опит за достъп на елемент, който не е част от map-а, то в map-a се добавя елемент със същия ключ и стойност по подразбиране.
Пример:


map <string, int> months;
months["January"] = 31;
cout<<months.size()<<endl;  // размерът е 1
cout<<months["invalid month"]<<endl;  // !!!! добавя елемента (invalid month; 0)
cout<<months.size()<<endl;  // размера е 2

Търсенето и изтриването на елементи става по същия начин, както в set, така и в multiset – чрез find() и erase().

Итераторите са bidirectional, като всеки итератор е указател към двойката (ключ; стойност).

Също както в set, multiset и priority_queue, може да се дефинира структура, която сравнява ключовете.
За удобство можем да използваме typedef за да избегнем многократното писане на нотацията на map.
Пример за итерация със структура за сравнение и typedef:


struct ltstr
{
  bool operator()(const char* s1, const char* s2) const
  {
    return strcmp(s1, s2) < 0;
  }
};

typedef map<const char*, int, ltstr> myMap;

int main()
{
	myMap months;
  
	months["january"] = 31;
	months["february"] = 28;
	months["march"] = 31;
	months["april"] = 30;
	months["may"] = 31;
	months["june"] = 30;
	months["july"] = 31;
	months["august"] = 31;
	months["september"] = 30;
	months["october"] = 31;
	months["november"] = 30;
	months["december"] = 31;

	for (myMap::iterator it = months.begin();
		it != months.end() ; it++)
		cout<<it->first<<' '<<it->second<<endl;
	return 0;
}






Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%A1%D0%9F-2007-STL_%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F“.
			Категории: STL | Състезателно-Програмиране-2007			
						
		