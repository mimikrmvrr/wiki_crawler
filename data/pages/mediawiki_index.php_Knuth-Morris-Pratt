Knuth-Morris-Pratt  Основна идея   Изчисляване на префиксната функция   Примерна реализация   Външни препратки 
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Първият линеен алгоритъм за търсене на един стринг в друг e разработен е от Кнут и Прат и независимо от тях от Морис през 1977 год., но е публикуван съвместно от тримата.

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Основна идея 
В основата му е наивния подход и по-скоро информацията, която той не използва... 
Например нека сравняваме P[1 … m]  с T[i … i+m], като първата позиция в която те се различават е j, т.е. P[1 … j-1] = T[i … i+j-1] = w и P[j] != T [i+j] 
Наивният подход не използва събраната информация и отмества шаблона само с една позиция надясно, което неминуемо води до несполучливи опити. 
Вместо това, при отместването KMP подравнява суфикс на w с подходящ префикс на P по следния начин:
(kartinka s w)
Нека next[j] e най-дългият префикс на P[1 …j], който е различен от него и в същото време е негов суфикс. Това е постринг на Pj, който се среща както в началото, така и в края му. 
Тогава трябва да продължим търсенето, като първите символи, които сравним, са P[next[j] + 1] и Т[i+j]. Няма нужда да проверяваме за първите next[j] символа от шаблона, защото знаем, че префиксът на P с дължина next[j] е и суфикс на Pj, който от своя страна се среща в края на прочетения до момента текст. 
За да си гарантираме, че няма да пропуснем някое срещане на P, избираме най-дългия такъв префикс; ако той не ни върши работа ( P[next[j]+1] != T[i+j] ) – втория по големина и т.н.
Тъй като всеки символ от текста сравняваме с точно един символ от шаблона, сложността на търсенето става О(n).

  Изчисляване на префиксната функция 
Първо ще отбележим, че масивът next[] не съдържа информация само за най-дългите такива суфикси на P.
Ако в next[j] съдържа дължината на най-дългия такъв префикс (border), то вторият най-дълъг можем да намерим в next [ next[j] ] (тъй като той е префикс на P с дължина е по-малка от next[j] и едновременно с това – суфикс на P с дължина по-малка от next[j], то той е едновременно префикс и суфикс на P[1 … next[j] ] и следователно дължината му е next [ next[j] ]).
Ясно е, че P1 няма суфикс, различен от него и следователно next[1] = 0. 
Нека сме изчислили всички стойности на next[k] за k = 1, 2, 3, … j-1 
За да намерим next[i], първо се опитваме да продължим досега намерения най-дълъг суфикс, който е и префикс на P, т.е. проверяваме дали P[ next[j-1]+1 ] == P[j]. Ако е така, next[j] = next[j-1]+1 
Иначе най-доброто, което можем да направим е да се опитаме да продължим втория по големина такъв суфикс, т.е. да проверим дали P [ next[next[j-1]] + 1] == P[j]. 
Ако не намерим такъв суфикс, то next[j] = 0. 
Сложността за пресмятане на префиксната функция е O(m) и така сложността на целия алгоритъм става O(n+m).

  Примерна реализация 
(Шаблонът и тектът са представени чрез 1-базираните масиви pattern и text) 


void pre ()
{
int i,j;

next[1] = 0;
j=0;

for (i=2; i<=m; i++) {
    while (j>0 && pattern[i]!=pattern[j+1])
          j = next[j];
    if (pattern[i]==pattern[j+1])
       j++;
    next[i] = j;
    }
}


void KMP ()
{
int i,j;

pre();
j=0;

for (i=1; i<=n; i++) {
    while (j>0 && text[i]!=pattern[j+1])
          j = next[j];
    if (text[i]==pattern[j+1])
       j++;
    if (j==m) printf("Shift %d\n", i-j+1);
    }
}

  Външни препратки 
 Обяснение на алгоритъма (на английски)
 Knuth-Morris-Pratt algorithm (на английски)
 Интерактивна анимация на алгоритъма

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Knuth-Morris-Pratt“.
			Категории: Алгоритми | Низове			
						
		