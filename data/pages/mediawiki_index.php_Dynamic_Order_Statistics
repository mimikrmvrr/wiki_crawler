Dynamic Order Statistics
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Въведение 
Dynamic Order Statistics е абстрактен контейнер, който е обобщение на списък. Това, което добавя като операции, са операции по индекс на елементите. В интернет не се срещат много неща за него, така че явно не е утвърден термин или пък има друг термин, който се използва вместо него (ако някой знае такъв да пише). 
D.O.S. държи елементите си в някакъв ред. Може този ред да се определя от програмиста, който използва този абстрактен тип (тогава може на него да се гледа като на обощение на списък) или да е възходящ по стойността на елементите (тогава може да се гледа като обобщение на сортиран списък, каквито са std::set и std::map). Може да се модифицира и относно това дали елементите може да се повтярят.

  Операции 
Когато абстрактният списък в който са наредени елементите, е сортиран, може да се дефинират следните операции:

 Намиране на елемент по индекс.
 Намиране на индекс по стойност на елемент (когато се допускат повторения съответно първи/последен индекс на елемент).
 Намиране на броя на елементите по-малки от даден.
 Намиране на броя на елементите, чиято стойност е в някакъв интервал (тази операция може да се реализира и чрез горната).
 Намиране на следващ/предишен елемент.
 Добавяне на елемент.
 Изтриване на елемент.
 Вземане на броя на всички елементи в контейнера.

Когато реда на елементите се контролира от програмиста който използва D.O.S. тогава могат да се дефинират следните операции:

 Намиране на елемент по индекс.
 Промяна на елемент (по даден индекс и стойност).
 Вмъкване на елемент на даден индекс.
 Изтриване на елемент от даден индекс.
 Вземане на броя на всички елементи в контейнера.
В този случай D.O.S. предлага операциите, които се предлагат от std::vector, std::deque. Особеност е обаче, че има реализации, в които всички те могат да се реализират с не по-голяма от логаритмична сложност.

  Реализации 
И двата варианта могат да се реализират с двоично дърво, на което е добавено допълнително свойство - брой на елементите в поддървото на текущия връх. Съответно всички варианти на балансирано двоично дърво също могат да се приложат. Проблем е обаче, че писането на такова изисква много време и не е много подходящо за състезания на живо.
Най-често използваната на състезания реализация на D.O.S. е Индексно дърво. Тя предлага много добър компромис между време за писане и свойства на операциите. Недостатък е, че заеманата памет и време зависи от областта (Range) на елементите, които ще се държат вътре. За това много често се прилага в комбинация със Свиване на стойностите.
Разбира се, и двата варианта могат да се реализират с обикновен масив, свързан списък, std::vector, std::dequeue или std::list. Тогава обаче, някои от операциите ще бъдат линейни.
Има и други реализации, някои от които са подходящи за състезание. Такава например е следната идея:

 Прилагаме Свиване на стойностите.
 Полученият интервал с големина N разделяме на <math>\sqrt{N}</math> блока. 
 За всяка стойност от интервала пазим броя на елементите с тази стойност.
 За всеки блок пазим броя на елементите в него.
 Можем да пазим и броя на всички елементи.
 Така можем да реализираме всички операции със сложност най-много <math>O(\sqrt{N})</math>.
 Работи за сортирания вариант.
Горната реализация може да се направи и на 3 нива, при което се постига сложност <math>O(\sqrt[3]{N})</math>. Всъщност, ако я направим на неограничен брой нива, се получава точно Индексно дърво.

  Ресурси 
 Реализация на D.O.S. с Червено-черно дърво е описана в MIT Introduction to Algorithms. Ако някой я има под ръка, моля да уточни този ресурс.

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Dynamic_Order_Statistics“.
			Категории: Структури от данни | Advanced Data Structures			
						
		