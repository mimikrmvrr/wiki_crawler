Двоично търсене
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Въведение 
Двоичното търсене е един широко известен метод, но за много хора неговото приложение се ограничава само до търсене на число в сортиран масив. Въпреки че този алгоритъм изглежда относително прост, той може за реши на пръв поглед изключително сложни задачи с голяма ефективност.
Ситуациите, в които се прилага може са много разнообразни, но във всички случаи принипът е един и същ. Сега да се опитаме да обобщим алгоритъма за двоичното търсене и да го дефинираме малко по-формално. Ще дефинираме две функции Search(L,R) и Compare(M), като М = (L+R)/2. Функция Search(L,R) търси елемент в интервала [L,R] от дадено наредено множество. При L=R резултатът е L, иначе резултатът е Search(L,M), ако функция Compare(M) е положителна, или Search(M+1,R) в противен случай. Сега да разгледаме три задачи, които могат да се решат ефективно чрез двоично търсене.

  Задача Dwarfs 
Първата задача е Dwarfs от CEOI 2002. Преразказано накратко условието е: Имаме N <math>(N \le 100 000)</math> точки в равнината, и М <math>(M \le 100 000)</math> прави. За всяка права трябва да определим дали е „Добра“(т.е. не разделя точките на две части) или „Лоша“(т.е. разделя точките). С други думи достатачно е за всяка права да проверим дали същетсвува поне по една точка във всяка от полуравнините определени от правата.
Въпросът е как да направим това достатъчно ефективно. Нека да дефинираме ориентирано разстояние от точка до права, като дължината на перпендикуляра спуснат от точката до правата, със знак плюс ако е в едната полуравнина и със знак минус ако е в другата. Ако една точка има по-малко ориентирано разстояние до права от друга точка, то ще я наричаме по-близка и съответно ако има по-голямо ориентирано разстояние до правата ще я наричаме по-далечна. Ако съществува поне една точка с положително ориентирано разстояние до права, то най-далечната също ще има такова. Аналогично ако съществува поне една точка с отрицателно ориентирано разстояение до права, то най-близката също ще има такова. Т.е. сведохме задачата за определяне на една права като „Добра“ или „Лоша“ до намиране на най-далечната и най-близката точка до нея и сравняване на знаците им.
Тъй като най-далечната и най-близката точка задължително лежат на изпъкналата обвивка(която можем да намерим за <math>O(N \log N)</math> време), можем да направим двоично търсене и да намерим двете точки за <math>O(\log K)</math> време и след това да ги сравним (K е броя на точките в обвивката). Като повторим това за всяка права в крайна сметка ще получим алгоритъм със сложност <math>O(N \log N + M \log K)</math>, което е достатъчно бързо за конкретната задача. Сега как да направим двоично търсене? Номерирали сме точките от обвивката с числата от 1 до K. Има два случая:
Първият случай(Фиг. 1) е точките първо да се отдалечават от правата докато се стигне до най-далечната т. Max, после да започнат  да се приближават докато се стигне до най-близката т. Min и пак да започнат да се увеличават до достигане на точка K(1<=Max<=Min<=K).

Фиг. 1
Вторият случай(Фиг. 2) е точките първо да се приближават от правата докато се стигне до най-близката т. Min), после да започнат да се отдалечават докато се стигне най-далечната т. Max) и пак да започнат да се приближават до достигане на точка К(1<=Min<=Max<=K).

Фиг. 2
Ще опишем намирането на най-близката точка до правата, a намирането на най-далечната става аналогично. Нека означим с d1 ориентираното разстояние от т. М до правата, с d2 ориентираното разстояние от т. М+1 и с d ориентираното разстояние от т. 1. Най-близката точка е резултатът от фукцията Search(1,N), като функцията Compare(M) е дефинирана по следния начин в зависимост от случая.
В първия случай, aко d1>d2(т.е. точките се приближават), то Compare(M) = 1. Ако d1<d2, то трябва да сравним d1 и d. Ако d1>d,  то Compare(M) = 1, иначе Compare(M) = -1.
Във втория случай, ако d1<d2(т.е. точките се отдалечават), то Compare(M) = -1. Ако d1>d2 и d1<d, то Compare(M) = 1, а ако d1>d2 и d1>d, то Compare(M) = -1.

  Задача Rods 
Втората задача е Rods от IOI 2002. Преразказано накратко условието изглежда така: В квадратна матрица от N*N (N<=10 000) квадратчета има две прави, една хоризонтална и една вертикална. Те може да се  пресичат или не. Права е последователност от поне две хоризонтално или вертикално разположени квадратчета от матрицата. Не е известно как са разположени правите и задачата е да се определи с най-много до 100 питания(за максимален брой точки). Чрез едно питане можем да разберем дали в зададен от нас правоъгълник има клетка участваща в някоя от правите.
Първо да се опитаме да намерим най-малкия правоъгълник, в който се вписват и двете прави или с други думи контура. Лявата граница на този контур е K-та колона, когато K е такова, че първите K-1 колони не съдържат част от права, а първите K колони съдържат такава. K може да се намери чрез двоично търсене K = Search(1,N), като Compare(M) = 1, ако в правоъгълника образуван от първите М колони има част от права и Compare(M) = -1, ако няма такава. Аналогично можем да намерим дяснат, горната и долната граница на контура с общо четири двоични търсения.
Сега може да проверим дали клетките в четирите ъгъла на контура са част от права с четири директни проверки. Забележете, че няма начин само един или и четирите ъгъла да са запълнени, тъй като има само една вертикална и една хоризонтлна права. Остава да разгледаме четири случая.
Първо, може да не е запълнен нито един ъгъл(фиг. 3). Тъй като знаем началото и края(лявата и дясната граница на контура) на хоризонталната отсечка, чрез едно двоично търсене можем да определим на каква височина се намира тя. Аналогично се прави и с вертикалнaта.
 
Фиг. 3 и Фиг. 4
Второ, може да са запълнени два несъседни ъгъла(фиг. 4). Тогава с една дирекна проверка можем да проверим от кой от двата ъгъла започва хоризонталната отсечка, като проверим дали е запълнена клетка X, която е вътрешна за обвивката и стой непосредсвено до един от ъглите. Ако тя е запълнена следва, че хоризонталнaтa права започва от този ъгъл, в противен случай следва, че другата т. X e запълнена и хоризонталната права започва от другия ъгъл. След това с две двоични търсения можем да определим двете прави.
Трето, може да са запълнени два съседни ъгъла(фиг. 5). Тогава знаем коя права покрива и двата ъгъла в зависимост дали те са хоризонтално или вертикално разположени и с две двоични търсения отркиваме другата.
 
Фиг. 5 и Фиг. 6
И последно, може да са запълнени три от ъглите(фиг. 6). Тогава с една директна проверка в т. X(ако едната е пълна, другата е празна) можем да проверим коя от двете прави(хоризонталната или вертикалната) покрива два от ъглите. След това знаеки началото(третия ъгъл) на другата права можем да я определим с едно двоично търсене.
Така в най-лошият случай имаме шест двоични търсения и пет проверки на отделни клетки. Всяко двоично търсене е най-много log2(10 000) = 14 запитвания. Или в крайна сметка имаме 6*14+5=89 питания, което ни усигурява максимален брой точки.

  Задача SQRI 
Друг вид приложение на двоичното търсене е широко изпозвана техника, който аз лично наричам “двоично търсене по отговора”. Понякога, когато се изисква да се изчисли нещо, директното му изчисление може да се окаже непосилна задача. Но ако има някаква наредба на решенията и съществува достатъчно ефективен начин да се определи дали фиксирано число е решение можем да приложим двоично търсене.
Добра илюстрация на този метод е задача SQRI от Втори(Регионален) кръг на НОИ. Накратко условието е: Дадено е едно положително цяло число A до 50 цифри и се търси цялата част на квадратния му корен. В повечето езици за програмиране няма тип, който да побира 50 цифрено число и затова се налага съзтезателят сам да имплементира тип “дълги числа”.
Тривиалният подход е да се напише функция за пресмятане на корен квадратен на дълги числа и да се отреже дробната част. Но намирането на квадратен корен, както и работата с дробни дълги числа не е никак лесно за времето на едно съзтезание. Нека погледнам задача под друг ъгъл. Търси се най-голямото цяло число B, чийто квадрат не надвишава A.
Тъй като имаме наредба на елементите(ако квадрата на едно цяло положително число C е по-малко от A, то квадрата на всяко друго положително число по-малко от C също е по-малко от A) можем да приложим двоично търсене. Достатъчно ни е да имплементираме функция за повдигане на квадрат на тип “дълги числа” със сложност O(D2), където D е броя на цифрите на числото. Това е значително по-лесно от коренуването. Резултатът B = Search(1,A), като Compare(M) = 1, ако M2 е по-малко на A и Compare(M) = -1, в противен случай.
В крайна сметка получaваме алгоритъм със сложност O(log(А)*D2), което в най-лошият случай е равно на log(1050)*502 = 417500 операции, което е се изпълнява без проблем за даденото време.

  Връзки 
 http://en.wikipedia.org/wiki/Binary_search
 http://www.nist.gov/dads/HTML/binarySearch.html
  Ресурси 
 Тренировки на националния отбор 2003-2005г. с огромната подкрепа на Велин Цанов.

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE_%D1%82%D1%8A%D1%80%D1%81%D0%B5%D0%BD%D0%B5“.
			Категория: Алгоритми			
						
		