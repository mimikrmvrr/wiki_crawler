АС-Quick sort
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Анализ на алгоритъма:
The quick sort е In-Place, divide-and-conquer, рекурсивен метод за сортиране. Нормален човек би казал че това е In-Place версия на merge sort. Quick sort е лесен за разбиране, но много труден за написване
Рекурсивният алгоритъм се състои от 4 стъпки(много напомнят merge sort):

Ако има един или по-малко елементи за сортиране, прекрати сортирането
Избери си елемент, който да ти служи за отправна точка (pivot point)
Сортирай масива на две части - едната с елементи по-големи от отправния, другата със по-малките
Рекурсивно повтори алгоритъма за двете половини на масива
Ефективността на алгоритъма зависи главно от това кой елемент е избран първоначално. Най-лошият случай, когато ефективността е <math>O(n^2)</math>, е когато за отправен елемент е избран left-most(демек най-малкия бел.ред.) елементът. Ако отправната точка се избере случайно, quick sort има сложност <math>O(n\log n)</math>
Pros: Многмногмного бърз
Cons: много сложен алгоритъм; изпозва множествена рекурсияЕмперичен анализ:

Може да се каже, че quick sort е най-бързия често използван алгоритъм за сортиране. Възможно е да се напише някакъв специален алгоритъм, който да е по-бърз за сортиране на определен тип данни, но в общия случай няма по-бърз от quick sort.
След като учениците забележат това, те започват да използват quick sort за всичко. По-добре обаче е да не се използва само той - не винаги е най-добрият избор. Както беше споменато по-рано той използва множествена рекурсия (това означава че при големи сортирания, може много бързо да свърши стек-паметта на компютъра). Освен това quick sort е прекалено сложен за да се напише за сортиране на масив с 25 елемента например.
В крайна сметка в повечето случаи quick sort е най-добрият избор ако се търси най-бърз алгоритъм(но не винаги). Използвайте го ако сортирате средни по големина списъци или ако не сте много сигурни какво да използвате. Quick sort е ужасно неефективен когато се използва за сортиране на почти сортирани списъци - избягвайте този случай.
Примерен код:


void quickSort(int numbers[], int array_size)
{
  q_sort(numbers, 0, array_size - 1);
}


void q_sort(int numbers[], int left, int right)
{
  int pivot, l_hold, r_hold;

  l_hold = left;
  r_hold = right;
  pivot = numbers[left];
  while (left < right)
  {
    while ((numbers[right] >= pivot) && (left < right))
      right--;
    if (left != right)
    {
      numbers[left] = numbers[right];
      left++;
    }
    while ((numbers[left] <= pivot) && (left < right))
      left++;
    if (left != right)
    {
      numbers[right] = numbers[left];
      right--;
    }
  }
  numbers[left] = pivot;
  pivot = left;
  left = l_hold;
  right = r_hold;
  if (left < pivot)
    q_sort(numbers, left, pivot-1);
  if (right > pivot)
    q_sort(numbers, pivot+1, right);
}

Както се вижда от сорса все пак този алгоритъм не е чак толкова сложен и не мога да се съглася с автора, че е невъзможно да бъде написан(бел. ред)





Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%90%D0%A1-Quick_sort“.
			Категории: Алгоритми | Сортиране			
						
		