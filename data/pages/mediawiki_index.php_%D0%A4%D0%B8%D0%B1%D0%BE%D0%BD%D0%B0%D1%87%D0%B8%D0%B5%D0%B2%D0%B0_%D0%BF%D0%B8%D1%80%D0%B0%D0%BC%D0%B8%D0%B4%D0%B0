Фибоначиева пирамида
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Фибоначиевата пирамида е абстрактна структура данни, подобна на обикновената пирамида (двоична пирамида) и биномната пирамида, но с по-ниски асимптотични оценки на операциите. Това позволява някои алгоритми (например алгоритъма на Дийкстра за най-къс път в граф и алгоритъма на Прим за минимално обхващащо дърво) да се реализират с по-ниска сложност.

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   История 
Фибоначиевата пирамида е измислена от Майкъл Фредман и Робърт Тарджан през 1984-та година и публикувана през 1987-ма. Името на структурата произлиза от числата на Фибоначи, които са използвани при асимптотичния анализ на сложностите на операциите.

  Сложности 
Фибоначиевата пирамида позволява всички стандартни за пирамидите операции със следните сложности:

Операция
Амортизирана сложност
create_heap
Θ(1)
insert
Θ(1)
query_minimum
Θ(1)
union
Θ(1)
decrease_key
Θ(1)
extract_minimum
Θ(log n)
delete
Θ(log n)
Ако даден алгоритъм започне от празна пирамида и изпълни a операции от групата insert, query_minimum, decrease_key и union, както и b операции от групата extract_minimum и delete, то сложността на алгоритъма ще бъде O(a + b log n). При биномна пирамида, сложността би била O((a + b) log n). Следователно, Фибоначиевата пирамида е за предпочитане пред биномната в ситуации, в които a надвишава значително b.
На практика, обаче, Фибоначиевата пирамида е тежка и трудна за имплементиране структура. За едно сравнение, погледнете Емпирични резултати

  Структура на Фибоначиевата пирамида 
Файл:Fibonacci heap-bg.png
Фибоначиевата пирамида е списък от дървета. Самите дървета са произволни като структура (сравн. с Биномна пирамида), но изпълняват условието за пирамида (всеки връх е не по-голям от наследниците си). Минимумът на цялата пирамида се намира в корена на някое от дърветата, като е необходимо да се поддържа указател към него. Структурата на фибоначиевата пирамида е доста гъвкава и това позволява някои от операциите да се изпълняват "мързеливо" - пирамидата се оставя в "разхвърлен" вид и подреждането и се отлага за по-късно. Например, две пирамиди се обединеняват като се свържат двата списъка дъвета, а операцията decrease_key, когато е необходимо, се реализира, като се отреже върха (поддървото) от бащата и се сложи като ново дърво в пирамидата.
За да може да се изпълнят обещаните сложности, по някое време в пирамидата все пак се въвежда някакъв ред. В частност, степените на дърветата (степен = броя на наследниците) се поддържат ниски - те са максимум Θ(log n); големината на поддърво с корен от степен k е поне Fk+2 (където Fk е k-тото число на Фибоначи). Това се осигурява чрез следното правило - може да отрежем най-много един наследник на всеки връх, различен от корен. Ако трябва да се премахне втори наследник, самият връх също се отрязва от родителя си и става корен на ново дърво. Освен това, броят на дърветата намаля при операцията extract_min, при която част от дърветата закачат едно за друго.
Структурата сякаш е "замислена" за амортизационен анализ. Някои операции (може да) отнемат много време, докато другите приключват бързо. В амортизационния анализ приемаме, че бързите операции всъщност отнемат повече време, отколкото в действителност. Това допълнително време после вадим от бавните операции. Времето, запазено за "изразходване" се измерва с функция на потенциала, която, за Фибоначиевата пирамида е 
Потенциал := t + 2m
където t е броя дървета в пирамидата, а m е броя маркирани върхове (връх е маркиран, ако някой от неговите наследници е бил отрязан отпреди последното закачане на върха към друго дърво (корените не са маркирани)).
Така, корените на всяко дърво в пирамидата държат по една единица време. Тази единица може в последствие да се ползва за свързване на дървото с някое друго, с амортизирана сложност 0. Освен това, всеки маркиран връх има две единици време. Едната от тях може да се ползва за да се отреже върха от родителя. Ако това се случи, новия връх става корен на дърво, и оставащата единица се запазва в него.

  Реализиране на операциите 
Основната структура, използвана за помнене на списъка от дървета, както и за наследниците на всеки връх е цикличен, двойносвързан списък. За всеки връх помним дали е маркиран, както и броя на наследниците (степента). Глобално пазим и указател към дървото с минималната стойност.

  Минимален елемент (find min) 
Тривиална, тъй като пазим указател към него. Потенциалът не се променя - сложността (реална и амортизирана) е Θ(1)

  Обединение на пирамиди (union) 
Тривиална, свързваме двойносвързаните списъци, представящи дърветата на двете пирамиди. Потенциалът не се променя - сложността (реална и амортизирана) е Θ(1)

  Добавяне на елемент (insert) 
Елемента се добавя като ново дърво с единствен елемент. Потенциалът се покачва с 1, тъй като броя дървета нараства с 1. Следователно амортизираната сложност е Θ(1)

  Премахване на минималния елемент (extract_min) 
Файл:Fibonacci heap-extract min-bg.png
Операцията протича в три етапа. В първия взимаме корена, съдържащ минималния елемент и го премахваме. Наследниците му стават корени на нови дървета. Ако броят наследници на минималния корен е бил d, разглеждането на новите корени отнема Θ(d) и потенциалът нараства с d-1. Следователно амортизираната сложност на тази стъпка е Θ(d) = Θ(log n). Фигура 2 отразява това. Първо, единицата се премахва. След което върховете 3 и 6 се свързват, а в последствие закачат за дървото с корен 2.
За да приключим extract_min(), трябва да обновим указателя към минималния корен. Тук може да имаме не повече от n корена, които трябва да разгледаме. Във втората фаза ще се опитаме да намалим броя на дърветата, като последователно обединяваме дървета с еднаква степен. Когато намерим две дървета u и v с еднаква степен, правим едното наследник на другото, като това с по-малка стойност остава в корена. Неговата степен ще нарастне с единица. Този процес се повтаря докато всеки корен има различна степен. За да намираме дървета с еднаква степен ефективно, може да ползваме масив с големина O(log n), в който държим указател до един корен от всяка степен. Когато намером втори корен със същата степен, двете се обединяват (като отбелязваме това в масива). Действителната сложност на втората фаза е (ако m е броят дървета в началото й): O(log n + m). Накрая ще имаме най-много O(log n) дървета (всяко с различна степен). Следователно потенциалът ще намалее с поне m - O(log n) и амортизираното време става O(log n).
В третата фаза (Фиг. 2 вдясно) разглеждаме всички останали дървета за да намерим новия глобален минимум. Това отнема O(log n) време и не променя потенциала. Общата сложност на extract_min е, следователно, O(log n).

  Намаляне на даден елемент (decrease_key) 
Файл:Fibonacci heap-decreasekey-bg.png
Намалянето на елемент (връх в някое дърво) може въобще да не промени пирамидата. Ще разгледаме, обаче, интересния случай, в който пирамидалното свойство се нарушава и намаленият връх става по-малък от родителя си. Решението е просто да откъснем върха и да го направим корен на ново дърво в пирамидата, като същевременно маркираме родителя му (но само ако родителят не е корен на дърво). Ако върха, подлежащ на маркиране вече е маркиран, то откъсваме и него от дървото и маркираме неговия родител и т.н. - процесът продължава нагоре по дървото докато не достигнем или корен, или немаркиран връх. В резултат се получават, да речем, k нови дървета. Всяко от тях (евентуално с изключение на първото) са били маркирани, но тъй като в последстве стават корени на дървета, се размаркират. Така, потенциалът намаля с поне k-2. Времето, необходимо за рязането е O(k), следователно амортизираната сложност на операцията decrease_key е константна.

  Изтриване на елемент 
Прави се, като елемента се намали до минус безкрайност, след което се прави extract_min. Амортизирана сложност - O(log n).

  Подробности по реализацията 
Естественият вид за представяне на върховете на дърветата, спрямо дефинициите, е да се използва динамичната памет. Това, обаче, значително вдига константата на тази и без това тромава структура. Едно по-ефикасно решение е да взаимстваме подхода за реализиране на двоичната пирамида, при който елементите се пазят плътно в обикновен масив, а връзките са не чрез указатели, а чрез номера на клетките в масива. Необходимо е да се установи политика за следните ситуации: 

 Препълване на масива. Може да се взаимства подхода на std::vector или просто да се ползва vector. Ако се знае предварително максималния брой елементи в пирамидата, може и да се ползва обикновен масив;
 Изтриване на елемент. При изтриването, в масива остава дупка, която трябва да се запълни, в противен случай структурата ще се пази в повече от O(n) памет. Едно решение на проблема е, при изтриване на елемент да се прави релокация на някой друг елемент (обикновено, крайният в масива) на мястото на изтрития. Необходимо е да се оправят и връзките на съседите на релокирания връх, така, че вече да сочат на новото му място.
  Емпирични резултати 
Тук са представени резултатите при изпълнение на алгоритъма на Дийкстра върху графи с различни размери. Тествана е една и съща реализация на самата Дийкстра, като е различна само конкретната реализация на пирамидата. Сравнението е между STL-ската пирамида (priority_queue<T, vector<T>, greater<T> >, което е реализирано в SGI STL с двоична пирамида), реализация на Фибоначиева пирамида, реализирана без динамична памет (по метода, описан в подробности по реализацията) и реализация на 2-3 Heap. Сорс-кодът може да бъде намерен във връзки. Компилаторът е gcc 3.3, машината е 1.0 GHz Athlon64.

Брой върхове
Брой ребра
Време - STL пирамида
Време - Фибоначиева пирамида
Време - 2-3 пирамида
100
9937
0.010s
0.010s
0.010s
500
234672
0.320s
0.313s
0.313s
1500
97752
0.143s
0.150s
0.150s
5000
298144
0.460s
0.483s
0.480s
Необходимо е да се отбележи, че Фибоначиевата и 2-3 пирамидата са леко ощетени в това сравнение, тъй като не е имплементирана операцията decrease_key(). Така, фибоначиевата пирамида реално не сваля сложността и разчита единствено на бързината на insert(), за да неутрализира тромавостта на extract_min(). Както се вижда, константите са такива, че комбинацията от Θ(log n) + Θ(log n) за двоичната пирамида не е по-бавно от Θ(log n) + Θ(1) за фибоначиевата.

  Използвана литература 
 Fredman M. L. & Tarjan R. E. (1987). Fibonacci heaps and their uses in improved network optimization algorithms. Journal of the ACM 34(3), 596-615.
 Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Второ издание. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Глава 20: Фибоначиеви пирамиди, pp.476–497.

  Връзки 
 Java аплет, който симулира фибоначиевата пирамида във визуален вид
 Имплементация на Фибоначиева пирамида (всички операции), написана на C
 Сорс-кода, използван за сравнението горе може да се изтегли от SVN-то на OpenFmi.net чрез следната команда svn co https://svn.openfmi.net/dijkstraheap или да се разгледа онлайн тук

Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D0%B8%D0%B5%D0%B2%D0%B0_%D0%BF%D0%B8%D1%80%D0%B0%D0%BC%D0%B8%D0%B4%D0%B0“.
			Категории: Структури от данни | Advanced Data Structures			
						
		