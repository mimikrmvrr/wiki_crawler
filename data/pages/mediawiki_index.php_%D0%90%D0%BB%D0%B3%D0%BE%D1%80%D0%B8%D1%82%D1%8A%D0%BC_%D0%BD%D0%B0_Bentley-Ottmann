Алгоритъм на Bentley-Ottmann
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Алгоритъм на Bentley-Ottmann за намиране на пресечните точки на множество от отсечки.

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }  Преглед
За вход алгоритъма на Bentley-Ottmann приема множество О = {Li} от отсечки Li и изкарва като резултат множество А = {Ij} от пресечни точки. Този алгоритъм се нарича алгоритъм на плъзгащата се линия(sweep line algorithm), защото неговото действие може да се визуализира като една “плъзгаща” се линия SL върху множеството от отсечки О и събиращо информация минавайки през индивидуалните отсечки Li. Информацията, която се събирра от SL, е общо казано нареден списък от всички отсечки в О, които са пресечени в даден момент от SL. Структурата която поддържа тази информация се нарича “плъзгаща линия” (sweep line). Начина по който се намират пресечните точки е съцето на алгоритъма и ефективността му.

 Идея
За да имплементираме алгоритъма първо трябва да подредим елементите на О за да определим последователността в която SL ще ги обхожда. Всъщност трябва да подредим само краищата {Ei1, Ei2} на отсечките Li, за да можем да определим кога SL започва и спира да пресича дадена отсечка. Обикновенно краищата се подреждат по нарастващи x и после нарастващи y кординати. При такава подредба SL е вертикална и се движи от ляво надясно, както е показано на диаграмата:

SL следи сегментите като:

	Добавя отсечка когато нейния ляв край е достигнат.
	Издтрива отсечка, когато нейния десен край е достигнат
SL поддържа отсечките в ред, подчинен на релацията “горен-долен”. Т.е за да бъде добавена или извадена дадена отсечка, нейната позиция трябва да бъде определена, т.е. в най-лошия случай може да бъде извършено със сложност O(logn) двоично търсене от текущите отсечки в SL. Но настрани от добавянето и изваждането на отсечки към структурата, има и друго нещо което променя нейното състояние, а именно когато две текущи отсечки се пресекат, тогава техните позиции в подредбата се сменят. Имайки две отсечки, които трябва да са съседи в подредбата, този размяна може да бъде осъществена за O(logn) сложност.

 Опашка на събитията
	За да можем да осъществим това, ще въведем подредена “опашка на събитията” EQ, чиито елементи предизвикват промяна в структурата на SL. Отначало EQ е списък от подредените краища на отсечките. Когато пресичане на отсечки е намерено, то също се добавят към списъка със събитията, като се поддържа подредбата. Трябва да се прави и проверка дали не се добавят повтарящи се събития. На диаграмата е показано как това може да се случи. При събитие 2, отсечките s1 и s2 се пресичат в точката I12, което се добавя в опашката. След това при събитие 3 s3 застава между s1 и s2. След това при събитие 4, s1 и s2 си разменят местата в SL и s1 става съсед отново на s2, което кара I12 бъде пресметнато отново. Но всяко събитие трябва да присъства само веднъж, затова когато пресечна точка бива добавена в опашката, трябва да проверим дали вече няма такова събитие. Тъй като има най-много една пресечна точка за всеки две отсечки, маркирайки пресечните точки с някакъв идентификатор е достатъчно да ги различаваме. В резултат на това максималния размер на опашката на събитията EQ е 2n + k <= 2n + n2 и добавяне в нея може да бъде направено с най-много О(log(2n + n2)) = O(logn) двоично търсене.

 Идея на Реализацията
	Да видим какво общо има всичко това с ефективното намиране на пресечни точки. Тъй като отсечките последователно се обновяват в SL списъка, техните възможни пресечни точки с други отсечки се определя. Когато валидна пресечна точка е намерена, тогава тя се добавя в събитийната опашка. Освен това когато събитието “пресичане на две отсечки” се обработва, това предизвиква пренареждане на SL списъка и също бива добавено към списъка A на резултата. Накрая, когато всички събития бъдат обработени, A ще съдържа всички пресечни точки.

 Пресичане на отсечки
	Но има едно съществено нещо, което е сърцето на алгоритъма, а именно "как се определя кога се пресичат отсечки?". Очевидно две отсечки могат да се пресекат само ако се появят по едно и също време в списъка на SL. Но това само по себе си не може да направи алгоритъма ефективен. Важното съображение което трябва да се направи е, че за да могат да се пресекат две отсечки, те трябва да бъдат непосредствени съседи в списъка на SL. Забелязвайки това, вече можем да заключим, че има само няколко случая при които могат да възникнат пресичания на отсечки:

	Когато отсечка се добави с списъка на SL, се проверява дали може да се пресече с отсечките под и над нея в подредбата
	Когато сегмент бъде изтрит от списъка, неговите съседи стават нови съседи. Затова трябва да се проверят за пресичане.
	При събитие “пресечна точка на две отсечки” двете отсечки се разменят и трябва да се проверят дали се пресичат с новите си съседи.
	Това означава, че за да се обработи всяко едно събитие (край или пресичане), има най-много 2 проверки за пресичане трябва да бъдат направени. Един детайл остава, а именно времето необходимо за добавяне, махане, размяна и намиране на отсечки в SL структурата. За това можем да използваме балансирано двоично дърво(като AVL, 2-3, или червено-черни дървета), което гарантира, че тези операции отнемат най-много O(logn) време, кадето n е максималния размер на SL. Тогава за всяка от (2n+k) операциите ще е необходимо O(logn) сложност. Или в крайна сметка ефективността на алгоритъма е O((n+k)logn)

 Псевдокод

Инициализираме събитийната опашка EQ с краищата на отсечките;
Сортираме Oпо нарастващи x и y;
Инициализираме “плъзгащата линия” SL да е празна;
Инициализираме резултатното множество от пресечни точки A да е празно;

While (EQ не е празно) {
	Нека E = следващото събитие в EQ;
	If (E ляв край) {
		Нека segE = отсечката на E;
		Добавяме segE към SL;
		Нека segA = отсечката над segE в SL;
            	Нека segB = отсечката под segE в SL;
		If (I = (Пресечната на segE със segA) съществува) 
                		Добавяме I към EQ;
		If (I = (Пресечната на segE със segB) съществува) 
                		Добавяме I към EQ;
        } Else If (E е десен край) {
		Нека segE = отсечката на E;
		Нека segA = отсечката над segE в SL;
            	Нека segB = отсечката под segE в SL;
		Махаме segE от SL;
		If (I = (Пресечната на segA със segB) съществува) 
                		If (I не е вече в EQ) Добяме I към EQ;
	} Else {  // E е събитие на пресичане
		Добавяме E към резултатния списък A;
		Нека segE1 и segE2 са отсечките които се пресичат в Е;
		Разменяме техните позиции, така че segE2 е вече над segE1;
		Нека segA = отсечката над segE2 в SL;
		Нека segB = отсечката под segE1 в SL;
		If (I = (Пресечната на segE2 със segA) съществува)
			If (I не е вече в EQ) Добавяме I към EQ;
		If (I = (Пресечната на segE1 със segB) съществува)
			If (I не е вече в EQ) Добавяме I към EQ;
        }
        Махаме E от EQ;
    }
   
return L;


 Реализация
Line Segment Intersection

 Приложения
 Разделяне на не-прости многоъгълници на прости части
За да разделим един не-прост многоъгълник на прости части, трябва да намерим всички пресечни точки. За целта можем да използваме например Алгоритъм на Bentley-Ottmann.
Можем да подходим по следния начин:

 Намираме пресечните точки на страните на многоъгълника
 За всяка пресечна точка, добавяме нови 2 точки V1 = V2 = пресечната точка и разделяме пресичащите се отсечки Е1 и Е2 на 2 части: съответно Е1 на Е1,in -> E1,out (които се свързват в точката V1) и E2 na E2,in -> E2out (които се свързват в точката V2)
 Извършим малко "рязане" по новите отсечки, за да премахнем покриването. Това се прави като:
 свързваме Е1,in с E2out в точката V1.
 свързваме Е2,in с E1out в точката V2.
 След като повторим тези операции за всяка пресечна точка, получаваме искания резултат.

Имайте в предвид че резултатните многоъгълници могат да се съдържат един в друг.

 Операции с множества от многоъгълници
Алгоритъма може да бъде използван за ускорение на намирането на сечение, обединение, разлика на прости многоъгълници.
Ако многоъгълниците са изпъкнали, то броя на техните пресечни точки е най-много 2, което прави алгоритъма на Bentley-Ottmann ефективен. Съществува по-проста имлементация обаче за намриане на сечението на такива многоъгълници, а именно като се използва алгоритъм на намиране дали дадена точка е в изпъкнал многоъгълник с двоично търсене.





Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D1%8A%D0%BC_%D0%BD%D0%B0_Bentley-Ottmann“.
			Категории: Алгоритми | Геометрия			
						
		