АС-Radix sort
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			Анализ на алгоритъма:
Radix sort е алгоритъм, който може да се използва за сортиране на елементи във лексикографски ред. Елементите могат да са символни низове или числа. Сортирането на елементите започва съобразно с цифрата, която има най-малко значение за големината на числто(пр. най-лявата, която показва бораят на единиците) и продължава през по-значещите цифри(тези за десетици, стотици и т.н.)
Този тип алгоритъм има сложност O(nk), където n е броя на сортираните елементи, a k е средният борй на техните цифри.
Radix sort е възникнал като алтернатива на други алгоритми за сортиране с голямо бързодействие(като heap sort и merge sort), които имат сложност <math>O(n\log n)</math>. Тези алгоритми имат по-голяма сложност, но могат да сортират елементите по методи, по-различни от лексикографския.
Този алгоритъм разпределя елементите на групи спрямо стойността на най-дясната тяхна цифра(най-малко значещата лексикографски). Във всяка група елементите са подредени във първоначалния ред. Броя на групите е еднакъв с броя на стойностите, които може да приема всяка цифра. След това този процес се повтаря на всяка съседна цифра, която има по-голямо лексикографско значение, докато не останат повече цифри.

 Вземи най-малко значешата цифра на всеки елемент
 Групирай елементите спрямо стойността на тази цифра, като запазиш реда им по групи
 Повтори този процес със по-значещите цифри
Подреждането в стъпка 2 обикновено се прави чрез bucket sort или counting sort които са ефективни в случая ако има малко елементи за сравнение.
Съществува и друга вариация на този алгоритъм за сортиране, която сравнява елементите първо по тяхната най-значеща цифра и след това преминава към по-малко значещите.
Пример:
Несортираният списък:

554
153
088
523
235
След първоначално сортиране (по най-дясната цифра):

153
523
554
235
088
След следващо сортиране (втората цифра от ляво на дясно):

523
235
153
554
088
След трето сортиране (третата цифра от ляво на дясно):

088
153
235
523
554
Може да ви се струва, че след всяка стъпка масива тотално се разбърква, но важното е, че на всяка стъпка се запазва относителното положение на равните елементи спрямо критерия на съответната стъпка(бел. ред.).
Примерен код:


#include <iostream.h>
#include <stdlib.h>
#include <string.h>

void radix (int byte, long N, long *source, long *dest)
{
  long count[256];
  long index[256];
  memset (count, 0, sizeof (count));
  for ( int i=0; i<N; i++ ) count[((source[i])>>(byte*8))&0xff]++;

  index[0]=0;
  for ( i=1; i<256; i++ ) index[i]=index[i-1]+count[i-1];
  for ( i=0; i<N; i++ ) dest[index[((source[i])>>(byte*8))&0xff]++] = source[i];
}

void radixsort (long *source, long *temp, long N)
{
  radix (0, N, source, temp);
  radix (1, N, temp, source);
  radix (2, N, source, temp);
  radix (3, N, temp, source);
}

void make_random (long *data, long N)
{
  for ( int i=0; i<N; i++ ) data[i]=rand()|(rand()<<16);
}

long data[100];
long temp[100];

void main (void)
{
 make_random(data, 100);
 radixsort (data, temp, 100);
 for ( int i=0; i<100; i++ ) cout << data[i] << '\n';
}






Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/%D0%90%D0%A1-Radix_sort“.
			Категории: Алгоритми | Сортиране			
						
		