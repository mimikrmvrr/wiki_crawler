STL Алгоритми
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			1.Защо са ни тези мъдри писания? – Защото с тях се пише по-разбрано и освен това реализациите на доста от алгоритмите се пишат доста по-бързо.
2.Масиви, низове и всякакви други контейнери са сложени под общите “област” или
“последователност”.
3.Последователностите( областите ) в семантиката са описани по начина.
“име на пром. + начало” и “име на пром. + край”.
Пример:  
Int A[100];
Sort(A,A+100);
В горния пример “А” ни е все едно “А+0”.
Бележка към редактора:Май ще трябва в началото да напишем как да си дефинират функционални обекти и функции за сравнения.

 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }   Джвъчки 
  min 
Връща по-малката от две стойности.
Пример:
const int x = min(3, 9);
assert(x == 3);

Семантика:
Min(име на пром1.(да не е масив), име на пром2.(да не е масив));
Сложност:Константна.

  max 
Същото като min, само че връща по-голямата стойност.Семантиката и сложността са същите.

  swap 
Разменя стойностите на две променливи.
Пример:
int x = 1;
int y = 2;
assert(x == 1 && y == 2);
swap(x, y);
assert(x == 2 && y == 1);

Семантика:
Swap( име на пром1., име на пром2. );

Сложност:Константна.
Употреба:Къде ли не.

  Търсене в несортирани последователности 
  find 
Функцията Find намира първото срещане на определена последователност или на 1 елемент в дадена последователност (string в string или число в масив) и връща итератор(от същия тип като стойността на търсеното) към началото на последователността или към самия елемент.
Пример:
vector <int> A;
A.push_back(1);
A.push_back(2);
A.push_back(3);
int i;
i=find(a.begin(),a.end(),2);

Семантика:
find(име на пром. + началото на последователността , име на пром. + края + 1, стойност или име на променлива  който търсим);
Сложност: Линейна.
Употреба:Когато искаме да търсим низ в друг низ , и не ни трябва КМП или когато търсим елемент в масив.

  find_if 
Същото като горното, само с разликата че намира елемента, който отговаря на даден критерии за сравнение.
Критерия за сравнение се осъществява с функционален обект ( предикат ).
Пример за обект:


class GreaterThan
{
public:
      GreaterThan (int nn) : m_n(nn) {}
      bool operator() (int cmp) { return cmp > m_n; }
private:
      int m_n;
};

Този предикат сравнява елемента подаден му със предварително зададен елемент, като връща истина (true), ако подадения елемент е по-голям от предварително зададения
Например за даден вектор v функцията find_if (v.begin(), v.end(), GreaterThan(5)); връща итератор към първия елемент, който е по-голям от 5. Характерното при предикатите е, че трябва да имат operator(), който да се вика от алгоритъма. Има и разни подробности, че трябва копията на предиката да са еквивалентни, но това са редки случаи ;)
Има разни готови предикати в STL като equal_to, greater и т.н.
Семантика:
find_if(име на пром.+начало , име на пром. + края + 1, функц. обект);
Сложност:Линейна.

  find_first_of 
Наподобява find, но за разлика от него търси за всеки един от елементите в последователността, която се подава за търсене.
Пример:


	int main()
	{
		const char* WS = "\t\n ";
		const int n_WS = strlen(WS);
		
		char* s1 = "This sentence contains five words.";
		char* s2 = "OneWord";
	
		char* end1 = find_first_of(s1, s1 + strlen(s1), WS, WS + n_WS); 
		char* end2 = find_first_of(s2, s2 + strlen(s2), WS, WS + n_WS); 
		printf("First word of s1: %.*s\n", end1 - s1, s1); 
		printf("First word of s2: %.*s\n", end2 - s2, s2); 
	}

Семантика:
Find_first_of(име на пром1. + начало, име на пром1. + край, име на пром2. + начало, име на пром2. + край);
Сложност:края на пром1*края на пром2.
Употреба:Намиране на шпация, нов ред, табулация, точки, запетайки и тн. в низ.

  count 
Намира броя на срещанията на определен елемент в дадена последователност.Връща броя на срещания.
Пример:
int main() {

 int A[] = { 2, 0, 4, 6, 0, 3, 1, -7 };
 const int N = sizeof(A) / sizeof(int);

 cout << "Number of zeros: " 
      << count(A, A + N, 0)
      << endl;

}

Семантика: 
Count(име на пром. + начало, име на пром. + край, пром. или стойнот чиито брой търсим, (елемент , който добавяме броя));
Бележка: Отсега нататък ще отбелязваме със скоби параметрите на функцията, които не са задължителни.
Сложност:Линейна.

  min_element 
Намира минималния елемент в дадена последователност.
Пример:
int main()
{

 list<int> L;
 generate_n(front_inserter(L), 1000, rand);
 
 list<int>::const_iterator it = min_element(L.begin(), L.end());
 cout << "The smallest element is " << *it << endl;

}
Семантика:
Min_element(име на пром. + начало, име на пром. + край);
Сложност:Линейна.

  max_element 
Същото като min_element, само че намира най-големия елемент. Семантиката и сложността са същите.

  lexicographical_compare 
Проверява коя от двете подадени области е по-голяма в лексикографски( азбучен ) ред.Връща true, ако първата област е по-голяма и false, ако втората е по-голяма.
Пример:
int main()
{

 int A1[] = {3, 1, 4, 1, 5, 9, 3};
 int A2[] = {3, 1, 4, 2, 8, 5, 7};
 int A3[] = {1, 2, 3, 4};
 int A4[] = {1, 2, 3, 4, 5};

 const int N1 = sizeof(A1) / sizeof(int);
 const int N2 = sizeof(A2) / sizeof(int);
 const int N3 = sizeof(A3) / sizeof(int);
 const int N4 = sizeof(A4) / sizeof(int);

 bool C12 = lexicographical_compare(A1, A1 + N1, A2, A2 + N2);
 bool C34 = lexicographical_compare(A3, A3 + N3, A4, A4 + N4);

 cout << "A1[] < A2[]: " << (C12 ? "true" : "false") << endl;
 cout << "A3[] < A4[]: " << (C34 ? "true" : "false") << endl;

}

Семантика:
Lexicographical_compare(име на пром1. + начало, име на пром1. + край, име на пром2. + начало, име на пром2. + край);
Сложност:Линейна.

  mismatch 
Намира първото несъответствие между елементите на две последователности.Връща елемент от тип Pair.Ако няма несъответствие връша first да е първия итератор и second да е първият2 + (последният1 - първият1).Първата последователност трябва да е с по-малка големина, защото тя е определяща каква част от втората ще бъде сравнена.
Пример:
int A1[] = { 3, 1, 4, 1, 5, 9, 3 };
int A2[] = { 3, 1, 4, 2, 8, 5, 7 };
const int N = sizeof(A1) / sizeof(int);
pair<int*, int*> result = mismatch(A1, A1 + N, A2);
cout << "The first mismatch is in position " << result.first - A1 << endl;
cout << "Values are: " << *(result.first) << ", " << *(result.second) << endl;
Семантика:
Mismatch(име на пром1. + начало, име на пром1. + край , име на пром2. + началото, (Предикат));

Сложност:Линейна.

  equal 
Определя дали две области съвпадат.Изискванията са подобно на mismatch.Връща true, ако съвпадат и false, ако ли не. 
Пример:
int A1[] = { 3, 1, 4, 1, 5, 9, 3 };
int A2[] = { 3, 1, 4, 2, 8, 5, 7 };
const int N = sizeof(A1) / sizeof(int);
cout << "Result of comparison: " << equal(A1, A1 + N, A2) << endl;

Семантика:
Подобна на mismatch.

Сложност:Линейна.

  search 
Търси подпоследователност в дадена последователност.Връща итератор към началото на първата подпоследователност или ако няма такава връща итератора на последния елемент на първия параметър.
Пример:

 const char S1[] = "Hello, world!";
 const char S2[] = "world";
 const int N1 = sizeof(S1) - 1;
 const int N2 = sizeof(S2) - 1;

 const char* p = search(S1, S1 + N1, S2, S2 + N2);
 printf("Found subsequence \"%s\" at character %d of sequence \"%s\".\n",
        S2, p - S1, S1);


Семантика:
Search(име на пром1. + началото, име на пром1. + края, име на пром2. + началото, име на пром2. + края)

Сложност:Квадратична.

Употреба:Върши огромна работа при операции с низове.

  find_end 
Същото като search, само че намира последата подпоследователност и връща итератор към началото и.Семантика, сложност и употреба са същите като при search.

  Промяна на последователности 
  swap_ranges 
Разменя елементите в цели последователности.Първата последователност подадена на функцията трябва да е по-малка, защото тя определя големината на разменящите се елементи.
Пример:
vector<int> V1, V2;
V1.push_back(1);
V1.push_back(2);
V2.push_back(3);
V2.push_back(4);
assert(V1[0] == 1 && V1[1] == 2 && V2[0] == 3 && V2[1] == 4);
swap_ranges(V1.begin(), V1.end(), V2.begin());
assert(V1[0] == 3 && V1[1] == 4 && V2[0] == 1 && V2[1] == 2)

Семантика:
Swap_ranges( име на пром1. + начало, име на пром1. + край, име на пром2. + начало )

Сложност:Линейна.

Употреба:При реализация на MergeSort и при низове.

  replace 
Заменя всеки елемент в последователността, който е еднакъв на подадената стойност или елемент.
Пример:
vector<int> V;
V.push_back(1);
V.push_back(2);
V.push_back(3);
V.push_back(1);
replace(V.begin(), V.end(), 1, 99);
assert(V[0] == 99 && V[3] == 99);

Семантика:
Replace( име на пром1. + начало, име на пром1. + края, променлива която ще заменяме, променлива която ще заменя );

Сложност:Линейна.

Употреба:Щирока употреба в низовете и в някои задачи за масиви.

  replace_if 
Същото като replace, но има и предикат, който определя при какво условие да се заменят.
Пример:
vector<int> V;
V.push_back(1);
V.push_back(-3);
V.push_back(2);
V.push_back(-1);
replace_if(V.begin(), V.end(), bind2nd(less<int>(), 0), -1);
assert(V[1] == 0 && V[3] == 0);
Семантика:
Replace_if( име на пром1. + начало, име на пром1. + края,  предикат, променлива която ще заменя );

Сложност:Линейна.
Употреба:Като на replace.

  fill 
Запълва последователност с някаква стойност.
Пример:
vector<double> V(4);
fill(V.begin(), V.end(), 137);
assert(V[0] == 137 && V[1] == 137 && V[2] == 137 && V[3] == 137);

Семантика:
Fill(име на пром1. + начало, име на пром1. + край, стойност);

Сложност:Линейна.

  fill_n 
Запълва с някаква стойност първите N елемента от началото на последователността.
Пример:
vector<double> V;
fill_n(back_inserter(V), 4, 137);
assert(V.size() == 4 && V[0] == 42 && V[1] == 42 && V[2] == 42 && V[3] == 42);

Семантика:
Fill_N( име на пром1. + начало, N, стойност);
Сложност:Линейна.

  generate 
Гeнерира елементите в последователността, по някакъв функционален обект за генериране на цисла ( най-добре да се ползва стандартната за C++, функция rand() ).
Пример:
vector<int> V;
...
generate(V.begin(), V.end(), rand);

Семантика:
Generate( име на пром. + начало, име на пром. + край, функц. обект );
Сложност:Линейна.
Употреба:Ми ако правите алчен алгоритъм може да свърши работа или ако си генерирате някакъв вход.

  generate_n 
Генерира N на брой числа в последователността.
Пример:
Да се напише.
Семантика:
Generate_N( име на пром. + край, N, функционален обект);
Сложност: Линейна.
Употреба: Като на Generate.

  remove 
Премахва елементите в последователността равни на подадения елемент.
Пример:
vector<int> V;
V.push_back(3);
V.push_back(1);
V.push_back(4);
V.push_back(1);
V.push_back(5);
V.push_back(9);
copy(V.begin(), V.end(), ostream_iterator<int>(cout, " "));

   // The output is "3 1 4 1 5 9".

vector<int>::iterator new_end = remove(V.begin(), V.end(), 1);
copy(V.begin(), new_end, ostream_iterator<int>(cout, " "));

   // The output is "3 4 5 9".


Семантика:
Remove(име на пром. + на4ало, име на пром. + край, елемент който да премахваме);

Сложност:Линейна.
Употреба:Низове и масиви.

  remove_if 
Като Remove, но премахва елементите, ако изпълняват някакво условие (предикат).
Пример:


vector<int> V;
V.push_back(1);
V.push_back(4);
V.push_back(2);
V.push_back(8);
V.push_back(5);
V.push_back(7);

copy(V.begin(), V.end(), ostream_iterator<int>(cout, " "));
    // The output is "1 4 2 8 5 7"

vector<int>::iterator new_end = 
        remove_if(V.begin(), V.end(), 
                  compose1(bind2nd(equal_to<int>(), 0),
                           bind2nd(modulus<int>(), 2)));
V.erase(new_end, V.end()); [1]

copy(V.begin(), V.end(), ostream_iterator<int>(cout, " "));
    // The output is "1 5 7".

Семантика:
Replace_if( име на пром. + начало, име на пром. + край, предикат );
Сложност:Линейна.
Употреба:Като replace.

  unique 
unique е особен алгоритъм - той НЕ премахва повтарящите се елементи. В действителност контейнера може да е масив и от него не може да се трие. Ето какво прави
Ако в подадената му редица има последвателни повтарящи се елементи, от тях остава само първия, а другите се преместват в края на редицата. Това означава, че ако подадената редица е сортирана, в началото й ще останат само уникалните елементи, а в края ще бъдат премесестени повторенията. unique връща указател към новия края на уникалната редица - т.е. мястото, което разделя уникалните от повтарящите се елементи.
Пример:
vector<int> V;
V.push_back(1);
V.push_back(3);
V.push_back(3);
V.push_back(3);
V.push_back(2);
V.push_back(2);
V.push_back(1);
vector<int>::iterator new_end = unique(V.begin(), V.end());
copy(V.begin(), new_end, ostream_iterator<int>(cout, " "));

   // The output is "1 3 2 1".

Семантика:
unique( име на пром. + начало, име на пром1. +  край );
Сложност:Линейна.

Употреба:Извиквате ге след sort и получавате всички различни елементи за време O(NlogN).

  reverse 
Обръща областта огледално спрямо средата и.
Пример:
vector<int> V;
V.push_back(0);
V.push_back(1);
V.push_back(2);
copy(V.begin(), V.end(), ostream_iterator<int>(cout, " "));

               // Output: 0 1 2

reverse(V.begin(), V.end());
copy(V.begin(), V.end(), ostream_iterator<int>(cout, " "));

// Output: 2 1 0

Семантика:
Reverse( име на пром. + начало, име на пром. + край );
Сложност:Линейна.

  rotate 
Завърта наляво елементите в дадена областта.Избира се един елемент, който да иде наляво и той става първи в областта, елемента след него става втори , а елементите се “залепят” след посления елемент.
Пример:
char alpha[] = "abcdefghijklmnopqrstuvwxyz";
rotate(alpha, alpha + 13, alpha + 26);
printf("%s\n", alpha);
// The output is nopqrstuvwxyzabcdefghijklm

Семантика:
Rotate( име на пром. + начало, име на пром. + елементо който искаме да въртим, име на пром. + край );

Сложност:Линейна.

  random_shuffle 
Размества по произволен начин елементите в областта.
Пример:
const int N = 8;
int A[] = {1, 2, 3, 4, 5, 6, 7, 8};
random_shuffle(A, A + N);
copy(A, A + N, ostream_iterator<int>(cout, " "));
// The printed result might be 7 1 6 3 2 5 4 8, 
//  or any of 40,319 other possibilities.

Семантика:
Random_shuffle( име на пром. + начало, име на пром. + край );

Сложност:Линейна.

  sort 
Сортира елементите от областта по някакъв критерий.Може да дефинира функция за сравнение ( трябва да е от тип bool).
Пример:
Bool CMP(int &i,int &j)
{
if(i>j) return 1;//Разменя елементит 
else return 0;}//Иначе не ги разменя
.....
sort(A,A+N,CMP);
Семантика:
Sort( име на пром. + начало, име на пром. + край, функция );

Сложност: O(n log n)

  stable_sort 
Абсолютно същото като sort.Само дето бачка по друг алгоритъм.
Пример:
	int masiv[100];

	int N;
	cin>>N;
	int i;
	for(i=1;i<=N;i++)
	{
		cin>>masiv[i];
	}
	stable_sort(masiv+1,masiv+N+1);

Семантика:Като на Sort.

Сложност:Като на Sort.

  Сортирани Последователности 
  is_sorted 
Проверява дали областта е сортирана.Връща true, ако е сортирана и false, ако не е.Може да ползвате самостоятелна функция за сравнение.
Пример:
int A[] = {1, 4, 2, 8, 5, 7};
const int N = sizeof(A) / sizeof(int);
assert(!is_sorted(A, A + N));
sort(A, A + N);
assert(is_sorted(A, A + N));

Семантина:
Is_sorted( име на пром. + начало, име на пром. + край, функция за сравнение );

Сложност:Линейна.

  lower_bound 
Намира първия елемент в дадена сортирана последователност, който има стойност по-малка от зададената.

Пример:
int main()
{

 int A[] = { 1, 2, 3, 3, 3, 5, 8 };
 const int N = sizeof(A) / sizeof(int);

 for (int i = 1; i <= 10; ++i) {
   int* p = lower_bound(A, A + N, i);
   cout << "Searching for " << i << ".  ";
   cout << "Result: index = " << p - A << ", ";
   if (p != A + N)
     cout << "A[" << p - A << "] == " << *p << endl;
   else
     cout << "which is off-the-end." << endl;
 }

}

Семантика:
Lower_bound( име на пром. + начало, име на пром. + край, стойност която търсим, функция за сравнение );

Сложност:Логаритмична.

Употреба:Ако трябва да пазим нещо в сортиран вид.

  upper_bound 
Същото като lower_bound, но намира по-голямата стойност не по-малката.

  equal_range 
Двоично търсене,което намира последователността равна на даден елемент, в някаква определена сортирана последователност.Връща тип pair , като first е равно на итератора, от който започва последователността, а second е равно на итератора, в който завършва последователността.
Пример:
int main()
{

 int A[] = { 1, 2, 3, 3, 3, 5, 8 };
 const int N = sizeof(A) / sizeof(int);

 for (int i = 2; i <= 4; ++i) {
   pair<int*, int*> result = equal_range(A, A + N, i);

   cout << endl;
   cout << "Searching for " << i << endl;
   cout << "  First position where " << i << " could be inserted: "
        << result.first - A << endl;
   cout << "  Last position where " << i << " could be inserted: "
        << result.second - A << endl;
   if (result.first < A + N)
     cout << "  *result.first = " << *result.first << endl;
   if (result.second < A + N)
     cout << "  *result.second = " << *result.second << endl;
 }

}

Семантика:
Equal_ranges( име на пром. + начало, име на пром. + край, стойност която ще търсим, функция за сравнение );

Сложност:Логаритмична.

  binary_search 
Двоично търсене, което проверява дали елемента е в сортираната последователност.
Връща true, ако го има и false, ако го няма.
Пример:
int main()
{

 int A[] = { 1, 2, 3, 3, 3, 5, 8 };
 const int N = sizeof(A) / sizeof(int);

 for (int i = 1; i <= 10; ++i) {
   cout << "Searching for " << i << ": "
        << (binary_search(A, A + N, i) ? "present" : "not present") << endl;
 }

}

Семантика:
Bin_search( име на пром. + начало, име на пром. +  край, стойност която търсим, функция за сравнение );

Сложност:Логаритмична.

  merge 
Слива две наредени последователности, запазвайки резултата в наредена
трета.Критерия за сравнение може да се промени с функция за сравнение.
Последователността, в която се пази резултата се подава като 5 параметър на функцията.
Пример:
int main()
{

 int A1[] = { 1, 3, 5, 7 };
 int A2[] = { 2, 4, 6, 8 };
 const int N1 = sizeof(A1) / sizeof(int);
 const int N2 = sizeof(A2) / sizeof(int);

 merge(A1, A1 + N1, A2, A2 + N2, 
       ostream_iterator<int>(cout, " "));
 // The output is "1 2 3 4 5 6 7 8"

}

Семантика:
Merge( име на пром1. + начало, име на пром1. + край, име на пром2. + начало, име на пром2. + край, име на пром.3, функция за сравнение );

Сложност:Линейна.

Употреба:При писане на Mergesort .И при доста други алгоритми. 

  includes 
Определя дали дадена сортирана последователност съдържа елементите на друга
сортирана такава.
Пример:
int A1[] = { 1, 2, 3, 4, 5, 6, 7 };
int A2[] = { 1, 4, 7 };
int A3[] = { 2, 7, 9 };
int A4[] = { 1, 1, 2, 3, 5, 8, 13, 21 };
int A5[] = { 1, 2, 13, 13 };
int A6[] = { 1, 1, 3, 21 };
const int N1 = sizeof(A1) / sizeof(int);
const int N2 = sizeof(A2) / sizeof(int);
const int N3 = sizeof(A3) / sizeof(int);
const int N4 = sizeof(A4) / sizeof(int);
const int N5 = sizeof(A5) / sizeof(int);
const int N6 = sizeof(A6) / sizeof(int);
cout << "A2 contained in A1: " 

    << (includes(A1, A1 + N1, A2, A2 + N2) ? "true" : "false") << endl;

cout << "A3 contained in A1: " 

    << (includes(A1, A1 + N2, A3, A3 + N3) ? "true" : "false") << endl;

cout << "A5 contained in A4: " 

    << (includes(A4, A4 + N4, A5, A5 + N5) ? "true" : "false") << endl;

cout << "A6 contained in A4: " 

    << (includes(A4, A4 + N4, A6, A6 + N6) ? "true" : "false") << endl;

The output is: 
A2 contained in A1: true
A3 contained in A1: false
A5 contained in A4: false
A6 contained in A4: true
Семантика:
Includes(име на пром1. + начало, име на пром1. + край, име на пром2. + начало, име на пром2. + край, функция за сравнение);
Сложност:Линейна.

  За двоична пирамида 
Следващите алгоритми рядко се използват пряко, тъй като за двоична пирамида обикновенно се използва адаптера priority_queue.

  make_heap 
Създава пирамида по дадеда последователност.Създаването може да бъде по някаква функция за сравнение.
Пример:
int main()
{

 int A[] = {1, 4, 2, 8, 5, 7};
 const int N = sizeof(A) / sizeof(int);

 make_heap(A, A+N);
 copy(A, A+N, ostream_iterator<int>(cout, " "));
 cout << endl;

 sort_heap(A, A+N);
 copy(A, A+N, ostream_iterator<int>(cout, " "));
 cout << endl;

}

Семантика:
Make_heap(име на пром. + начало, име на пром. + край, фунция за сравнение);

Сложност:Линейна.
Употреба:Пирамидата е много бърза стуктура от данни, защото операциите добавяна и премахване са с логаритмична сложност.

  push_heap 
Добавя елемент към пирамидата.Но добавения елемент трябва вече да е в последователността, тоест като извикаме функцията и тя прибавя към дадената пирамида, елементите който са след последния елемент, съдържащ се в  нея.
Пример:
int main()
{

 int A[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

 make_heap(A, A + 9);
 cout << "[A, A + 9)  = ";
 copy(A, A + 9, ostream_iterator<int>(cout, " "));
 
 push_heap(A, A + 10);
 cout << endl << "[A, A + 10) = ";
 copy(A, A + 10, ostream_iterator<int>(cout, " "));
 cout << endl;

}

Семантика:
Push_heap( име на пром. + начало, име на пром. + край (обезателно итератор след последния елемент на пирамидата), функция за сравнение );
Сложност:Логаритмична.

  pop_heap 
Премахва най-големия по някакъв критерий елемент в пирамида.
Пример:
int main()
{

 int A[] = {1, 2, 3, 4, 5, 6};
 const int N = sizeof(A) / sizeof(int);

 make_heap(A, A+N);
 cout << "Before pop: ";
 copy(A, A+N, ostream_iterator<int>(cout, " "));

 pop_heap(A, A+N);
 cout << endl << "After pop: ";
 copy(A, A+N-1, ostream_iterator<int>(cout, " "));
 cout << endl << "A[N-1] = " << A[N-1] << endl;

}
Семантика:
Pop_heap(име на пром. + начало, име на пром. + край, функция за сравнение);
Сложност:Логаритмична.

  sort_heap 
Сортира пирамида по даден критерий(ТОВА НЕ Е ПИРАМИДАЛНО СОРТИРАНЕ!).
Пример:
int main()
{

 int A[] = {1, 4, 2, 8, 5, 7};
 const int N = sizeof(A) / sizeof(int);

 make_heap(A, A+N);
 copy(A, A+N, ostream_iterator<int>(cout, " "));
 cout << endl;

 sort_heap(A, A+N);
 copy(A, A+N, ostream_iterator<int>(cout, " "));
 cout << endl;

}

Семантика:
Sort_heap(име на пром. + начало, име на пром. + край, функция за сравнение);

Сложност:Логаритмична*Линейна.

  is_heap 
Проверява дали дадена последователност е пирамида.Връща true, ако е и false, ако не е.
Пример:
int A[] = {1, 2, 3, 4, 5, 6, 7};
const int N = sizeof(A) / sizeof(int);
assert(!is_heap(A, A+N));
make_heap(A, A+N);
assert(is_heap(A, A+N));

Семантика:
Is_heap(име на пром. +  начало, име на пром. + край);

Сложност:Линейна.

  Пермутации 
  next_permutation 
Генерира следващата лексикографска пермутация на подадената област ( генерира е в същата област ).
Пример:
template <class BidirectionalIterator> 
void snail_sort(BidirectionalIterator first, BidirectionalIterator last)
{

 while (next_permutation(first, last)) {}

}
int main()
{

 int A[] = {8, 3, 6, 1, 2, 5, 7, 4};
 const int N = sizeof(A) / sizeof(int);

 snail_sort(A, A+N);
 copy(A, A+N, ostream_iterator<int>(cout, "\n"));

}

Семантика:
next_permutation(име на пром. + начало, име на пром. +  край);
Сложност:Линейна.

  prev_permutation 
Същото като next_permutation, само че генерира предишната лексикографска пермутация.





Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/STL_%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8“.
			Категории: Алгоритми | STL			
						
		