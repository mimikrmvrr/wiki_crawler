Tiered Vector
			от Съзтезателно програмиране
			
									Направо към: навигация, търсене			
			 if (window.showTocToggle) { var tocShowText = "показване"; var tocHideText = "скриване"; showTocToggle(); }  Въведение
Tiered Vector е динамичен последователен списък с елементи, който може да се разширява или свива. Когато броят на елементите във вектора стане по-голям или много по-малък от заделената памет, нова памет се заделя и елементите се пренареждат. На всеки елемент се дава индекс или ранг, който показва броят на елементите преди дадения във вектора. На рангът може да се гледа и като на текущия адрес на елемента. Всеки ранг се дава последователно, тоест няма дупки между тях. Въпреки това може да се добавя или изтрива елемент върху съществуващ ранг. Тези операции изискват всички елементи от ранг r+1, ..., n да се преместят на ляво или дясно, взависимост от операцията.
При реализация на стандартен вектор използваме масив S. За да намериме елемент от ранг r от този вектор, просто връщаме елемента на мястото S[r]. Това е константно време. Въпреки това, добавянето и триенето на елемент могат да отнемат O(n) време в най-лошия случай когато работиме с елемент с ранг 0, тъй като се налага елементите от 1 до n да бъдат преместени. При Tiered Vector връщането на елемент отново е с константно време, а добавянето и триенето са с амортизирана сложност от O(sqrt (N)).

 Реализация
Tiered Vector поддържа следните операции:

 void Insert (int E, int R) // Добавя елемент E във вектора на място R
 void Delete (int R) // Изтрива елементът на място R
 int Search (int R) // Връща стойност на елементът от място R
 int FindK (int K) // Връща стойност на K-тия елемент в вектора
Tiered Vector е съставен от L двойно-свързани индексни списъци, добавянето в началото и в края на които е константно - структурата deque. Всеки списък съдържа по L елемента, затова максималният брой елементи, които вектора може да съдържа преди разширяване е <math>L^2</math>. Имайки N елемента, S ги разделя във [N/L] дека, като S[0] съдържа елементите с ранг 0,...,L-1, S[1] съдържа елементите с ранг L,...,2L-1 и т.н.


class TieredVector
{
public:
	TieredVector ();
	~TieredVector () {};

	void Insert (int, int);
	void Delete (int);
	int Search (int);
	int FindK (int);

private:
	deque<int>* theVector;
	int L; // number of deques
	int N; // number of elements
	int K; // L = 2^K

	void Expand ();
	void Contract ();
};

 Връщане на елемент
При търсене на елемент в Tiered Vector, първо трябва да определим в кой дек се намира той, като сметнеме [N/L]. След това смятаме мястото на елемента в дадения дек, чрез N mod L. Препоръчително е броя на дековете да е <math>2^k</math>, което ще позволи шифтване на битове за по-бързо намиране кой дек съдържа елементът с ранг r. Това би станало с операцията N >> k. Използвайки побитови операции вместо делене би намалило броят на операциите за връщане на елемент от Tiered Vector до 2, доближавайки времето за достъп до това на нормален вектор-масив.


int TieredVector::Search (int Rank)
{
	if (Rank >= N) return -1;

	int dequeRank = Rank >> K;
	int rankAtDeque = Rank & (L-1);

	deque<int>::iterator i = theVector[dequeRank].begin () + rankAtDeque;
	return (*i);
}

 Добавяне на елемент с ранг r
Добавянето на елемент в Tiered Vector цели да намали броя на операциите до O(L). Първата стъпка е да се намери дека и мястото в дека, където трябва да се добави елемента с ранг r. Тъй като броя на дековете е степен на 2, лесно се показва, че търсеният дек е с индекс r >> k, където L = <math>2^k</math>. Мястото в дадения дек се определя от младшите k бита на числото r (изпълняваме r % L). Това става лесно чрез операцията r & (L-1), което е еквивалентно на r % L. След като сме намерили точното място, където трябва да добавиме нашия елемент, проверяваме дали текущия дек е пълен. Ако е пълен трябва да преместиме последния елемент от него, на първо място в следващия дек. Проверяваме дали следващия дек е препълнен и прилагаме същата операция докато всички декове са максимално с L елемента. Вече сме освободили място в дека за елемент с ранг r и го добавяме на неговото място.


void TieredVector::Insert (int Element, int Rank)
{
	if (Rank > N || Rank < 0) return;
	if (N == L*L) Expand ();

	int dequeRank = Rank >> K;
	int rankAtDeque = Rank & (L-1);

	if (theVector[dequeRank].size () == L)
	{
		int nextDeque = dequeRank;
		do
		{
			theVector [nextDeque+1].push_front (theVector [nextDeque].back ());
			theVector [nextDeque].pop_back ();

			nextDeque++;
		} while (theVector[nextDeque].size () > L);
	}

	theVector[dequeRank].insert (theVector[dequeRank].begin() + rankAtDeque, Element);
	N++;
}

 Изтриване на елемент с ранг r
Изтриването на елемент става аналогично на добавянето. Тъй като не трябва да има дупки между ранговете, след изтриване на елемент трябва да върнеме елемент от следващия дек в текущия, разбира се ако с следващия има елементи. Прилагаме операцията докато всички декове са пълни освен последния ("оплътняваме дупките във вектора").


void TieredVector::Delete (int Rank)
{
	if (Rank > N || Rank < 0) return;
	if (N == L*L / 8) Contract ();

	int dequeRank = Rank >> K;
	int rankAtDeque = Rank & (L-1);

	theVector[dequeRank].erase (theVector[dequeRank].begin () + rankAtDeque);

	int nextDeque = dequeRank + 1;

	while (nextDeque < L && theVector[nextDeque].size () != 0)
	{
		theVector[nextDeque-1].push_back (theVector[nextDeque].front ());
		theVector[nextDeque].pop_front ();

		nextDeque++;
	}
	N--;
}

 Намиране на K-тия по големина елемент във вектора
Намирането на K-тия по големина елемент се извършва на принципа 'разделяй и владей' или по-конкретно чрез частен случай на quicksort. Започваме изпълняването на quicksort със граница K-тия елемент. След излизане от вътрешния while цикъл, i > j, а всички елементи след i са >= от K-тия и всички елементи преди j са <= от K-тия. Тук трябва да разгледаме взаймното положение на индексите k, i, j. При j < k, трябва да продължиме алгоритъма като за нова лява граница използваме i. При i > k, за нова дясна граница изплозваме j. В третия случай, k e между i и j и алгоритъма се прекратява, тъй като сме намерили K-тия най-голям елемент.


int TieredVector::FindK (int _K)
{
	if (_K >= N) return -1;

	int Left = 0;
	int Right = N-1;

	while (Left < Right)
	{
		int i = Left;
		int j = Right;

		int X = Search (_K);

		while (i <= j)
		{
			while (X > theVector[i >> K][i & (L - 1)]) i++;
			while (X < theVector[j >> K][j & (L - 1)]) j--;

			if (i > j)
				break;

			Swap (theVector[i >> K][i & (L - 1)], theVector[j >> K][j & (L - 1)]);

			i++; j--;
		}

		if (j < _K)
			Left = i;
		if (_K < i)
			Right = j;
	}

	return Search (_K);
}

 Разширяване и свиване на вектора
Тези операции са необходими, когато броят на елементите във вектора стане по-голям или значително по-малък от заделената памет. Разширяването на вектора се извършва като големината на дековете се увеличава с 2, заделяйки място за 4 пъти повече елементи във вектора отколкото има в момента на разширяването. Свиването се извършва когато броят на елементите е 8 пъти по-малък от заделеното място. Причината свиването да се прави чак когато елементите са станали толкова малко (8 пъти по-малко, а не например 4 пъти по-малко) е за да се избегне многократно свиване и разширяване при брой на елементи клонящ към 'критична' точка.


void TieredVector::Expand ()
{
	int newL = L*2;
	deque<int>* newVector = new deque<int> [newL];

	for (int i=0; i<L; i++)
	{
		for (deque<int>::iterator j = theVector [i].begin(); j != theVector [i].end(); j++)
			newVector [i/2].push_back (*j);
	}

	L = newL;
	theVector = newVector;
	K++;
}

void TieredVector::Contract ()
{
	int newL = L/2;
	deque<int>* newVector = new deque<int> [newL];

	int currentIndex = 0;
	
	for (int i=0; i<L; i++)
	{
		for (deque<int>::iterator j = theVector [i].begin(); j != theVector [i].end(); j++)
		{
			newVector [currentIndex].push_back (*j);
			if (newVector [currentIndex].size () == newL)
				currentIndex++;
		}
	}

	theVector = newVector;
	L = newL;
	K--;
}






Взето от „http://judge.openfmi.net:9080/mediawiki/index.php/Tiered_Vector“.
			Категории: Структури от данни | Advanced Data Structures			
						
		